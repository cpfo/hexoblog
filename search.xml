<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>go环境安装</title>
    <url>/hexoblog/go/go%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>go语言环境的安装</p>
<span id="more"></span>

<p>安装就按照官网的步骤，直接安装即可，下面主要是列举下安装后的一些问题</p>
<ul>
<li>VsCode 插件安装失败的问题</li>
</ul>
<p>proxy.golang.org 访问失败，需要设置代理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go env -w GO111MODULE=on</span><br><span class="line">go env -w GOPROXY=https://goproxy.io,direct</span><br></pre></td></tr></table></figure>

<ul>
<li>verifying module: invalid GOSUMDB: malformed verifier id</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go env -w GOSUMDB=&quot;sum.golang.org&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">或者关闭包验证</span></span><br><span class="line">go env -w GOSUMDB=off</span><br></pre></td></tr></table></figure>

<ul>
<li>VsCode中红线提示</li>
</ul>
<p><code>gopls was not able to find modules in your workspace.</code></p>
<p>在 *.go文件同级目录下初始化一个新的Go模块，会自动创建一个go.mod文件<br><code>main</code> 和go文件中的package一致。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go mod init main</span><br></pre></td></tr></table></figure>

<ul>
<li>VsCode代码自动提示</li>
</ul>
<p>在VsCode的Command Palette中输入 <code>go:install/Update Tools</code>，在弹窗中把列出来的几项都选中，然后安装</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言变量和运算符</title>
    <url>/hexoblog/go/go%E8%AF%AD%E8%A8%80%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<p>主要介绍go语言变量，运算符等</p>
<span id="more"></span>

<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>变量被定义为程序运行时储存和操纵数据的实体。变量可以通过变量名访问。 变量名格式：字母数字下划线，不能以数字开头。</p>
<p>变量声明:</p>
<blockquote>
<p>var variable_name variable_type</p>
</blockquote>
<p>也可以一次声明多个变量</p>
<blockquote>
<p>var variable_name, variable_name1 variable_type</p>
</blockquote>
<h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><ul>
<li><strong>指定变量类型，如果没有初始化，则变量默认为零值。</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println()</span><br><span class="line"><span class="comment">// 默认false</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">bool</span></span><br><span class="line">fmt.Println(b)</span><br><span class="line"><span class="comment">// 默认 &quot;&quot; 空字符串</span></span><br><span class="line"><span class="keyword">var</span> s <span class="type">string</span></span><br><span class="line">fmt.Println(s)</span><br><span class="line"><span class="comment">// 默认0</span></span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">fmt.Println(i)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>第二种， 根据值自行判定变量类型</strong></li>
</ul>
<p>不需要显示声明变量类型，自动推断</p>
<blockquote>
<p>var v_name &#x3D; value</p>
</blockquote>
<p>比如:  <code>var num = 1</code></p>
<ul>
<li><strong>变量的简短声明</strong></li>
</ul>
<p><code>x := 1</code>  这个代码中， <code>x</code> 自动被声明为 int 类型，并存储了值 1 。 这种方式只能被用在函数体内。</p>
<p>如果变量已经使用 <code>var</code> 声明过了，再使用 <code>:=</code> 声明变量，就产生编译错误</p>
<ul>
<li><strong>多变量声明</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 <span class="type">int</span></span><br><span class="line">vname1, vname2, vname3 = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">fmt.Println(vname1, vname2, vname3)</span><br><span class="line"></span><br><span class="line">vname4, vname5 := <span class="number">4</span>, <span class="number">5</span></span><br><span class="line">a, b, c := <span class="number">5</span>, <span class="number">7</span>, <span class="string">&quot;abc&quot;</span></span><br><span class="line">fmt.Println(vname4, vname5)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种因式分解关键字的写法一般用于声明全局变量</span></span><br><span class="line">   <span class="keyword">var</span> (</span><br><span class="line">       vname1 v_type1</span><br><span class="line">       vname2 v_type2</span><br><span class="line">   )</span><br></pre></td></tr></table></figure>
<h2 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h2><p>所有像 int、float、bool 和 string 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值：</p>
<p>当使用等号 <code>=</code> 将一个变量的值赋值给另一个变量时，如：<code>j = i</code>，实际上是在内存中将 <code>i</code> 的值进行了拷贝</p>
<p>可以通过 <code>&amp;i</code> 来获取变量 <code>i</code> 的内存地址</p>
<p>如下， 可以看到， <code>i</code> 和 <code>j</code> 实际上对应的内存地址是不同的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var i = 1</span><br><span class="line">var j = i</span><br><span class="line">fmt.Println(&amp;i, &amp;j)</span><br><span class="line"># 结果</span><br><span class="line">0xc00000a0e8 0xc00000a0f0</span><br></pre></td></tr></table></figure>
<p>堆内存和栈内存：栈内存用于存储局部变量以及函数调用的信息。堆内存用于存储程序中创建的对象和实例。</p>
<p>变量的值存储在堆内。</p>
<p>更复杂的数据通常会需要使用多个字，这些数据一般使用引用类型保存。</p>
<blockquote>
<p>位(Bit)是数据存储的最小单位，字节(Byte)常用于处理字符级数据，而字(Word)则是计算机硬件设计的基本单位，与特定计算机体系结构有关。</p>
</blockquote>
<p>一个引用类型的变量 <code>r1</code> 存储的是 <code>r1</code> 的值所在的内存地址（数字），或内存地址中第一个字所在的位置。</p>
<p>这个内存地址称之为指针，这个指针实际上也被存在另外的某一个值中。</p>
<p>引用类型的变量存储的是一个指向实际数据的引用。</p>
<p>当将一个引用类型的变量赋值给另一个变量时，两个变量将引用同一个数据，修改一个变量会影响到另一个变量。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>同一个变量不能被重复初始化声明 ，会提示 <code>no new variables on left side of :=</code></li>
<li>声明了局部变量没有使用，会编译报错 <code>xxx declared but not used</code></li>
<li>如果你想要交换两个变量的值，则可以简单地使用 <code>a, b = b, a</code>，两个变量的类型必须是相同</li>
<li>空白标识符 _ 也被用于抛弃值，如值 5 在：<code>_, b = 5, 7</code> 中被抛弃。</li>
<li>_ 实际上是一个只写变量，你不能得到它的值。这样做是因为 Go 语言中你必须使用所有被声明的变量，但有时你并不需要使用从一个函数得到的所有返回值。</li>
<li>并行赋值也被用于当一个函数返回多个返回值时，比如这里的 <code>val</code> 和错误 <code>err</code> 是通过调用 <code>Func1</code> 函数同时得到：<code>val, err = Func1(var1)</code>。</li>
</ul>
<h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>常量是一个简单值的标识符，在程序运行时，不会被修改的量。</p>
<p>常量中的数据类型只可以是布尔型、数字型和字符串型。</p>
<p>定义格式如下</p>
<blockquote>
<p>const identifier [type] &#x3D; value</p>
</blockquote>
<p>可以省略类型说明符 <code>[type]</code>，因为编译器可以根据变量的值来推断其类型。</p>
<p>常量也可以用作枚举</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Unknown = <span class="number">0</span></span><br><span class="line">	Female  = <span class="number">1</span></span><br><span class="line">	Male    = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>数字 0、1 和 2 分别代表未知性别、女性和男性。</p>
<p>常量可以用<code>len()</code>, <code>cap()</code>, <code>unsafe.Sizeof()</code>函数计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="string">&quot;abc&quot;</span></span><br><span class="line">    b = <span class="built_in">len</span>(a)</span><br><span class="line">    c = unsafe.Sizeof(a)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言结构和基础语法</title>
    <url>/hexoblog/go/go%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E5%92%8C%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>简单介绍下go语言的程序结构，基础语法和数据类型。</p>
<span id="more"></span>

<h1 id="结构示例"><a href="#结构示例" class="headerlink" title="结构示例"></a>结构示例</h1><p>go语言的基础组成包含以下部分</p>
<ul>
<li>包声明</li>
<li>引入包 </li>
<li>函数</li>
<li>变量</li>
<li>语句和表达式</li>
<li>注释</li>
</ul>
<p>以下面代码为例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">/*输出hello world*/</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>第一行代码 <code>package main</code> 定义了包名。必须在源文件中非注释的第一行指明这个文件属于哪个包，如：<code>package main</code>。<code>package main</code>表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 <code>main</code> 的包。</li>
<li>下一行 <code>import &quot;fmt&quot;</code> 告诉 Go 编译器这个程序需要使用 <code>fmt</code> 包，<code>fmt</code> 包实现了格式化 IO（输入&#x2F;输出）的函数。</li>
<li>下一行 <code>func main()</code> 是程序开始执行的函数。<code>main</code> 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 <code>init()</code> 函数则会先执行该函数）</li>
<li><code>/**/</code> 是注释。可以在任何地方使用以 <code>//</code> 开头的单行注释。多行注释也叫块注释，均已以 <code>/*</code> 开头，并以 <code>*/</code> 结尾</li>
<li><code>fmt.Println()</code> 将字符串输出到控制台</li>
<li>当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如<code>Print</code>，那么使用这种形式的标识符的对象就可以被外部包的代码所使用(需要先引入)，这被称为导出(像java中的public)，标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像java的<code>protected</code> ）</li>
</ol>
<h1 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a>运行代码</h1><p>运行go文件</p>
<blockquote>
<p>go run hello.go</p>
</blockquote>
<p>也可以生成二进制文件</p>
<blockquote>
<p>go build hello.go</p>
</blockquote>
<p><code>&#123;</code> 不能单独放在一行， 和java不同。</p>
<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><ul>
<li>行分隔符</li>
</ul>
<p>语句结束是由分号（;）标志，但是代码不需要添加，Go编译器会自动在每行结束的地方插入分号。一行代表一个语句结束。</p>
<ul>
<li>注释</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 单行注释</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">多行注释</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<ul>
<li>标识符</li>
</ul>
<p>标识符用来命名变量、类型等程序实体。</p>
<p>必须是字母数字下划线组成，但是第一个字符必须是字母或者下划线，不能是数字。</p>
<ul>
<li>字符串连接</li>
</ul>
<p>字符串连接使用 <code>+</code> 操作</p>
<blockquote>
<p>fmt.Println(“hello, “ + “world”)</p>
</blockquote>
<ul>
<li>关键字</li>
</ul>
<p>有25个关键字</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">break        default      func         interface    select</span><br><span class="line">case         defer        go           map          struct</span><br><span class="line">chan         else         goto         package      switch</span><br><span class="line">const        fallthrough  if           range        type</span><br><span class="line">continue     for          import       return       var</span><br></pre></td></tr></table></figure>

<p>36个预定义标识符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">append       bool         byte         cap          close        complex      </span><br><span class="line">complex64    complex128   uint16       copy         false        float32      </span><br><span class="line">float64      imag         int          int8         int16        uint32       </span><br><span class="line">int32        int64        iota         len          make         new          </span><br><span class="line">nil          panic        print        println      real         recover      </span><br><span class="line">string       true         uint         uint8        uint64       uintptr      </span><br></pre></td></tr></table></figure>

<p>程序一般由关键字、常量、变量、运算符、类型和函数组成。</p>
<ul>
<li>空格</li>
</ul>
<p>空格通常用于分隔标识符、关键字、运算符和表达式，以提高代码的可读性。</p>
<ol>
<li>变量的声明必须使用空格隔开</li>
<li>关键字和表达式之间要使用空格</li>
</ol>
<ul>
<li>格式化字符串</li>
</ul>
<p>Go 语言中使用 <code>fmt.Sprintf</code> 或 <code>fmt.Printf</code> 格式化字符串并赋值给新串</p>
<p><code>Sprintf</code> 根据格式化参数生成格式化的字符串并返回该字符串<br><code>Printf</code>  根据格式化参数生成格式化的字符串并写入标准输出</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/*输出hello world*/</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;hello, &quot;</span> + <span class="string">&quot;world&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> url = <span class="string">&quot;name=%s&amp;num=%d&quot;</span></span><br><span class="line">	<span class="keyword">var</span> num = <span class="number">1</span></span><br><span class="line">	<span class="keyword">var</span> name = <span class="string">&quot;张三&quot;</span></span><br><span class="line">	<span class="keyword">var</span> result = fmt.Sprintf(url, name, num)</span><br><span class="line">	fmt.Println(result)</span><br><span class="line">	fmt.Printf(url, name, num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>数据类型用于声明函数和变量。数据类型是为了把数据分成内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。</p>
<ol>
<li>布尔型</li>
</ol>
<p>布尔型只能是true或者false， 例如 <code>var b bool = true</code></p>
<ol start="2">
<li>数字类型</li>
</ol>
<p>整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。</p>
<p>还区分有符号和无符号的</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>uint8</td>
<td>无符号 8 位整型 (0 到 255)</td>
</tr>
<tr>
<td>uint16</td>
<td>无符号 16 位整型 (0 到 65535)</td>
</tr>
<tr>
<td>uint32</td>
<td>无符号 32 位整型 (0 到 4294967295)</td>
</tr>
<tr>
<td>uint64</td>
<td>无符号 64 位整型</td>
</tr>
<tr>
<td>int8</td>
<td>有符号 8 位整型 (-128 到 127)</td>
</tr>
<tr>
<td>int16</td>
<td>有符号 16 位整型 (-32768 到 32767)</td>
</tr>
<tr>
<td>int32</td>
<td>有符号 32 位整型 (-2147483648 到 2147483647)</td>
</tr>
<tr>
<td>int64</td>
<td>有符号 64 位整型</td>
</tr>
</tbody></table>
<ol start="3">
<li>字符串类型</li>
</ol>
<p>字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。使用 <code>UTF-8</code> 编码</p>
<ol start="4">
<li><p>派生类型</p>
<ul>
<li>指针类型（Pointer）</li>
<li>数组类型</li>
<li>结构化类型(struct)</li>
<li>Channel 类型</li>
<li>函数类型</li>
<li>切片类型</li>
<li>接口类型（interface）</li>
<li>Map 类型</li>
</ul>
</li>
</ol>
<p>派生类型(也称为复合类型)</p>
<ol start="5">
<li>其他数字类型</li>
</ol>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>类似 uint8</td>
</tr>
<tr>
<td>rune</td>
<td>类似 int32</td>
</tr>
<tr>
<td>uint</td>
<td>32 或 64 位</td>
</tr>
<tr>
<td>int</td>
<td>与 uint 一样大小</td>
</tr>
<tr>
<td>uintptr</td>
<td>无符号整型，用于存放一个指针</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>shardingsphere分库分表</title>
    <url>/hexoblog/java/shardingsphere%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</url>
    <content><![CDATA[<p>主要记录使用shardingsphere-jdbc 5.2.0进行分库，分表，分库加分表，读写分离，自定义复合分片算法等的操作步骤。</p>
<span id="more"></span>

<h1 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h1><h2 id="基因法"><a href="#基因法" class="headerlink" title="基因法"></a>基因法</h2><blockquote>
<p>基因法原理 : 对一个数取余2的n次方，那么余数就是这个数的二进制的最后n位数。</p>
</blockquote>
<ul>
<li>举例</li>
</ul>
<p>十进制数对10的n次幂取余，余数是10进制数的最后n位， 比如</p>
<p>11 % 10，余数 1</p>
<p>122 % 10，余数 2</p>
<p>122 % 100 , 余数 22</p>
<p>同理，对一个数取余2的n次方，余数就是这个数的二进制的最后n位数，然后可以再转为10进制。</p>
<h2 id="为什么分片数要是2的n次幂"><a href="#为什么分片数要是2的n次幂" class="headerlink" title="为什么分片数要是2的n次幂"></a>为什么分片数要是2的n次幂</h2><ul>
<li>可以将取模算法优化成性能更高的位运算算法。</li>
</ul>
<p>如： 11 % 4 等于 11 &amp; (4-1) </p>
<ul>
<li>可以将表在多个库中均匀分布。</li>
</ul>
<p>通常分表会和分库一起进行，比如需要分成2个库8个表，分表和分库的数量都是2的n次幂，可以实现均匀分布，8个表均分到2个库中，每个库4个表。</p>
<ul>
<li>第三个也是最重要的原因，可以减少扩容时迁移的数据量，只需要迁移一半。</li>
</ul>
<p>比如 原来分2个表，order_0,order_1</p>
<ol>
<li>userId % 2 &#x3D; 0 ，对应 order_0</li>
<li>userId % 2 &#x3D; 1 , 对应 order_1</li>
</ol>
<p>此时扩容到4个表</p>
<ol>
<li>userId % 4 &#x3D; 0 ，对应 order_0</li>
<li>userId % 4 &#x3D; 1 , 对应 order_1</li>
<li>userId % 4 &#x3D; 2 ，对应 order_2</li>
<li>userId % 4 &#x3D; 3 , 对应 order_3</li>
</ol>
<p>只需要迁移原来在 order_0, order_1 中，且 userId % 4 &gt;&#x3D;2 数据就行。</p>
<ol>
<li>userId % 4 &#x3D; 2的数据， 从 order_0 迁移到 order_2 </li>
<li>userId % 4 &#x3D; 3的数据， 从order_1  迁移到 order_3</li>
</ol>
<h1 id="具体配置和操作"><a href="#具体配置和操作" class="headerlink" title="具体配置和操作"></a>具体配置和操作</h1><p>以电商系统中用户的订单表为例。</p>
<p>电商系统中，常见的业务场景是通过userId查询用户的订单列表，因此使用userId作为分片键，查询时可以快速定位到数据库和表。</p>
<p>但是也会有通过订单号进行查询的情况，默认情况下，非分片键的查询，需要在所有分片上进行查询，然后对结果进行聚合，这样效率非常低，日志中sql如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Actual SQL: ds0 ::: SELECT  user_id,order_id,address_id,status  FROM t_order_0 </span><br><span class="line"> WHERE order_id = ? UNION ALL SELECT  user_id,order_id,address_id,status  FROM t_order_1 </span><br><span class="line"> WHERE order_id = ? ::: </span><br></pre></td></tr></table></figure>
<p>此时可以考虑新增一个订单号和userId的映射关系表即索引表。</p>
<h2 id="索引表法"><a href="#索引表法" class="headerlink" title="索引表法"></a>索引表法</h2><p>将订单号和userId的映射关系，单独保存到一个表中，通过订单号进行查询时，先从索引表中查询到对应的userId，然后在查询条件中加上userId，这样只需要2步就可以查询出结果。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> user_id <span class="keyword">from</span> order_user_relation <span class="keyword">where</span> order_id <span class="operator">=</span> xxx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_order <span class="keyword">where</span> order_id <span class="operator">=</span> xxx <span class="keyword">and</span> user_id <span class="operator">=</span> xxx;</span><br></pre></td></tr></table></figure>

<p>为了提升查询效率，可以在加上一层分布式缓存，将映射关系保存到redis中。但是这样会带来一定的问题，比如数据库和缓存的存储量增大。</p>
<h2 id="基因法自定义复合分片算法"><a href="#基因法自定义复合分片算法" class="headerlink" title="基因法自定义复合分片算法"></a>基因法自定义复合分片算法</h2><p>为了解决聚合查询或者索引表的问题，业界一般采用基因法来将分片键的信息，保存到非分片键中，比如取userId的后4位，拼接到order_id后面。</p>
<p>假设订单号的规则为 :  时间戳 + 随机数 + 用户id后四位。这样可以从订单号的后四位中截取到用户id的基因，可以定位到具体的分片位置，一次查询就可以查到对应的数据。</p>
<p>比如淘宝的订单号，后6位都是一样的，大概率也是用户id的后6位。</p>
<ul>
<li>算法实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;String&gt; <span class="title function_">doSharding</span><span class="params">(Collection availableTargetNames, ComplexKeysShardingValue complexKeysShardingValue)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> availableTargetNames.size();</span><br><span class="line">        <span class="comment">// 判断分片数必须是2的整数次幂</span></span><br><span class="line">        <span class="keyword">if</span> ((count &amp; (count - <span class="number">1</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;分片数不是2的整数次幂，当前分片数 &#123;&#125;&quot;</span>, count);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;分片数量不是2的整数次幂，当前数量:&quot;</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(availableTargetNames);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//        String logicName = complexKeysShardingValue.getLogicTableName();</span></span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">&quot;availableTargetNames的值 &#123;&#125;&quot;</span>, JSON.toJSONString(availableTargetNames));</span><br><span class="line">        log.debug(<span class="string">&quot;complexKeysShardingValue &#123;&#125;&quot;</span>, JSON.toJSONString(complexKeysShardingValue));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先判断userId， 如果有userId， 则直接计算</span></span><br><span class="line">        Map&lt;String, Collection&lt;Comparable&lt;?&gt;&gt;&gt; nameAndValueMap = complexKeysShardingValue.getColumnNameAndShardingValuesMap();</span><br><span class="line">        Collection&lt;Comparable&lt;?&gt;&gt; userIdValueCollection = nameAndValueMap.get(userIdKey);</span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(userIdValueCollection)) &#123;</span><br><span class="line">            userIdValueCollection.stream().findFirst().ifPresent(o -&gt; &#123;</span><br><span class="line">                <span class="type">Long</span> <span class="variable">index</span> <span class="operator">=</span> (Long) o % count;</span><br><span class="line">                log.debug(<span class="string">&quot;以userid &#123;&#125; 对 分片数&#123;&#125; 取余的结果为 &#123;&#125;&quot;</span>, o, count, index);</span><br><span class="line"><span class="comment">//                result.add(logicName + &quot;_&quot; + index);</span></span><br><span class="line">                result.add(String.valueOf(list.get(index.intValue())));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 从订单号中截取用户id基因</span></span><br><span class="line">            Collection&lt;Comparable&lt;?&gt;&gt; orderIdCollection = nameAndValueMap.get(orderIdKey);</span><br><span class="line">            orderIdCollection.stream().findFirst().ifPresent(comparable -&gt; &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">orderId</span> <span class="operator">=</span> String.valueOf(comparable);</span><br><span class="line">                <span class="type">String</span> <span class="variable">subString</span> <span class="operator">=</span> orderId.substring(orderId.length() - userIdSuffixLength);</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Integer.parseInt(subString) % count;</span><br><span class="line">                log.debug(<span class="string">&quot;orderId中基因 &#123;&#125; 对 分片数&#123;&#125; 取余的结果为 &#123;&#125;&quot;</span>, subString, count, index);</span><br><span class="line"><span class="comment">//                result.add(logicName + &quot;_&quot; + index);</span></span><br><span class="line">                result.add(String.valueOf(list.get(index)));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>配置信息</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模式配置</span></span><br><span class="line"><span class="attr">spring.shardingsphere.mode.type</span>=<span class="string">Standalone</span></span><br><span class="line"><span class="attr">spring.shardingsphere.mode.repository.type</span>=<span class="string">JDBC</span></span><br><span class="line"><span class="comment"># 数据源配置 配置真实数据源</span></span><br><span class="line"><span class="attr">spring.shardingsphere.datasource.names</span>=<span class="string">ds0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring.shardingsphere.datasource.ds0.jdbc-url</span>=<span class="string">jdbc:mysql://localhost:3306/shop_ds_0?serverTimezone=Asia/Shanghai&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line"><span class="attr">spring.shardingsphere.datasource.ds0.type</span>=<span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line"><span class="attr">spring.shardingsphere.datasource.ds0.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">spring.shardingsphere.datasource.ds0.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.shardingsphere.datasource.ds0.password</span>=<span class="string">root</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 广播表规则列表</span></span><br><span class="line"><span class="attr">spring.shardingsphere.rules.sharding.broadcast-tables</span>=<span class="string">t_address</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 标准分片表配置</span></span><br><span class="line"><span class="comment"># 由数据源名 + 表名组成，以小数点分隔。多个表以逗号分隔，支持 inline 表达式。</span></span><br><span class="line"><span class="comment"># 缺省表示使用已知数据源与逻辑表名称生成数据节点，用于广播表（即每个库中都需要一个同样的表用于关联查询，多为字典表）或只分库不分表且所有库的表结构完全一致的情况</span></span><br><span class="line"><span class="attr">spring.shardingsphere.rules.sharding.tables.t_order.actual-data-nodes</span>=<span class="string">ds0.t_order_$-&gt;&#123;0..1&#125;</span></span><br><span class="line"><span class="comment"># 复合分片，自定义策略</span></span><br><span class="line"><span class="attr">spring.shardingsphere.rules.sharding.tables.t_order.table-strategy.complex.sharding-columns</span>=<span class="string">user_id,order_id</span></span><br><span class="line"><span class="comment"># 分片算法名称</span></span><br><span class="line"><span class="attr">spring.shardingsphere.rules.sharding.tables.t_order.table-strategy.complex.sharding-algorithm-name</span>=<span class="string">t_order_complex_custom_algorithm</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 自定义复合分片算法</span></span><br><span class="line"><span class="attr">spring.shardingsphere.rules.sharding.sharding-algorithms.t_order_complex_custom_algorithm.type</span>=<span class="string">CLASS_BASED</span></span><br><span class="line"><span class="attr">spring.shardingsphere.rules.sharding.sharding-algorithms.t_order_complex_custom_algorithm.props.strategy</span>=<span class="string">complex</span></span><br><span class="line"><span class="attr">spring.shardingsphere.rules.sharding.sharding-algorithms.t_order_complex_custom_algorithm.props.algorithmClassName</span>=<span class="string">com.bsd.xxyp.sharding.config.GeneComplexKeysShardingAlgorithm</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ol>
<li><a href="https://tech.meituan.com/2016/11/18/dianping-order-db-sharding.html">大众点评订单系统分库分表实践</a></li>
<li><a href="https://community.sphere-ex.com/t/topic/674">基于Apache ShardingSphere的核心业务分库分表实践</a></li>
<li><a href="https://www.cnblogs.com/chengxy-nds/p/18108596">DIY 3 种分库分表分片算法</a></li>
<li><a href="https://mp.weixin.qq.com/s/PqXJKXCzQlMVwR4EjPpXew">实战：Springboot3+ShardingSphere5.2.1生产级分库分表实现</a></li>
<li><a href="https://mp.weixin.qq.com/s/TdCqxsBeSnugWXP_MuosdQ">聊聊分库分表后非Sharding Key查询的三种方案</a></li>
<li><a href="https://mp.weixin.qq.com/s/6sI92hEH6Sxt7nzXWDW-kA">一些补充的知识点-MySQL大表分库分表基因法</a></li>
<li><a href="https://mp.weixin.qq.com/s/3cP_emfG15qJapeQwV5gtQ">看完这一篇，ShardingSphere-jdbc 实战再也不怕了</a></li>
<li><a href="https://www.cnblogs.com/chengxy-nds/p/17513945.html">SpringBoot 2 种方式快速实现分库分表，轻松拿捏</a></li>
<li><a href="https://mp.weixin.qq.com/s/1syeeqzusxt4Z-yJff0mng">分布式数据库：如何正确选择分片键？</a></li>
</ol>
<h1 id="FAQ整理"><a href="#FAQ整理" class="headerlink" title="FAQ整理"></a>FAQ整理</h1><ol>
<li>点评的文章中，userid后4位，为什么说最大是8192个表</li>
</ol>
<p>按照上面的规范，分片数必须是2的n次幂，4位数的最大值是9999，假设分片数是 2的14次幂 16384，4位数字对16384取余的结果范围是[0, 9999], 实际计算出来需要的分片数是10000个，不是2的n次幂，不满足分片数规则。<br>所以最大只能取 8192 个</p>
<ol start="2">
<li>点评的方式和基因法的区别。</li>
</ol>
<p>点评文章中userid和orderid的取模都是用的userid的后四位，所以最大是8192个。基因法里面，通过userid计算分片是按照userid % 2^n，按照订单id计算分片 &#x3D; orderId.substring(length-4) % 2^n，<br>是使用订单号的后四位进行计算，所以userid后四位的最大分片数是16个。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>shardingsphere</tag>
      </tags>
  </entry>
  <entry>
    <title>雪花算法 百度uid-generator生成的id变成负数</title>
    <url>/hexoblog/java/snowflake-baidu-uid-generator/</url>
    <content><![CDATA[<p>项目使用了百度的uid-generator来生成唯一ID，在2024-11-21时候，观察到部分项目生成的id变成了负数，下面分析了具体的原因以及给出了解决思路。</p>
<span id="more"></span>

<h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>在 <code>2024-11-21</code> 当天，开发环境发现了部分项目生成的id变成了负数，产生了业务异常，无法入库，经过排查，发现是由于使用了百度的uid-generator进行id生成，配置不当导致的。</p>
<p>项目中同时使用了 <code>DefaultUidGenerator</code> 和 <code>CachedUidGenerator</code> 两种生成策略。但是，在初始化配置时，只针对 <code>DefaultUidGenerator</code> 进行了调整，<code>CachedUidGenerator</code> 使用的默认值。</p>
<p>查看代码，发现 CachedUidGenerator 继承自 DefaultUidGenerator，在sequence上做了调整，但是前面依然是雪花算法的策略。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* +------+----------------------+----------------+-----------+</span><br><span class="line">* | sign |     delta seconds    | worker node id | sequence  |</span><br><span class="line">* +------+----------------------+----------------+-----------+</span><br><span class="line">*   1bit          28bits              22bits         13bits</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Snowflake算法描述：指定机器 &amp; 同一时刻 &amp; 某一并发序列，是唯一的。据此可生成一个64 bits的唯一ID（long）。默认采用上图字节分配方式：</p>
<ul>
<li><p>sign(1bit)<br>固定1bit符号标识，即生成的UID为正数。</p>
</li>
<li><p>delta seconds (28 bits)<br>当前时间，相对于时间基点”2016-05-20”的增量值，单位：秒，最多可支持约8.7年</p>
</li>
<li><p>worker id (22 bits)<br>机器id，最多可支持约420w次机器启动。内置实现为在启动时由数据库分配，默认分配策略为用后即弃，后续可提供复用策略。</p>
</li>
<li><p>sequence (13 bits)<br>每秒下的并发序列，13 bits可支持每秒8192个并发。</p>
</li>
</ul>
<p>在 <code>DefaultUidGenerator</code> 中有说明，默认配置是从<code>2016-05-20</code>开始，大概支持8.7年，到<code>2024-11-20 21:24:16</code></p>
<blockquote>
<p>delta seconds: The next 28 bits, represents delta seconds since a customer epoch(2016-05-20 00:00:00.000).</p>
<p>Supports about 8.7 years until to 2024-11-20 21:24:16</p>
</blockquote>
<p>CachedUidGenerator不是每次获取当前时间戳作为时间位上的数字，而是在系统启动时获取系统时间作为基础，后续在该时间上进行递增。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 启动时获取当前时间</span></span><br><span class="line"><span class="built_in">this</span>.lastSecond = <span class="keyword">new</span> <span class="title class_">PaddedAtomicLong</span>(TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// fill the rest slots until to catch the cursor</span></span><br><span class="line">List&lt;Long&gt; uidList = uidProvider.provide(lastSecond.incrementAndGet());</span><br></pre></td></tr></table></figure>

<h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><h2 id="调整时间基点"><a href="#调整时间基点" class="headerlink" title="调整时间基点"></a>调整时间基点</h2><p>既然是由于初始时间 epochStr 导致的，可以考虑调整 epochStr 到接近当前时间的某个日期。</p>
<p>此时需要注意，如果想要保证生成的id长度固定为19位的话，新的日期不能距离当前时间太近，否则生成的id长度会发生变化。比如可以调整到1年前的日期，如 <code>2023-11-26</code> 。</p>
<p>生成id又会从 1 开头的数字开始，如 <code>1088488405369774084</code></p>
<p>这种方案会有一个风险，生成的id可能会和调整前生成的id一样，导致id重复。原因如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allocate bits for UID</span></span><br><span class="line"><span class="keyword">return</span> bitsAllocator.allocate(currentSecond - epochSeconds, workerId, sequence);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">allocate</span><span class="params">(<span class="type">long</span> deltaSeconds, <span class="type">long</span> workerId, <span class="type">long</span> sequence)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (deltaSeconds &lt;&lt; timestampShift) | (workerId &lt;&lt; workerIdShift) | sequence;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>理论上，获取id时的时间戳和基准时间的差值(currentSecond - epochSeconds)如果一致，生成的id就会相同。</p>
<p>所以此方案可以用于临时紧急修复问题，不能长期使用。</p>
<h2 id="调整位数的划分"><a href="#调整位数的划分" class="headerlink" title="调整位数的划分"></a>调整位数的划分</h2><p>可以调整 <code>timeBits</code> 到30位，增大2位，<code>seqBits</code> 调整到11位，减少2位。 此时可以支持的时间为2^30 -1 , 大概是34年，而每秒可以生成的序列为 2^11-1&#x3D;2047个。理论上也能满足大部分系统的并发场景需要。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Bits allocate */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="variable">timeBits</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="variable">workerBits</span> <span class="operator">=</span> <span class="number">22</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="variable">seqBits</span> <span class="operator">=</span> <span class="number">11</span>;</span><br></pre></td></tr></table></figure>
<p>调整之后，生成的id又会从一个较小的数字开始，理论上到达某个条件之后，生成的id还是有可能和历史已生成的id重复的可能，需要注意。</p>
<p>或者还可以调整 <code>workerBits</code> 的位数，默认是22位，接近420w次重启， 实际上可以按需进行取舍，考虑重复使用workId或者循环利用。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在系统初始阶段，最好就要先确定好位数的划分，比如增大 timeBits ，保证系统可以支持到更长的时间。减少workerBits，调整 seqBits 等。</p>
<ul>
<li><p>为什么线上系统在11-21号的时候没有报错</p>
<p>  由于线上大部分使用的是 <code>CachedUidGenerator</code>，所以是从系统启动时刻的时间戳开始计算的，如果系统近期没有重启，<code>lastSecond</code>会小于当前时间戳，并不会溢出。</p>
</li>
<li><p>为什么使用 CachedUidGenerator 生成的id顺序不是严格一致的。</p>
<ol>
<li>由于使用了 RingBuffer，如果流量不均衡的话，不同机器上消耗的速度是不同的，可能导致某些机器上消费的速度快，lastSecond 增长的快。</li>
<li>如果服务使用了动态的扩容缩容方案，不同节点的启动时间相差也会很大，后启动的机器，lastSecond会大点，生成的id 也会偏大。</li>
</ol>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md">uid-generator readme</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>snowflake</tag>
        <tag>唯一ID</tag>
      </tags>
  </entry>
  <entry>
    <title>使用RateLimiter进行限流</title>
    <url>/hexoblog/java/%E4%BD%BF%E7%94%A8RateLimiter%E8%BF%9B%E8%A1%8C%E9%99%90%E6%B5%81/</url>
    <content><![CDATA[<p>主要介绍使用RateLimiter进行请求的限流。</p>
<span id="more"></span>


<p>场景: 和第三方对接的项目中，为对接的第三方分配一个appid，需要针对appid进行限流，限制每个appid的请求不能超过指定的qps。</p>
<h1 id="Guava-RateLimiter"><a href="#Guava-RateLimiter" class="headerlink" title="Guava RateLimiter"></a>Guava RateLimiter</h1><p><code>RateLimiter</code> 是针对单机进行限流的，但是在实际的生产环境中，服务一般是通过集群的方式进行部署。假设限制的QPS是300，集群一共5台机器，如果流量分布均衡的话，每台机器的QPS是 <code>300/5 = 60</code> 。</p>
<p>但实际上，通过轮询的方式，流量不可能做到绝对的均匀，所以可以预留一定的空间，比如每台机器的qps限制在80，这样即使某台机器的流量稍微偏高，也不太可能超过限制被拦截掉。</p>
<p>此种方式适合对限流不是很严格的情况，即使部分请求被拦截，也不影响业务。</p>
<p><code>RateLimiter.create(rate)</code> 创建指定QPS的RateLimiter。</p>
<p><code>tryAcquire()</code>  以非阻塞的方式获取令牌。</p>
<h1 id="RedissonRateLimiter"><a href="#RedissonRateLimiter" class="headerlink" title="RedissonRateLimiter"></a>RedissonRateLimiter</h1><p><code>RedissonRateLimiter</code> 是redisson中提供的分布式限流器。</p>
<p><code>getRateLimiter(String name)</code> 获取对应name的 rate limiter。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRateController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, RateLimiter&gt; rateLimiterMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 针对appid配置请求频率</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ApolloJsonValue(&quot;$&#123;qps.rate:&#123;&#125;&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; appIdRateMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/rate/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testRateLimiter</span><span class="params">(<span class="meta">@RequestParam</span> String appId)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> tryAcquire(appId);</span><br><span class="line">        log.info(<span class="string">&quot;获取限流的结果为 &#123;&#125;&quot;</span>, result);</span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;rate limiter&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/redisson/rate&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">redissonRateLimiter</span><span class="params">(<span class="meta">@RequestParam</span> String appId)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">RRateLimiter</span> <span class="variable">clientRateLimiter</span> <span class="operator">=</span> redissonClient.getRateLimiter(<span class="string">&quot;limiter:&quot;</span>.concat(appId));</span><br><span class="line">        <span class="keyword">if</span> (!clientRateLimiter.isExists()) &#123;</span><br><span class="line">            clientRateLimiter.setRate(RateType.OVERALL, <span class="number">1</span>, <span class="number">1</span>, RateIntervalUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> clientRateLimiter.tryAcquire();</span><br><span class="line">        log.info(<span class="string">&quot;获取限流的结果为 &#123;&#125;&quot;</span>, result);</span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;rate limiter&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(String appId)</span> &#123;</span><br><span class="line">        Assert.notNull(appId, <span class="string">&quot;appId不能为空&quot;</span>);</span><br><span class="line">        <span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> rateLimiterMap.computeIfAbsent(appId, s -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;初始化appid &#123;&#125; 的限流器&quot;</span>, appId);</span><br><span class="line">            <span class="type">int</span> <span class="variable">rate</span> <span class="operator">=</span> appIdRateMap.getOrDefault(appId, <span class="number">70</span>);</span><br><span class="line">            <span class="keyword">return</span> RateLimiter.create(rate);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> rateLimiter.tryAcquire();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>RateLimiter</tag>
      </tags>
  </entry>
  <entry>
    <title>1.python基础</title>
    <url>/hexoblog/python/1.python%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>python输入输出，基础数据类型和变量。</p>
<span id="more"></span>

<h1 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h1><ul>
<li><p>输入</p>
<blockquote>
<p>name &#x3D; input(‘请输入xx’)</p>
</blockquote>
</li>
<li><p>输出</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(<span class="string">&#x27;hello aa&#x27;</span>)</span></span><br><span class="line">hello aa</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;haha&#x27;</span>)</span></span><br><span class="line">hello 张三 haha</span><br></pre></td></tr></table></figure>
<p><code>print()</code> 输出时，遇到逗号 <code>,</code> 会转换成空格</p>
<h1 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h1><h2 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h2><ul>
<li><strong>整数</strong></li>
</ul>
<p>十六进制，使用 <code>0x</code> 开头</p>
<p>比较大的数，允许使用下划线 <code>_</code> 进行分隔，如 <code>10_000_000_000</code></p>
<ul>
<li><strong>浮点数</strong></li>
</ul>
<p>浮点数可以用数学写法，比如 <code>1.231</code>, 比较大的浮点数需要用科学计数法，把10用e替代， 比如 1.23x10^9，就是<code>1.23e9</code></p>
<ul>
<li><strong>字符串</strong></li>
</ul>
<p>字符串用单引号 <code>&#39;</code> 或者 双引号 <code>&quot;</code> 括起来，转义使用 <code>\</code> ，如果字符串里面有多个字符需要转义，可以使用 <code>r&#39;&#39;</code> ，表示<code>&#39;&#39;</code> 里面的字符串不转义。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(r<span class="string">&#x27;\r\n\t\r\n\t&#x27;</span>)</span></span><br><span class="line">\r\n\t\r\n\t</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>
<p>字符串转数字， int(123)</p>
<ul>
<li><strong>布尔值</strong></li>
</ul>
<p>使用 <code>True</code> 和 <code>False</code> 表示，注意大小写。</p>
<p>布尔值可以使用 <code>and</code> <code>or</code> 和 <code>not</code> 进行运算。 <code>and</code>是与运算，<code>or</code>是或运算，<code>not</code>是非运算，单目运算，取反。</p>
<ul>
<li><strong>空值</strong></li>
</ul>
<p>空值使用 <code>None</code> 表示， 空值是一种特殊值。</p>
<ul>
<li><strong>变量</strong></li>
</ul>
<p>变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和<code>_</code>的组合，且不能用数字开头，和 java 一样</p>
<p>在Python中，等号<code>=</code>是赋值语句，动态语言，同一个变量可以多次赋值，也可以赋不同类型的值。</p>
<p>变量的指向:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; a = <span class="string">&#x27;ABC&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; b = a</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; a = <span class="string">&#x27;XYZ&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(b)</span></span><br><span class="line">ABC</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>内存中创建了 <code>ABC</code> 字符串</li>
<li>内存中创建了名为 <code>a</code>的变量，并把它指向了 <code>ABC</code></li>
<li>创建了<code>b</code>，并把<code>b</code>指向了<code>a</code>所指向的数据<code>ABC</code></li>
<li>重新把 <code>a</code> 指向了 <code>XYZ</code></li>
</ol>
<ul>
<li><strong>常量</strong></li>
</ul>
<p>用全部大写的变量名表示常量</p>
<p>除法 分为 <code>/</code> 和 <code>//</code> 地板除， <code>/</code>结果是浮点数，即使能够整除，结果也是浮点数，<code>//</code> 结果是整数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; 10/3</span></span><br><span class="line">3.3333333333333335</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; 9/3</span></span><br><span class="line">3.0</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; 10//3</span></span><br><span class="line">3</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串和编码"><a href="#字符串和编码" class="headerlink" title="字符串和编码"></a>字符串和编码</h2><p>一个字节(byte)使用8位(bit)， <code>UTF-8</code> 变长编码。</p>
<p>python的字符串类型是 <code>str</code>， 在内存中以Unicode表示，一个字符对应若干个字节。</p>
<p>对 <code>bytes</code>类型的数据，使用 <code>b</code>前缀的单引号或者双引号表示。</p>
<p>对单个字符的编码，<code>ord()</code> 函数获取字符的整数表示，<code>chr()</code>函数把编码转换为对应的字符。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; ord(<span class="string">&#x27;a&#x27;</span>)</span></span><br><span class="line">97</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; ord(<span class="string">&#x27;人&#x27;</span>)</span></span><br><span class="line">20154</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; chr(78)</span></span><br><span class="line">&#x27;N&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="string">&#x27;\u4e2d\u6587&#x27;</span></span></span><br><span class="line">&#x27;中文&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以 <code>Unicode</code>表示的 <code>str</code> 可以使用 <code>encode()</code>函数编码为指定的 <code>bytes</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="string">&#x27;abc&#x27;</span>.encode(<span class="string">&#x27;ascii&#x27;</span>)</span></span><br><span class="line">b&#x27;abc&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="string">&#x27;abc&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span></span><br><span class="line">b&#x27;abc&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="string">&#x27;中文&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span></span><br><span class="line">b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="string">&#x27;abc12&#x27;</span>.encode(<span class="string">&#x27;ascii&#x27;</span>)</span></span><br><span class="line">b&#x27;abc12&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p>相反， 从网络或者磁盘上读取到的字节流就是<code>bytes</code>，可以使用 <code>decode()</code> 方法转换为 <code>str</code></p>
<p><code>len()</code> 函数可以计算 <code>str</code>的字符数，也可以计算 <code>bytes</code> 的字节数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; len(<span class="string">&#x27;中文&#x27;</span>)</span></span><br><span class="line">2</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; len(<span class="string">&#x27;abc&#x27;</span>)</span></span><br><span class="line">3</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; len(<span class="string">&#x27;中文&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span></span><br><span class="line">6</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p>要坚持使用 UTF-8 格式的编码， 文件需要添加下面的开头</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/env python3</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure>

<p><strong>格式化问题</strong></p>
<p>格式化方法和C语言一致，用 <code>%</code> 实现。 <code>%s</code> 代表用字符串替换，<code>%d</code>代表用整数替换，<code>%f</code>代表用浮点数替换，<code>%x</code>代表用十六进制替换。</p>
<blockquote>
<p>‘Hi, %s, you have $%d.’ % (‘Michael’, 1000000)</p>
</blockquote>
<p>格式化整数和浮点数还可以指定是否补0和整数与小数的位数</p>
<ul>
<li>format()</li>
</ul>
<p>也可以使用字符串的<code>format()</code> 方法来实现，传入的参数依次替换字符串内的占位符。</p>
<ul>
<li>f-string<br>使用以 <code>f</code> 开头的字符串，称之为 <code>f-string</code> ，它和普通字符串不同之处在于，字符串如果包含 <code>&#123;xxx&#125;</code> ，就会以对应的变量替换</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; a = 10</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(f<span class="string">&#x27;num is &#123;a&#125;&#x27;</span>)</span></span><br><span class="line">num is 10</span><br></pre></td></tr></table></figure>

<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><p><strong>if</strong></p>
<p>注意和 java中条件判断写法的区别。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if &lt;条件判断1&gt;:</span><br><span class="line">    &lt;执行1&gt;</span><br><span class="line">elif &lt;条件判断2&gt;:</span><br><span class="line">    &lt;执行2&gt;</span><br><span class="line">elif &lt;条件判断3&gt;:</span><br><span class="line">    &lt;执行3&gt;</span><br><span class="line">else:</span><br><span class="line">    &lt;执行4&gt;</span><br></pre></td></tr></table></figure>

<p><strong>模式匹配</strong></p>
<p>match case</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">age = 15</span><br><span class="line"></span><br><span class="line">match age:</span><br><span class="line">    case x if x &lt; 10:</span><br><span class="line">        print(f&#x27;&lt; 10 years old: &#123;x&#125;&#x27;)</span><br><span class="line">    case 10:</span><br><span class="line">        print(&#x27;10 years old.&#x27;)</span><br><span class="line">    case 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18:</span><br><span class="line">        print(&#x27;11~18 years old.&#x27;)</span><br><span class="line">    case 19:</span><br><span class="line">        print(&#x27;19 years old.&#x27;)</span><br><span class="line">    case _:</span><br><span class="line">        print(&#x27;not sure.&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第一个 <code>case x if x &lt; 10 </code>表示当 <code>age &lt; 10</code> 成立时匹配，且赋值给变量x，第二个case 10仅匹配单个值，第三个 <code>case 11|12|...|18</code> 能匹配多个值，用|分隔。</p>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>python的循环有2种，一种是 for…in 循环，依次把集合中的元素迭代出来。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">L = [&#x27;Bart&#x27;, &#x27;Lisa&#x27;, &#x27;Adam&#x27;]</span><br><span class="line">for n in L:</span><br><span class="line">    print(&#x27;Hello, %s!&#x27; % n)</span><br></pre></td></tr></table></figure>
<p><strong>while</strong></p>
<p>只要条件满足，就不断循环，条件不满足时，退出循环。</p>
<p>循环控制， <code>break</code> 提前结束循环， <code>continue</code> 跳过当次循环，执行下一次循环。</p>
<h2 id="list和tuple"><a href="#list和tuple" class="headerlink" title="list和tuple"></a>list和tuple</h2><p><strong>list</strong></p>
<p>list是python内置的数据类型，列表，是有序集合。</p>
<p>相关操作有</p>
<ol>
<li>使用 len(list) 获取元素个数</li>
<li>使用索引访问元素，正序从 <code>0</code> 开始，倒序从 <code>-1</code> 开始</li>
<li>list是一个可变的有序表，使用 <code>.append(element)</code>往list中添加元素</li>
<li>也可以使用insert(index, 元素) 方法，将元素插入指定位置。</li>
<li>使用 pop()方法删除末尾元素，pop(i) 方法删除指定位置的元素。</li>
<li>使用 list[i] &#x3D; xxx， 直接替换对应位置的元素。</li>
<li>list中元素的数据类型可以不同。</li>
<li>list中的元素也可以是另一个list的引用。</li>
<li>空list [] ， 长度为0</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; names = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; names</span></span><br><span class="line">[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; names[1]</span></span><br><span class="line">&#x27;b&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; len(names)</span></span><br><span class="line">3</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; names[-1]</span></span><br><span class="line">&#x27;c&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; names.append(<span class="string">&#x27;d&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; names</span></span><br><span class="line">[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; names.insert(2, <span class="string">&#x27;f&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; names</span></span><br><span class="line">[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;f&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; names.pop()</span></span><br><span class="line">&#x27;d&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; names</span></span><br><span class="line">[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;f&#x27;, &#x27;c&#x27;]</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; names.pop(1)</span></span><br><span class="line">&#x27;b&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; names</span></span><br><span class="line">[&#x27;a&#x27;, &#x27;f&#x27;, &#x27;c&#x27;]</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; names[1]= <span class="string">&#x27;张三&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; names</span></span><br><span class="line">[&#x27;a&#x27;, &#x27;张三&#x27;, &#x27;c&#x27;]</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>tuple</strong></p>
<p>另一种有序列表叫元组，<code>tuple</code> ，tuple和list非常相似，但是tuple一旦被初始化，就不能修改。</p>
<ol>
<li>tuple 使用小括号进行初始化 <code>()</code></li>
<li>只有一个元素的tuple需要加个逗号<code>,</code>，避免和数据公式中的小括号造成歧义。 (1,)</li>
<li>tuple不可变 意思是元素的指向不可变。</li>
</ol>
<h2 id="dict和set"><a href="#dict和set" class="headerlink" title="dict和set"></a>dict和set</h2><p><strong>dict</strong></p>
<p>dict全称dictionary，在其他语言中也称为map，是键值对的数据类型。</p>
<blockquote>
<p> d&#x3D;{‘k1’:1, ‘k2’:2, ‘k3’:3}</p>
</blockquote>
<p>相关操作</p>
<ol>
<li>dict中的key必须是 <strong>不可变对象</strong></li>
<li>d[key]&#x3D;xxx 进行赋值。</li>
<li>d[key]来获取对应的value，key不存在时会报错。</li>
<li>用 <code>in</code> 判断key是否存在。</li>
<li>可以使用 <code>get(key)</code>方法获取元素，key不存在会返回 <code>None</code></li>
<li>可以使用 <code>get(key, -1)</code>方法获取元素，key不存在会返回指定的默认值。</li>
<li>使用 <code>pop(key)</code> 来删除key。</li>
<li>元素存放位置，使用hash算法。</li>
</ol>
<p><strong>set</strong></p>
<p>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。</p>
<p>要创建一个set，需要提供一个list作为输入集合：</p>
<p><code>s=set([1,2,3,4,5])</code> 或者 <code>s=&#123;1,2,3,4,5&#125;</code></p>
<p>注意要加上 set， 否则就变成了 list了。</p>
<p>set的特点</p>
<ol>
<li>元素无序，不可重复。</li>
<li><code>add(key)</code> 添加元素。</li>
<li><code>remove(key)</code> 移除元素。</li>
<li>set 可以进行交集 <code>&amp;</code> 和 并集 <code>|</code> 的操作。</li>
<li>set和dict的唯一区别仅在于没有存储对应的value。</li>
</ol>
<p>list, tuple, dict, set 的区别</p>
<p>list [] , tuple (), dict {k:v} , set {k1,k2}</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>10.python进程和线程</title>
    <url>/hexoblog/python/10.python%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>多任务操作系统，可以同时执行多个任务，单核CPU是通过进程调度，多个任务交替执行的。</p>
<p>一个任务就是一个进程，进程是操作系统分配资源的基本单位，具有独立的内存空间和资源，进程可以看做一个独立的程序，比如微信，qq等，一个进程可以包含多个线程，至少一个线程，线程是进程内的执行单位，共享进程的资源。</p>
<span id="more"></span>

<h1 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h1><h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>Unix&#x2F;Linux 提供了 <code>fork()</code> 系统调用，调用一次返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。</p>
<p>子进程永远返回<code>0</code>，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。</p>
<p>Windows没有 <code>fork</code> 调用。</p>
<h2 id="multiprocessing"><a href="#multiprocessing" class="headerlink" title="multiprocessing"></a>multiprocessing</h2><p><code>multiprocessing</code> 模块是跨平台版本的多进程模块。</p>
<p><code>multiprocessing</code>提供了一个<code>Process</code>类来代表一个进程对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">run_proc</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Run child process %s (%s)...&#x27;</span> % (name, os.getpid()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Parent process %s.&#x27;</span> % os.getpid())</span><br><span class="line">    p = Process(target=run_proc, args=(<span class="string">&#x27;子进程&#x27;</span>, ))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;启动子进程&#x27;</span>)</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;子进程执行结束&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>创建子进程时，只需要传入一个执行函数和函数的参数，创建一个<code>Process</code>实例，用<code>start()</code>方法启动，这样创建进程比<code>fork()</code>还要简单。</p>
<p><code>join()</code>方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。</p>
<h2 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h2><p>如果要启动大量的子进程，可以用进程池的方式批量创建子进程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool, Process</span><br><span class="line"><span class="keyword">import</span> os,time,random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">long_time_task</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Run task %s (%s)...&#x27;</span> % (name, os.getpid()))</span><br><span class="line">    start = time.time()</span><br><span class="line">    time.sleep(random.random() * <span class="number">5</span>)</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Task %s runs %0.2f seconds.&#x27;</span> % (name, (end - start)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Parent process %s.&#x27;</span> % os.getpid())</span><br><span class="line">    p = Pool(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        p.apply_async(long_time_task, args=(i,))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Waiting for all subprocesses done...&#x27;</span>)</span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;All subprocesses done.&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>解读：<br>对<code>Pool</code>对象调用<code>join()</code>方法会等待所有子进程执行完毕，调用<code>join()</code>之前必须先调用<code>close()</code>，调用<code>close()</code>之后就不能继续添加新的<code>Process</code>了。</p>
<p>由于<code>Pool</code>的默认大小是CPU的核数。如果任务数量大于Pool的大小，就需要等前面的任务执行完后才能执行后面的任务。</p>
<h2 id="子进程"><a href="#子进程" class="headerlink" title="子进程"></a>子进程</h2><p>很多时候，子进程并不是自身，而是一个外部进程。我们创建了子进程后，还需要控制子进程的输入和输出。</p>
<p><code>subprocess</code>可以让我们方便的启动子进程，并控制其输入和输出。</p>
<p>如果子进程还需要输入，可以使用 <code>communicate()</code> 输入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;nslookup www.baidu.com&#x27;</span>)</span><br><span class="line">r = subprocess.call([<span class="string">&#x27;nslookup&#x27;</span>, <span class="string">&#x27;www.baidu.com&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Exit code:&#x27;</span>, r)</span><br></pre></td></tr></table></figure>

<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p><code>Process</code>之间肯定是需要通信的，操作系统提供了很多机制来实现进程间的通信。Python的<code>multiprocessing</code>模块包装了底层的机制，提供了<code>Queue</code>、<code>Pipes</code>等多种方式来交换数据。</p>
<p>我们以<code>Queue</code>为例，在父进程中创建两个子进程，一个往<code>Queue</code>里写数据，一个从<code>Queue</code>里读数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写数据进程执行的代码:</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">q</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Process to write: %s&#x27;</span> % os.getpid())</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Put %s to queue...&#x27;</span> % value)</span><br><span class="line">        q.put(value)</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读数据进程执行的代码:</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">q</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Process to read: %s&#x27;</span> % os.getpid())</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        value = q.get(<span class="literal">True</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Get %s from queue.&#x27;</span> % value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 父进程创建Queue，并传给各个子进程：</span></span><br><span class="line">    q = Queue()</span><br><span class="line">    pw = Process(target=write, args=(q,))</span><br><span class="line">    pr = Process(target=read, args=(q,))</span><br><span class="line">    <span class="comment"># 启动子进程pw，写入:</span></span><br><span class="line">    pw.start()</span><br><span class="line">    <span class="comment"># 启动子进程pr，读取:</span></span><br><span class="line">    pr.start()</span><br><span class="line">    <span class="comment"># 等待pw结束:</span></span><br><span class="line">    pw.join()</span><br><span class="line">    <span class="comment"># pr进程里是死循环，无法等待其结束，只能强行终止:</span></span><br><span class="line">    pr.terminate()</span><br></pre></td></tr></table></figure>

<p>在Unix&#x2F;Linux下，<code>multiprocessing</code>模块封装了<code>fork()</code>调用，使我们不需要关注<code>fork()</code>的细节。</p>
<p>由于Windows没有<code>fork</code>调用，因此，<code>multiprocessing</code>需要“模拟”出<code>fork</code>的效果，父进程所有Python对象都必须通过<strong>pickle序列化</strong>再传到子进程去，所以，如果multiprocessing在Windows下调用失败了，要先考虑是不是pickle失败了。</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>多任务可以由多进程完成，也可以由一个进程内的多线程完成。Python的线程是真正的Posix Thread，而不是模拟出来的线程</p>
<h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><p>Python的标准库提供了两个模块：<code>_thread</code>和<code>threading</code>，<code>_thread</code>是低级模块，<code>threading</code>是高级模块，对<code>_thread</code>进行了封装。绝大多数情况下，我们只需要使用<code>threading</code>这个高级模块。</p>
<p>启动一个线程就是把一个函数传入并创建<code>Thread</code>实例，然后调用<code>start()</code>开始执行(和java有点像)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">task_run</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;当前线程名称是 %s&#x27;</span> % threading.current_thread().name)</span><br><span class="line">    time.sleep(random.random() * <span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;线程 % s 在执行任务&#x27;</span> % threading.current_thread().name)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;线程 %s 执行结束&#x27;</span> % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;当前线程是 %s &#x27;</span> % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line">t = threading.Thread(target=task_run, name=<span class="string">&#x27;子线程&#x27;</span>)</span><br><span class="line">t.start()</span><br><span class="line">t.join()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;线程 %s 执行结束 &#x27;</span> % threading.current_thread().name)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，Python的<code>threading</code>模块有个<code>current_thread()</code>函数，它永远返回当前线程的实例。主线程实例的名字叫<code>MainThread</code>，子线程的名字在创建时指定，名字仅仅在打印时用来显示，完全没有其他意义，如果不起名字Python就自动给线程命名为Thread-1，Thread-2…</p>
<h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><p>线程共享变量，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容改乱了。</p>
<p>高级语言的一条语句在CPU执行时是若干条语句，即使一个简单的计算</p>
<blockquote>
<p>balance &#x3D; balance + n</p>
</blockquote>
<p>也分两步：</p>
<ol>
<li>计算balance + n，存入临时变量中；</li>
<li>将临时变量的值赋给balance。</li>
</ol>
<p>也就是可以看成：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = balance + n</span><br><span class="line">balance = x</span><br></pre></td></tr></table></figure>

<p>两个线程同时一存一取，就可能导致余额不对，所以，我们必须确保一个线程在修改balance的时候，别的线程一定不能改。</p>
<p>如果我们要确保<code>balance</code>计算正确，就要给<code>change_it()</code>修改的地方上一把锁，当某个线程开始执行<code>change_it()</code>时，我们说，该线程因为获得了锁，因此其他线程不能同时执行<code>change_it()</code>，只能等待，直到锁被释放后，获得该锁以后才能改。</p>
<p>由于锁只有一个，无论多少线程，同一时刻最多只有一个线程持有该锁，所以，不会造成修改的冲突。创建一个锁就是通过<code>threading.Lock()</code>来实现：</p>
<p>当多个线程同时执行<code>lock.acquire()</code>时，只有一个线程能成功地获取锁，其他线程需要继续等待，执行完后需要释放锁，可以放到<code>try...finally</code>代码块中来确保一定释放。</p>
<h2 id="多核CPU"><a href="#多核CPU" class="headerlink" title="多核CPU"></a>多核CPU</h2><p>启动与CPU核心数量相同的N个线程，在4核CPU上可以监控到CPU占用率仅有102%，也就是仅使用了一核。</p>
<p>但是用C、C++或Java来改写相同的死循环，直接可以把全部核心跑满，4核就跑到400%，8核就跑到800%，为什么Python不行呢？</p>
<p>因为Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：<code>Global Interpreter Lock</code>，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。</p>
<p>在Python中，可以使用多线程，但不要指望能有效利用多核。</p>
<p>Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。</p>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>多线程环境下，尽量使用局部变量，全局变量的修改操作需要加锁。但是局部变量在函数调用时传递比较麻烦。</p>
<p>正常情况下，需要函数一层层往下传递，比较麻烦，也可以使用全局变量dict来保存，使用线程信息作为key，代码看起来比较乱。可以使用 <code>ThreadLocal</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lc = threading.local()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_info</span>():</span><br><span class="line">    name = lc.user</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;当前线程 %s 输出用户名 %s&#x27;</span> % (threading.current_thread(), name))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_info</span>(<span class="params">name</span>):</span><br><span class="line">    lc.user = name</span><br><span class="line">    time.sleep(random.random() * <span class="number">3</span>)</span><br><span class="line">    print_info()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    t = threading.Thread(target=set_info, args=(i,), name=<span class="string">&#x27;thread-&#x27;</span> + <span class="built_in">str</span>(i))</span><br><span class="line">    t.start()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以理解为全局变量<code>lc</code>是一个<code>dict</code>，不但可以用<code>lc.user</code>，还可以绑定其他变量，如<code>lc.job</code>等等。</p>
<p><code>ThreadLocal</code>最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。</p>
<p>一个<code>ThreadLocal</code>变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰。<code>ThreadLocal</code>解决了参数在一个线程中各个函数之间互相传递的问题。</p>
<h1 id="进程-vs-线程"><a href="#进程-vs-线程" class="headerlink" title="进程 vs. 线程"></a>进程 vs. 线程</h1><p><strong>线程切换</strong></p>
<p>多任务线程切换。</p>
<p><strong>计算密集型 vs. IO密集型</strong></p>
<p>计算密集型主要消耗CPU资源，减少线程数，减少线程切换。 IO密集型主要消耗在IO等待，任务数提升，可以提高CPU的利用率。如常见的web应用。</p>
<p><strong>异步IO</strong></p>
<p>CPU和IO有巨大的速度差异，一个任务在执行的过程中大部分时间都在等待IO操作，单进程单线程模型会导致别的任务无法并行执行。</p>
<p>现在操作系统一般都支持异步IO，如果充分利用操作系统提供的异步IO支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型。Nginx就是支持异步IO的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。</p>
<p>对应到Python语言，单线程的异步编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。</p>
<h1 id="分布式进程"><a href="#分布式进程" class="headerlink" title="分布式进程"></a>分布式进程</h1><p>在Thread和Process中，应当优选Process，因为Process更稳定，而且，Process可以分布到多台机器上，而Thread最多只能分布到同一台机器的多个CPU上。</p>
<p>Python的<code>multiprocessing</code>模块不但支持多进程，其中<code>managers</code>子模块还支持把多进程分布到多台机器上。一个服务进程可以作为调度者，将任务分布到其他多个进程中，依靠网络通信。由于<code>managers</code>模块封装很好，不必了解网络通信的细节，就可以很容易地编写分布式多进程程序。</p>
<p><code>QueueManager</code>的使用。可以把任务分布到多台机器上进行就算。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>11.python正则表达式</title>
    <url>/hexoblog/python/11.python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>字符串是编程时涉及到的最多的一种数据结构，对字符串进行操作的需求几乎无处不在。</p>
<p>正则表达式是一种用来匹配字符串的强有力的武器。它的设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的。</p>
<span id="more"></span>

<p>正则表达式基础的表示方式，如数字，开头，结尾等，可以参考相关文档。</p>
<p><a href="https://www.runoob.com/regexp/regexp-syntax.html">菜鸟教程-正则表达式</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_expressions">Regular_expressions</a></p>
<h2 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h2><p>Python提供<code>re</code>模块，包含所有正则表达式的功能。由于Python的字符串本身也用<code>\</code>转义，所以要特别注意：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">s = &#x27;ABC\\-001&#x27; # Python的字符串</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对应的正则表达式字符串变成：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">&#x27;ABC\-001&#x27;</span></span></span><br></pre></td></tr></table></figure>

<p>所以强烈建议使用Python的<code>r</code>前缀，就不用考虑转义的问题了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">s = r&#x27;ABC\-001&#x27; # Python的字符串</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对应的正则表达式字符串不变：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">&#x27;ABC\-001&#x27;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h2><p>使用正则进行匹配</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import re</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; re.match(r<span class="string">&#x27;\d+&#x27;</span>, <span class="string">&#x27;111&#x27;</span>)</span></span><br><span class="line">&lt;re.Match object; span=(0, 3), match=&#x27;111&#x27;&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; re.match(r<span class="string">&#x27;\d+&#x27;</span>, <span class="string">&#x27;aa&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>match()</code>方法判断是否匹配，如果匹配成功，返回一个<code>Match</code>对象，否则返回<code>None</code>。常见的判断方法就是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test = <span class="string">&#x27;字符串&#x27;</span></span><br><span class="line"><span class="keyword">if</span> re.<span class="keyword">match</span>(<span class="string">r&#x27;正则表达式&#x27;</span>, test):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;failed&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="切分字符串"><a href="#切分字符串" class="headerlink" title="切分字符串"></a>切分字符串</h2><p>用正则表达式切分字符串比用固定的字符更灵活</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="string">&#x27;a b    c  d     e&#x27;</span>.<span class="built_in">split</span>(<span class="string">&#x27; &#x27;</span>)</span></span><br><span class="line">[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;c&#x27;, &#x27;&#x27;, &#x27;d&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;e&#x27;]</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; re.split(r<span class="string">&#x27;\s+&#x27;</span> , <span class="string">&#x27;a b    c  d     e&#x27;</span>)</span></span><br><span class="line">[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; re.split(r<span class="string">&#x27;[\s\,]+&#x27;</span> , <span class="string">&#x27;a b  , ,  c , d     e&#x27;</span>)</span></span><br><span class="line">[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span><br></pre></td></tr></table></figure>

<p>可以看出来使用正则更加灵活和强大，便于把不规范的输入转换成正确的数组。</p>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用<code>()</code>表示的就是要提取的分组（Group）。比如</p>
<p><code>^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$</code>分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; m = re.match(r<span class="string">&#x27;^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$&#x27;</span>, <span class="string">&#x27;010-12345&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; m</span></span><br><span class="line">&lt;re.Match object; span=(0, 9), match=&#x27;010-12345&#x27;&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; m.group(0)</span></span><br><span class="line">&#x27;010-12345&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; m.group(1)</span></span><br><span class="line">&#x27;010&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; m.group(2)</span></span><br><span class="line">&#x27;12345&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果正则表达式中定义了组，就可以在Match对象上用<code>group()</code>方法提取出子串来。</p>
<p><code>group(0)</code>永远是与整个正则表达式相匹配的字符串，<code>group(1)</code>、<code>group(2)</code>……表示第1、2、……个子串。</p>
<h2 id="贪婪匹配"><a href="#贪婪匹配" class="headerlink" title="贪婪匹配"></a>贪婪匹配</h2><p>正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的<code>0</code>， 加上 <code>?</code> 说明采用非贪婪模式。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; re.match(r<span class="string">&#x27;(\d+)(0*)$&#x27;</span>, <span class="string">&#x27;102010&#x27;</span>).<span class="built_in">groups</span>()</span></span><br><span class="line">(&#x27;102010&#x27;, &#x27;&#x27;)</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; re.match(r<span class="string">&#x27;(\d+?)(0*)$&#x27;</span>, <span class="string">&#x27;10201000&#x27;</span>).<span class="built_in">groups</span>()</span></span><br><span class="line">(&#x27;10201&#x27;, &#x27;000&#x27;)</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>\d+</code> 采用非贪婪模式，后面加上<code>?</code> ，改为 <code>(\d+?)</code></p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>当我们在Python中使用正则表达式时，re模块内部会干两件事情：</p>
<ol>
<li><p>编译正则表达式，如果正则表达式的字符串本身不合法，会报错；</p>
</li>
<li><p>用编译后的正则表达式去匹配字符串。</p>
</li>
</ol>
<p>如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配(和java一样)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import re</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译:</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; re_telephone = re.compile(r<span class="string">&#x27;^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用：</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; re_telephone.match(<span class="string">&#x27;010-12345&#x27;</span>).<span class="built_in">groups</span>()</span></span><br><span class="line">(&#x27;010&#x27;, &#x27;12345&#x27;)</span><br></pre></td></tr></table></figure>

<p>编译后生成Regular Expression对象，由于该对象自己包含了正则表达式，所以调用对应的方法时不用给出正则字符串。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>12.1python常用内建模块1</title>
    <url>/hexoblog/python/12.1python%E5%B8%B8%E7%94%A8%E5%86%85%E5%BB%BA%E6%A8%A1%E5%9D%971/</url>
    <content><![CDATA[<p>Python之所以自称“batteries included”，就是因为内置了许多非常有用的模块，无需额外安装和配置，即可直接使用。</p>
<p>主要介绍了datetime和collections模块</p>
<span id="more"></span>

<h1 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a>datetime</h1><p>datetime是Python处理日期和时间的标准库。</p>
<p><strong>获取当前日期和时间</strong></p>
<p><code>datetime.now()</code>返回的是当前日期和时间。</p>
<p><strong>获取指定日期和时间</strong></p>
<p>要指定某个日期和时间，我们直接用参数构造一个<code>datetime</code></p>
<p><strong>datetime转换为timestamp</strong></p>
<p>timestamp时间戳，timestamp的值与时区毫无关系，因为timestamp一旦确定，其UTC时间就确定了，注意时区的问题</p>
<p>把一个<code>datetime</code>类型转换为<code>timestamp</code>只需要简单调用<code>timestamp()</code>方法：</p>
<p>Python的timestamp是一个浮点数，整数位表示秒。</p>
<p><strong>timestamp转换为datetime</strong></p>
<p>要把<code>timestamp</code>转换为<code>datetime</code>，使用<code>datetime</code>提供的<code>fromtimestamp()</code>方法：</p>
<p><code>timestamp</code>是一个浮点数，它没有时区的概念，而<code>datetime</code>是有时区的。上述转换是在timestamp和本地时间做转换。本地时间是指当前操作系统设定的时区</p>
<p>timestamp也可以直接被转换到UTC标准时区的时间，使用<code>utcfromtimestamp()</code>方法，后续该方法可能会被移除。</p>
<p><strong>str转换为datetime</strong></p>
<p>把日期和时间的字符串转换为<code>datetime</code>，通过<code>datetime.strptime()</code>实现，需要一个日期和时间的格式化字符串：</p>
<p>格式化字符串参考文档 <a href="https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior">strftime-strptime-behavior</a></p>
<p><strong>datetime转换为str</strong></p>
<p>使用<code>strftime()</code>函数实现，参数需要一个格式化的字符串，和转datetime的一样。</p>
<p><code>now.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取当前日期和时间</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from datetime import datetime</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; now = datetime.now()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(now)</span></span><br><span class="line">2023-12-26 11:36:58.026154</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(<span class="built_in">type</span>(now))</span></span><br><span class="line">&lt;class &#x27;datetime.datetime&#x27;&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取指定日期和时间</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; dt = datetime(2023,12,26,11,22,44)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(dt)</span></span><br><span class="line">2023-12-26 11:22:44</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">timestamp</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(dt.timestamp())</span></span><br><span class="line">1703560964.0</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(now.timestamp())</span></span><br><span class="line">1703561818.026154</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">转datetime</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; t = 1601234654.1243</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(datetime.fromtimestamp(t))</span></span><br><span class="line">2020-09-28 03:24:14.124300</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(datetime.utcfromtimestamp(t))</span></span><br><span class="line">2020-09-27 19:24:14.124300</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">字符串转datetime</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; day  = datetime.strptime(<span class="string">&#x27;2023-12-01 12:11:01&#x27;</span>, <span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(day)</span></span><br><span class="line">2023-12-01 12:11:01</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(<span class="built_in">type</span>(day))</span></span><br><span class="line">&lt;class &#x27;datetime.datetime&#x27;&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">datetime转字符串</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(now.strftime( <span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>))</span></span><br><span class="line">2023-12-26 11:36:58</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">datetime 加减计算</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(now)</span></span><br><span class="line">2023-12-26 11:36:58.026154</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; nd = now + timedelta(days = 2)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(nd)</span></span><br><span class="line">2023-12-28 11:36:58.026154</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>datetime加减</strong></p>
<p>加减可以直接用<code>+</code>和<code>-</code>运算符，不过需要导入<code>timedelta</code>这个类</p>
<p><strong>本地时间转换为UTC时间</strong></p>
<p>一个<code>datetime</code>类型有一个时区属性<code>tzinfo</code>，但是默认为<code>None</code>，可以给<code>datetime</code>设置一个时区。</p>
<blockquote>
<p>tz_utc_8 &#x3D; timezone(timedelta(hours&#x3D;8)) # 创建时区UTC+8:00</p>
</blockquote>
<p><strong>时区转换</strong><br>可以先通过<code>utcnow()</code>拿到当前的UTC时间，再转换为任意时区的时间</p>
<p>利用带时区的<code>datetime</code>，通过<code>astimezone()</code>方法，可以转换到任意时区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from datetime import datetime, timedelta, timezone</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; utc_dt = datetime.utcnow().replace(tzinfo=timezone.utc)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(utc_dt)</span></span><br><span class="line">2023-12-26 06:17:28.304592+00:00</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; bj_dt = utc_dt.astimezone(timezone(timedelta(hours=8)))</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(bj_dt)</span></span><br><span class="line">2023-12-26 14:17:28.304592+08:00</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; tokyo_dt=bj_dt.astimezone(timezone(timedelta(hours=9)))</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(tokyo_dt)</span></span><br><span class="line">2023-12-26 15:17:28.304592+09:00</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="collections集合模块"><a href="#collections集合模块" class="headerlink" title="collections集合模块"></a>collections集合模块</h1><p><strong>namedtuple</strong></p>
<p><code>tuple</code>可以表示不变集合，一个点的二维坐标就可以表示成 <code>p = (1, 2)</code>，但是看到 <code>(1, 2)</code> 很难看出是表示一个坐标的。定义一个calss又小题大做了，这时可以用<code>namedtuple</code></p>
<p><code>namedtuple</code>是一个函数，它用来创建一个自定义的<code>tuple</code>对象，并且规定了<code>tuple</code>元素的个数，并可以用属性而不是索引来引用<code>tuple</code>的某个元素。</p>
<p>我们用<code>namedtuple</code>可以很方便地定义一种数据类型，它具备<code>tuple</code>的不变性，又可以根据属性来引用，使用十分方便。</p>
<p>可以验证创建的<code>Point</code>对象是<code>tuple</code>的一种子类</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from collections import namedtuple</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Point = namedtuple(<span class="string">&#x27;Point&#x27;</span>, [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>])</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; p = Point(1,2)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; p.x</span></span><br><span class="line">1</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">type</span>(p)</span></span><br><span class="line">&lt;class &#x27;__main__.Point&#x27;&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; isinstance(p, tuple)</span></span><br><span class="line">True</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>deque</strong></p>
<p>使用<code>list</code>存储数据时，按照索引访问快，但是插入和删除慢，数据量大的时候，效率很低。</p>
<p><code>deque</code>是为了高效实现插入和删除操作的双向列表，适合用于队列和栈</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from collections import deque</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; q = deque([<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>])</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; q.append(<span class="string">&#x27;4&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; q.appendleft(<span class="string">&#x27;5&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; q</span></span><br><span class="line">deque([&#x27;5&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;])</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; q.pop()</span></span><br><span class="line">&#x27;4&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; q.popleft()</span></span><br><span class="line">&#x27;5&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; q</span></span><br><span class="line">deque([&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;])</span><br></pre></td></tr></table></figure>
<p><code>deque</code>除了实现<code>list</code>的<code>append()</code>和<code>pop()</code>外，还支持<code>appendleft()</code>和<code>popleft()</code>，这样就可以非常高效地往头部添加或删除元素。</p>
<p><strong>defaultdict</strong></p>
<p>使用<code>dict</code>时，如果引用的Key不存在，就会抛出<code>KeyError</code>。如果希望key不存在时，返回一个默认值，就可以用<code>defaultdict</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from collections import defaultdict</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; d = defaultdict(lambda: <span class="string">&#x27;N/A&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; d[<span class="string">&#x27;key1&#x27;</span>] = <span class="string">&#x27;1&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; d[<span class="string">&#x27;key1&#x27;</span>]</span></span><br><span class="line">&#x27;1&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; d[<span class="string">&#x27;key2&#x27;</span>]</span></span><br><span class="line">&#x27;N/A&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>
<p>意默认值是调用函数返回的，而函数在创建<code>defaultdict</code>对象时传入。</p>
<p><strong>OrderedDict</strong></p>
<p><code>dict</code>的key是无序的，如果需要保持key的顺序，使用<code>OrderedDict</code></p>
<p><code>OrderedDict</code>是按照key插入的顺序排序，而不是key本身的顺序。</p>
<p><code>OrderedDict</code>可以实现一个FIFO（先进先出）的<code>dict</code>，当容量超出限制时，先删除最早添加的Key</p>
<p><code>OrderedDict</code>在Python 3.7及以后的版本中，已经不再是必要的，因为从Python 3.7开始，普通的<code>dict</code>对象也会保持元素的插入顺序。</p>
<p>如果想要按照字母顺序排序，可以先对dict排序，然后存入<code>OrderedDict</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"><span class="comment"># 创建一个普通的字典</span></span><br><span class="line">unsorted_dict = &#123;<span class="string">&#x27;apple&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;banana&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;orange&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;pear&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="comment"># 按照键的字母顺序对字典进行排序</span></span><br><span class="line">sorted_dict = OrderedDict(<span class="built_in">sorted</span>(unsorted_dict.items()))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>ChainMap</strong></p>
<p><code>ChainMap</code>可以把一组<code>dict</code>串起来并组成一个逻辑上的<code>dict</code>。<code>ChainMap</code>本身也是一个<code>dict</code>，但是查找的时候，会按照顺序在内部的<code>dict</code>依次查找。</p>
<p>什么时候使用ChainMap最合适？举个例子：应用程序往往都需要传入参数，参数可以通过命令行传入，可以通过环境变量传入，还可以有默认参数。我们可以用ChainMap实现参数的优先级查找，即先查命令行参数，如果没有传入，再查环境变量，如果没有，就使用默认参数。</p>
<p><strong>Counter</strong></p>
<p><code>Counter</code>是一个简单的计数器，<code>Counter</code>实际上也是<code>dict</code>的一个子类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Counter()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.update(<span class="string">&#x27;hahahshashsahashqh2qhewhfwh&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">Counter(&#123;<span class="string">&#x27;h&#x27;</span>: <span class="number">11</span>, <span class="string">&#x27;a&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;s&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;q&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;w&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;2&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;f&#x27;</span>: <span class="number">1</span>&#125;)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>12.2python常用内建模块2</title>
    <url>/hexoblog/python/12.2python%E5%B8%B8%E7%94%A8%E5%86%85%E5%BB%BA%E6%A8%A1%E5%9D%972/</url>
    <content><![CDATA[<p>本章主要介绍 argparse， bass64， struct，hashlib， hmac的使用。</p>
<span id="more"></span>

<h1 id="argparse"><a href="#argparse" class="headerlink" title="argparse"></a>argparse</h1><p>内置的<code>sys.argv</code>保留了完整的参数列表，我们可以从中解析出需要的参数，但是如果参数复杂点，解析起来就很麻烦了，可以使用<code>argparse</code></p>
<p>假设需要编写一个mysql命令行登录程序，需要的参数如下</p>
<blockquote>
<p>mysql -h localhost –port 3306 -u root -p password</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse,sys</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(</span><br><span class="line">    prog=<span class="string">&#x27;命令行登录&#x27;</span>,</span><br><span class="line">    description=<span class="string">&#x27;命令行登录mysql数据库&#x27;</span>,</span><br><span class="line">    epilog=<span class="string">&#x27;Copyright,2023&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义关键字参数: ，此处不能用 -h简写，和 argparse的-h帮助参数冲突了。</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;--host&#x27;</span>, default=<span class="string">&#x27;localhost&#x27;</span>)</span><br><span class="line"><span class="comment"># 此参数必须为int类型:</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;--port&#x27;</span>, default=<span class="string">&#x27;3306&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>)</span><br><span class="line"><span class="comment"># 允许用户输入简写的-u:</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;-u&#x27;</span>, <span class="string">&#x27;--user&#x27;</span>, required=<span class="literal">True</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-p&#x27;</span>, <span class="string">&#x27;--password&#x27;</span>, required=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析参数:</span></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sys.argv)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印参数:</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;parsed args:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;host = <span class="subst">&#123;args.host&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;port = <span class="subst">&#123;args.port&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;user = <span class="subst">&#123;args.user&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;password = <span class="subst">&#123;args.password&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输入有效的参数，能解析出所需要的全部参数。参数不对或者缺失的话，也会有详细的提示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python argparse-test.py --host localhost --port 3306 -u root</span><br><span class="line">usage: 命令行登录 [-h] [--host HOST] [--port PORT] -u USER -p PASSWORD</span><br><span class="line">命令行登录: error: the following arguments are required: -p/--password</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入参数 <code>-h</code> 会有对应的提示信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">D:\workspace\python&gt;python argparse-test.py -h</span><br><span class="line">usage: 命令行登录 [-h] [--host HOST] [--port PORT] -u USER -p PASSWORD</span><br><span class="line"></span><br><span class="line">命令行登录mysql数据库</span><br><span class="line"></span><br><span class="line">options:</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  --host HOST</span><br><span class="line">  --port PORT</span><br><span class="line">  -u USER, --user USER</span><br><span class="line">  -p PASSWORD, --password PASSWORD</span><br><span class="line"></span><br><span class="line">Copyright,2023</span><br></pre></td></tr></table></figure>

<p>只有当参数全部有效时，才会返回一个 <a href="https://docs.python.org/3/library/argparse.html#argparse.Namespace">NameSpace</a> 对象，获取对应的参数就把参数名当作属性获取，非常方便</p>
<h1 id="base64"><a href="#base64" class="headerlink" title="base64"></a>base64</h1><p>Base64是一种用64个字符来表示任意二进制数据的方法。A-Z、a-z、0-9、”+”和”&#x2F;“两个特殊字符，共计64个字符。因此，在URL安全的Base64编码中，常常将”+”替换为”-“，将”&#x2F;“替换为”_”，以避免引起冲突。</p>
<p>Base64编码将每3个字节的数据转换为4个字符，因此每个字符提供了6个比特位的信息</p>
<p>Base64对二进制数据进行处理，每3个字节一组，一共是<code>3x8=24bit</code>，划为4组，每组正好6个bit：</p>
<p>这样我们得到4个数字作为索引，然后查表，获得相应的4个字符，就是编码后的字符串。</p>
<p>示例参考 <a href="https://www.base64decode.org/">example</a>  页面的example部分。<code>Man</code>转换为base64结果为<code>TWFu</code></p>
<p><img data-src="https://pic1.zhimg.com/80/v2-3b7c9b9441623c1c6b5b6099bb897cbc_720w.png" alt="示例图"> </p>
<p>Base64编码会把3字节的二进制数据编码为4字节的文本数据，长度增加33%，好处是编码后的文本数据可以在邮件正文、网页等直接显示</p>
<p>如果要编码的二进制数据不是3的倍数，最后会剩下1个或2个字节怎么办？Base64用<code>\x00</code>字节在末尾补足后，再在编码的末尾加上1个或2个<code>=</code>号，表示补了多少字节，解码的时候，会自动去掉。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; e64 = base64.b64encode(<span class="string">&#x27;hahaha\x00&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(e64)</span></span><br><span class="line">b&#x27;aGFoYWhhAA==&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; d64 = base64.b64decode(b64)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(d64)</span></span><br><span class="line">b&#x27;hahaha&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(d64.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span></span><br><span class="line">hahaha</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>url safe</code>url安全的base64编码。把字符<code>+</code>和<code>/</code>分别变成<code>-</code>和<code>_</code>。使用<code>base64.urlsafe_b64encode()</code>和<code>base64.urlsafe_b64decode()</code></p>
<p>由于<code>=</code>字符也可能出现在Base64编码中，但&#x3D;用在URL、Cookie里面会造成歧义，所以，很多Base64编码后会把<code>=</code>去掉</p>
<p>去掉<code>=</code>后怎么解码呢？因为Base64是把<code>3</code>个字节变为<code>4</code>个字节，所以，Base64编码的长度永远是4的倍数，因此，需要加上&#x3D;把Base64字符串的长度变为4的倍数，就可以正常解码了。</p>
<h1 id="struct字节和二进制的转换"><a href="#struct字节和二进制的转换" class="headerlink" title="struct字节和二进制的转换"></a>struct字节和二进制的转换</h1><p>准确地讲，Python没有专门处理字节的数据类型。但由于b’str’可以表示字节，所以，字节数组＝二进制str。Python提供了一个<code>struct</code>模块来解决<code>bytes</code>和其他二进制数据类型的转换</p>
<p><code>struct</code>的<code>pack</code>函数把任意数据类型变成<code>bytes</code></p>
<p>pack的第一个参数是处理指令，<code>&#39;&gt;I&#39;</code>的意思是：</p>
<p><code>&gt;</code> 表示字节顺序是big-endian，也就是网络序，<code>I</code>表示4字节无符号整数。</p>
<p>后面的参数个数要和处理指令一致。</p>
<p><code>unpack</code>把<code>bytes</code>变成相应的数据类型</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import struct</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; struct.pack(<span class="string">&#x27;&gt;I&#x27;</span>, 2234324)</span></span><br><span class="line">b&#x27;\x00&quot;\x17\xd4&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; struct.unpack(<span class="string">&#x27;&gt;I&#x27;</span>, b<span class="string">&#x27;\x00&quot;\x17\xd4&#x27;</span>)</span></span><br><span class="line">(2234324,)</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; struct.unpack(<span class="string">&#x27;&gt;IH&#x27;</span>, b<span class="string">&#x27;\xf0\xf0\xf0\xf0\x80\x80&#x27;</span>)</span></span><br><span class="line">(4042322160, 32896)</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p>根据<code>&gt;IH</code>的说明，后面的<code>bytes</code>依次变为<code>I</code>：4字节无符号整数和<code>H</code>：2字节无符号整数。</p>
<p>所以，尽管Python不适合编写底层操作字节流的代码，但在对性能要求不高的地方，利用struct就方便多了。</p>
<p>struct支持的数据类型参考<a href="https://docs.python.org/3/library/struct.html#format-characters">format-characters</a> , </p>
<h1 id="hashlib"><a href="#hashlib" class="headerlink" title="hashlib"></a>hashlib</h1><p><strong>摘要算法简介</strong></p>
<p>Python的hashlib提供了常见的摘要算法，如MD5，SHA1等等。</p>
<p>摘要算法，通过摘要函数，计算出固定长度的摘要，用于验证数据，防篡改。</p>
<p>md5 和 sha1</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import hashlib</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; md5=hashlib.md5()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; md5.update(<span class="string">&#x27;test&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; md5</span></span><br><span class="line">&lt;md5 _hashlib.HASH object @ 0x0000020B0560E8F0&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(md5.hexdigest())</span></span><br><span class="line">098f6bcd4621d373cade4e832627b4f6</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; sha1 = hashlib.sha1()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; sha1.update(<span class="string">&#x27;test&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(sha1.hexdigest())</span></span><br><span class="line">a94a8fe5ccb19ba61c4c0873d391e987982fbbd3</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p>摘要可能出现hash碰撞的情况，不同的内容计算出来的hash值相同。</p>
<p><strong>摘要算法应用</strong></p>
<p>明文密码加盐，然后计算hash值，进行比对，判断用户输入的密码是否正确</p>
<h1 id="hmac"><a href="#hmac" class="headerlink" title="hmac"></a>hmac</h1><p>如果<code>salt</code>是我们自己随机生成的，通常我们计算MD5时采用<code>md5(message + salt)</code>。</p>
<p>这实际上就是Hmac算法：Keyed-Hashing for Message Authentication。它通过一个标准算法，在计算哈希的过程中，把key混入计算过程中。</p>
<p>Hmac算法针对所有哈希算法都通用，无论是MD5还是SHA-1。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import hmac</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; message = b<span class="string">&#x27;test&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; key = b<span class="string">&#x27;hahah&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; h = hmac.new(key, message, digestmod=<span class="string">&#x27;SHA1&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(h.hexdigest())</span></span><br><span class="line">5ab4f2d179d1243d6ff9084a0ca659a99bbfcf3f</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p>可见使用hmac和普通hash算法非常类似。hmac输出的长度和原始哈希算法的长度一致。需要注意传入的key和message都是bytes类型，str类型需要首先编码为bytes</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>12.3python常用内建模块3</title>
    <url>/hexoblog/python/12.3python%E5%B8%B8%E7%94%A8%E5%86%85%E5%BB%BA%E6%A8%A1%E5%9D%973/</url>
    <content><![CDATA[<p>本章主要介绍itertools， contextlib， urllib，XML，HTMLParser的使用。</p>
<span id="more"></span>

<h1 id="itertools"><a href="#itertools" class="headerlink" title="itertools"></a>itertools</h1><p><code>itertools</code>提供了非常有用的用于操作迭代对象的函数</p>
<p><code>itertools.count()</code> 自然数无限迭代。</p>
<p><code>itertools.cycle(&#39;abc&#39;)</code>， 将传入的序列无限重复下去</p>
<p><code>repeat()</code> 把一个元素重复下去，可以指定次数。<code>itertools.repeat(&#39;a&#39;, 5)</code></p>
<p>无限序列虽然可以无限迭代下去，但是通常我们会通过<code>takewhile()</code>等函数根据条件判断来截取出一个有限的序列</p>
<p><code>chain()</code>， 可以把一组迭代对象串联起来，组成一个更大的迭代器。<code>itertools.chain(&#39;ABC&#39;, &#39;XYZ&#39;)</code></p>
<p><code>groupby()</code> 把迭代器中相邻的重复元素挑出来放在一起</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import itertools</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="keyword">for</span> key, group <span class="keyword">in</span> itertools.groupby(<span class="string">&#x27;aabbccaaeeabc&#x27;</span>):</span></span><br><span class="line">...    print(key, list(group))</span><br><span class="line">...</span><br><span class="line">a [&#x27;a&#x27;, &#x27;a&#x27;]</span><br><span class="line">b [&#x27;b&#x27;, &#x27;b&#x27;]</span><br><span class="line">c [&#x27;c&#x27;, &#x27;c&#x27;]</span><br><span class="line">a [&#x27;a&#x27;, &#x27;a&#x27;]</span><br><span class="line">e [&#x27;e&#x27;, &#x27;e&#x27;]</span><br><span class="line">a [&#x27;a&#x27;]</span><br><span class="line">b [&#x27;b&#x27;]</span><br><span class="line">c [&#x27;c&#x27;]</span><br></pre></td></tr></table></figure>

<h1 id="contextlib"><a href="#contextlib" class="headerlink" title="contextlib"></a>contextlib</h1><p>在Python中，读写文件这样的资源要特别注意，必须在使用完毕后正确关闭它们。正确关闭文件资源的一个方法是使用<code>try...finally</code>，也可以使用<code>with</code>语句进行简化。</p>
<p>并不是只有<code>open()</code>函数返回的fp对象才能使用<code>with</code>语句。实际上，任何对象，只要正确实现了上下文管理，就可以用于<code>with</code>语句。</p>
<p>实现上下文管理是通过<code>__enter__</code>和<code>__exit__</code>这两个方法实现的。</p>
<p>编写<code>__enter__</code>和<code>__exit__</code>仍然很繁琐，因此Python的标准库<code>contextlib</code>提供了更简单的写法。<code>@contextmanager</code>这个decorator接受一个generator，用<code>yield</code>语句把<code>with ... as var</code>把变量输出出去，然后，<code>with</code>语句就可以正常地工作了</p>
<p>很多时候，我们希望在某段代码执行前后自动执行特定代码，也可以用<code>@contextmanager</code>实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tag</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&lt;%s&gt;&quot;</span> % name)</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&lt;/%s&gt;&quot;</span> % name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tag(<span class="string">&quot;h1&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;world&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>执行顺序</p>
<ol>
<li>with语句首先执行yield之前的语句，</li>
<li>yield调用会执行with语句内部的所有语句，因此打印出hello和world；</li>
<li>最后执行yield之后的语句。</li>
</ol>
<p><strong>@closing</strong></p>
<p>如果一个对象没有实现上下文，我们就不能把它用于<code>with</code>语句。这个时候，可以用<code>closing()</code>来把该对象变为上下文对象。例如，用<code>with</code>语句使用<code>urlopen()</code></p>
<p><code>closing</code>也是一个经过<code>@contextmanager</code>装饰的generator，这个generator编写起来其实非常简单</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">closing</span>(<span class="params">thing</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> thing</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        thing.close()</span><br></pre></td></tr></table></figure>

<h1 id="urllib"><a href="#urllib" class="headerlink" title="urllib"></a>urllib</h1><p>urllib提供了一系列用于操作URL的功能。</p>
<h2 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h2><p>urllib的<code>request</code>模块可以非常方便地抓取URL内容，也就是发送一个GET请求到指定的页面，然后返回HTTP的响应：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> request.urlopen(<span class="string">&#x27;https://api.map.baidu.com/location/ip&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.read()</span><br><span class="line">    <span class="built_in">print</span>(f.status)</span><br><span class="line">    <span class="built_in">print</span>(f.reason)</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> f.getheaders():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s: %s&#x27;</span> % (k, v))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Data:&#x27;</span>, data.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h2 id="Post"><a href="#Post" class="headerlink" title="Post"></a>Post</h2><p>如果要以POST发送一个请求，只需要把参数<code>data</code>以bytes形式传入。 例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reqData = login_data = parse.urlencode([</span><br><span class="line">    (<span class="string">&#x27;ak&#x27;</span>, <span class="string">&#x27;xxxxx&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;ip&#x27;</span>, <span class="string">&#x27;117.131.61.81&#x27;</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">req = request.Request(<span class="string">&#x27;https://api.map.baidu.com/location/ip&#x27;</span>)</span><br><span class="line">req.add_header(<span class="string">&#x27;user-agent&#x27;</span>, <span class="string">&#x27;chrome&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> request.urlopen(req, data=reqData.encode(<span class="string">&#x27;utf-8&#x27;</span>)) <span class="keyword">as</span> f :</span><br><span class="line">    data = f.read()</span><br><span class="line">    <span class="built_in">print</span>(f.status, f.reason)</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> f.getheaders():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s: %s&#x27;</span> % (k, v))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Data:&#x27;</span>, data.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>
<h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p>如果还需要更复杂的控制，比如通过一个Proxy去访问网站，我们需要利用<code>ProxyHandler</code>来处理，示例代码如下：</p>
<h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><p>操作XML有两种方法：DOM和SAX。DOM会把整个XML读入内存，解析为树，因此占用内存大，解析慢，优点是可以任意遍历树的节点。SAX是流模式，边读边解析，占用内存小，解析快，缺点是我们需要自己处理事件。</p>
<p>正常情况下，优先考虑SAX，因为DOM实在太占内存。</p>
<h1 id="HTMLParser"><a href="#HTMLParser" class="headerlink" title="HTMLParser"></a>HTMLParser</h1><p>Python提供了HTMLParser来非常方便地解析HTML，只需简单几行代码</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>13.python常用第三方模块</title>
    <url>/hexoblog/python/13.python%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>可以在<a href="https://pypi.org/">PyPI - the Python Package Index</a> 上查找第三方模块，使用pip安装。主要介绍Pillow，requests，chardet，psutil等</p>
<span id="more"></span>

<h1 id="Pillow"><a href="#Pillow" class="headerlink" title="Pillow"></a>Pillow</h1><p>PIL：Python Imaging Library，是图像处理库，但是仅支持到2.7，兼容的版本，名字叫Pillow，支持最新Python 3.x，又加入了许多新特性。</p>
<p>比如图片压缩和模糊</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageFilter</span><br><span class="line"></span><br><span class="line">img = Image.<span class="built_in">open</span>(<span class="string">&#x27;D:/oldimg.jpg&#x27;</span>)</span><br><span class="line">w = img.width</span><br><span class="line">h = img.height</span><br><span class="line"><span class="built_in">print</span>(w, h)</span><br><span class="line">img.thumbnail((w//<span class="number">2</span>, h//<span class="number">2</span>))</span><br><span class="line"><span class="comment"># 模糊滤镜</span></span><br><span class="line">img.<span class="built_in">filter</span>(ImageFilter.BLUR)</span><br><span class="line">img.save(<span class="string">&#x27;D:/newimg.jpg&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="requests"><a href="#requests" class="headerlink" title="requests"></a>requests</h1><p>requests 是一个第三方库，处理资源特别方便。</p>
<p><strong>使用requests</strong></p>
<p>requests自动检测编码，可以使用<code>encoding</code>属性查看</p>
<p>无论响应是文本还是二进制内容，我们都可以用<code>content</code>属性获得<code>bytes</code>对象</p>
<p>对于特定类型的响应，例如JSON，可以直接获取 ‘r.json()’</p>
<p>需要传入HTTP Header时，我们传入一个dict作为<code>headers</code>参数</p>
<p>requests默认使用<code>application/x-www-form-urlencoded</code>对POST数据编码。如果要传递JSON数据，可以直接传入json参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">params = &#123;<span class="string">&#x27;key&#x27;</span>: <span class="string">&#x27;value&#x27;</span>&#125;</span><br><span class="line">r = requests.post(url, json=params) <span class="comment"># 内部自动序列化为JSON</span></span><br></pre></td></tr></table></figure>
<p>上传文件需要更复杂的编码格式，但是<code>requests</code>把它简化成<code>files</code>参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; upload_files = &#123;<span class="string">&#x27;file&#x27;</span>: open(<span class="string">&#x27;report.xls&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)&#125;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; r = requests.post(url, files=upload_files)</span></span><br></pre></td></tr></table></figure>
<p>在读取文件时，注意务必使用<code>&#39;rb&#39;</code>即二进制模式读取，这样获取的<code>bytes</code>长度才是文件的长度。</p>
<p>requests对Cookie做了特殊处理，使得我们不必解析Cookie就可以轻松获取指定的Cookie：</p>
<p>要指定超时，传入以秒为单位的<code>timeout</code>参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">r = requests.get(url, timeout=2.5) # 2.5秒后超时</span><br></pre></td></tr></table></figure>
<p>示例代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">reqHeader = &#123;<span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;chrome&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">&#x27;https://www.baidu.com/&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(r.status_code)</span><br><span class="line">headers = r.headers</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> headers.items():</span><br><span class="line">    <span class="built_in">print</span>(k, <span class="string">&#x27;=&#x27;</span>, v)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(r.headers[<span class="string">&#x27;Date&#x27;</span>])</span><br><span class="line"><span class="comment"># cookie</span></span><br><span class="line"><span class="comment"># 打印所有的Cookie值</span></span><br><span class="line">cookies = r.cookies</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;输出cookie信息&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> cookies:</span><br><span class="line">    <span class="built_in">print</span>(cookie.name, <span class="string">&#x27;:&#x27;</span>, cookie.value)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(r.encoding)</span><br><span class="line"><span class="comment"># print(r.json())</span></span><br></pre></td></tr></table></figure>

<h1 id="chardet"><a href="#chardet" class="headerlink" title="chardet"></a>chardet</h1><p>虽然Python提供了Unicode表示的<code>str</code>和<code>bytes</code>两种数据类型，并且可以通过<code>encode()</code>和<code>decode()</code>方法转换，但是，在不知道编码的情况下，对<code>bytes</code>做<code>decode()</code>不好做。</p>
<p>对于未知编码的<code>bytes</code>，要把它转换成<code>str</code>，需要先“猜测”编码。猜测的方式是先收集各种编码的特征字符，根据特征字符判断，就能有很大概率“猜对”。</p>
<p>chardet 用来检测编码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import chardet</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; chardet.detect(b<span class="string">&#x27;12ass&#x27;</span>)</span></span><br><span class="line">&#123;&#x27;encoding&#x27;: &#x27;ascii&#x27;, &#x27;confidence&#x27;: 1.0, &#x27;language&#x27;: &#x27;&#x27;&#125;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; chardet.detect(<span class="string">&#x27;中国&#x27;</span>.encode())</span></span><br><span class="line">&#123;&#x27;encoding&#x27;: &#x27;utf-8&#x27;, &#x27;confidence&#x27;: 0.7525, &#x27;language&#x27;: &#x27;&#x27;&#125;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; chardet.detect(<span class="string">&#x27;中国&#x27;</span>.encode(<span class="string">&#x27;GB2312&#x27;</span>))</span></span><br><span class="line">&#123;&#x27;encoding&#x27;: &#x27;IBM855&#x27;, &#x27;confidence&#x27;: 0.7679697235616183, &#x27;language&#x27;: &#x27;Russian&#x27;&#125;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; chardet.detect(<span class="string">&#x27;中国&#x27;</span>.encode(<span class="string">&#x27;GBK&#x27;</span>))</span></span><br><span class="line">&#123;&#x27;encoding&#x27;: &#x27;IBM855&#x27;, &#x27;confidence&#x27;: 0.7679697235616183, &#x27;language&#x27;: &#x27;Russian&#x27;&#125;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; chardet.detect(<span class="string">&#x27;中国&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span></span><br><span class="line">&#123;&#x27;encoding&#x27;: &#x27;utf-8&#x27;, &#x27;confidence&#x27;: 0.7525, &#x27;language&#x27;: &#x27;&#x27;&#125;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; chardet.detect(<span class="string">&#x27;こんにちは&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span></span><br><span class="line">&#123;&#x27;encoding&#x27;: &#x27;utf-8&#x27;, &#x27;confidence&#x27;: 0.99, &#x27;language&#x27;: &#x27;&#x27;&#125;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; chardet.detect(<span class="string">&#x27;こんにちは&#x27;</span>.encode(<span class="string">&#x27;EUC-JP&#x27;</span>))</span></span><br><span class="line">&#123;&#x27;encoding&#x27;: &#x27;EUC-JP&#x27;, &#x27;confidence&#x27;: 0.99, &#x27;language&#x27;: &#x27;Japanese&#x27;&#125;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>confidence</code> 字段， 表示检测的概率， 最高是1.0</p>
<h1 id="psutil"><a href="#psutil" class="headerlink" title="psutil"></a>psutil</h1><p>用Python来编写脚本简化日常的运维工作是Python的一个重要用途。psutil &#x3D; process and system utilities，它不仅可以通过一两行代码实现系统监控，还可以跨平台使用。</p>
<p>获取cpu信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import psutil</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; psutil.cpu_count() <span class="comment"># CPU逻辑数量</span></span></span><br><span class="line">8</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; psutil.cpu_count(logical=False) <span class="comment"># CPU物理核心</span></span></span><br><span class="line">4</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">&quot;4核8线程&quot;</span>是指一个处理器（CPU）具有4个物理核心和8个线程。</span></span><br></pre></td></tr></table></figure>

<p>其他的方法可以查看文档。 <a href="https://pypi.org/project/psutil/">psutil</a>  </p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>14.python图形界面</title>
    <url>/hexoblog/python/14.python%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2/</url>
    <content><![CDATA[<p>主要介绍图形界面的操作。包括Tkinter和海龟绘图。</p>
<span id="more"></span>

<h1 id="Tkinter"><a href="#Tkinter" class="headerlink" title="Tkinter"></a>Tkinter</h1><p>Python支持多种图形界面的第三方库，包括</p>
<ul>
<li>Tk</li>
<li>wxWidgets</li>
<li>Qt</li>
<li>GTK</li>
</ul>
<p>等等。</p>
<p>Python自带的库是支持Tk的Tkinter，使用Tkinter，无需安装任何包，就可以直接使用。</p>
<p>我们编写的Python代码会调用内置的Tkinter，Tkinter封装了访问Tk的接口；</p>
<p>Tk是一个图形库，支持多个操作系统，使用Tcl语言开发；</p>
<p>Tk会调用操作系统提供的本地GUI接口，完成最终的GUI。</p>
<p>所以，我们的代码只需要调用Tkinter提供的接口就可以了。</p>
<p>使用Tkinter，第一步是导入Tkinter包的所有内容</p>
<blockquote>
<p>from tkinter import *</p>
</blockquote>
<p>第二步是从<code>Frame</code>派生一个<code>Application</code>类，这是所有Widget的父容器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> messagebox</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span>(<span class="title class_ inherited__">Frame</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, master=<span class="literal">None</span></span>):</span><br><span class="line">        Frame.__init__(self, master)</span><br><span class="line">        self.pack()</span><br><span class="line">        self.createWidgets()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">createWidgets</span>(<span class="params">self</span>):</span><br><span class="line">        self.helloLabel = Label(self, text=<span class="string">&#x27;这是gui界面的内容&#x27;</span>)</span><br><span class="line">        self.helloLabel.pack()</span><br><span class="line">        self.inputText = Entry(self)</span><br><span class="line">        self.inputText.pack()</span><br><span class="line">        self.submitBtn = Button(self, text=<span class="string">&#x27;提交&#x27;</span>, command=self.hello)</span><br><span class="line">        self.submitBtn.pack()</span><br><span class="line">        self.quitButton = Button(self, text=<span class="string">&#x27;退出&#x27;</span>, command=self.quit)</span><br><span class="line">        self.quitButton.pack()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">self</span>):</span><br><span class="line">        info = self.inputText.get() <span class="keyword">or</span> <span class="string">&#x27;你好&#x27;</span></span><br><span class="line">        messagebox.showinfo(<span class="string">&#x27;弹窗&#x27;</span>, <span class="string">&#x27;Hello, %s&#x27;</span> % info)</span><br></pre></td></tr></table></figure>

<p>在GUI中，每个Button、Label、输入框等，都是一个Widget。Frame则是可以容纳其他Widget的Widget，所有的Widget组合起来就是一棵树。</p>
<p>pack()方法把Widget加入到父容器中，并实现布局。pack()是最简单的布局，grid()可以实现更复杂的布局。</p>
<p>在<code>createWidgets()</code>方法中，我们创建一个Label和一个Button，当Button被点击时，触发<code>self.quit()</code>使程序退出。</p>
<p>第三步，实例化Application，并启动消息循环：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">app = Application()</span><br><span class="line"><span class="comment"># 设置窗口标题:</span></span><br><span class="line">app.master.title(<span class="string">&#x27;gui界面&#x27;</span>)</span><br><span class="line"><span class="comment"># 主消息循环:</span></span><br><span class="line">app.mainloop()</span><br></pre></td></tr></table></figure>

<p>GUI程序的主线程负责监听来自操作系统的消息，并依次处理每一条消息。因此，如果消息处理非常耗时，就需要在新线程中处理。</p>
<h1 id="海龟绘图"><a href="#海龟绘图" class="headerlink" title="海龟绘图"></a>海龟绘图</h1><p>在1966年，Seymour Papert和Wally Feurzig发明了一种专门给儿童学习编程的语言——LOGO语言，它的特色就是通过编程指挥一个小海龟（turtle）在屏幕上绘图。</p>
<p>海龟绘图（Turtle Graphics）后来被移植到各种高级语言中，Python内置了turtle库，基本上100%复制了原始的Turtle Graphics的所有功能。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>15.python网络编程</title>
    <url>/hexoblog/python/15.python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>网络通信是两台计算机上的两个进程之间的通信。</p>
<p>用Python进行网络编程，就是在Python程序本身这个进程内，连接别的服务器进程的通信端口进行通信。本章主要介绍TCP和UDP编程。</p>
<span id="more"></span>

<h1 id="TCP-IP简介"><a href="#TCP-IP简介" class="headerlink" title="TCP&#x2F;IP简介"></a>TCP&#x2F;IP简介</h1><p>互联网协议包含了上百种协议标准，但是最重要的两个协议是TCP和IP协议，所以，大家把互联网的协议简称TCP&#x2F;IP协议。</p>
<p>IP地址实际上是一个32位整数（称为IPv4），以字符串表示的IP地址如192.168.0.1实际上是把32位整数按8位分组后的数字表示，目的是便于阅读。</p>
<p>一个TCP报文除了包含要传输的数据外，还包含源IP地址和目标IP地址，源端口和目标端口。</p>
<h1 id="TCP编程"><a href="#TCP编程" class="headerlink" title="TCP编程"></a>TCP编程</h1><p>Socket是网络编程的一个抽象概念。通常我们用一个Socket表示“打开了一个网络链接”，而打开一个Socket需要知道目标计算机的IP地址和端口号，再指定协议类型即可。</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>大多数连接都是可靠的TCP连接。创建TCP连接时，主动发起连接的叫客户端，被动响应连接的叫服务器。</p>
<p>创建一个基于TCP连接的Socket，可以这样做</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入socket库:</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个socket:</span></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 建立连接:</span></span><br><span class="line">s.connect((<span class="string">&#x27;www.baidu.com&#x27;</span>, <span class="number">80</span>))</span><br></pre></td></tr></table></figure>

<p>创建<code>Socket</code>时，<code>AF_INET</code>指定使用<code>IPv4</code>协议，<code>SOCK_STREAM</code>指定使用面向流的TCP协议，这样，一个<code>Socket</code>对象就创建成功，但是还没有建立连接。</p>
<p>客户端要主动发起TCP连接，必须知道服务器的IP地址和端口号。IP地址可以通过域名dns解析获取到，端口号一般是固定80和443。</p>
<p>连接服务器的代码</p>
<blockquote>
<p>s.connect((‘<a href="http://www.baidu.com/">www.baidu.com</a>‘, 80))</p>
</blockquote>
<p>注意参数是一个<code>tuple</code>，包含地址和端口号。</p>
<p>建立TCP连接后，我们就可以向服务器发送请求，要求返回首页的内容：</p>
<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>服务器进程首先要绑定一个端口并监听来自其他客户端的连接。如果某个客户端连接过来了，服务器就与该客户端建立Socket连接，随后的通信就靠这个Socket连接了。</p>
<p>一个Socket依赖4项：服务器地址、服务器端口、客户端地址、客户端端口来唯一确定一个Socket。</p>
<p>是服务器还需要同时响应多个客户端的请求，所以，每个连接都需要一个新的进程或者新的线程来处理，否则，服务器一次就只能服务一个客户端了。</p>
<p>我们来编写一个简单的服务器程序，它接收客户端连接，把客户端发过来的字符串加上<code>Hello</code>再发回去。</p>
<p>首先，创建一个基于IPv4和TCP协议的Socket：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br></pre></td></tr></table></figure>

<p>然后，我们要绑定监听的地址和端口。服务器可能有多块网卡，可以绑定到某一块网卡的IP地址上，也可以用0.0.0.0绑定到所有的网络地址，还可以用127.0.0.1绑定到本机地址。127.0.0.1是一个特殊的IP地址，表示本机地址，如果绑定到这个地址，客户端必须同时在本机运行才能连接，也就是说，外部的计算机无法连接进来。</p>
<p>端口号需要预先指定。因为我们写的这个服务不是标准服务，所以用<code>8888</code>这个端口号。请注意，小于<code>1024</code>的端口号必须要有管理员权限才能绑定：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 监听端口:</span></span><br><span class="line">s.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8888</span>))</span><br></pre></td></tr></table></figure>
<p>紧接着，调用listen()方法开始监听端口，传入的参数指定等待连接的最大数量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s.listen(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Waiting for connection...&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>接下来，服务器程序通过一个永久循环来接受来自客户端的连接，<code>accept()</code>会等待并返回一个客户端的连接:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 接受一个新连接:</span></span><br><span class="line">    sock, addr = s.accept()</span><br><span class="line">    <span class="comment"># 创建新线程来处理TCP连接:</span></span><br><span class="line">    t = threading.Thread(target=tcplink, args=(sock, addr))</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>

<p>每个连接都必须创建新线程（或进程）来处理，否则，单线程在处理连接的过程中，无法接受其他客户端的连接：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tcplink</span>(<span class="params">sock, addr</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Accept new connection from %s:%s...&#x27;</span> % addr)</span><br><span class="line">    sock.send(<span class="string">b&#x27;Welcome!&#x27;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = sock.recv(<span class="number">1024</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data <span class="keyword">or</span> data.decode(<span class="string">&#x27;utf-8&#x27;</span>) == <span class="string">&#x27;exit&#x27;</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        sock.send((<span class="string">&#x27;Hello, %s!&#x27;</span> % data.decode(<span class="string">&#x27;utf-8&#x27;</span>)).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    sock.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Connection from %s:%s closed.&#x27;</span> % addr)</span><br></pre></td></tr></table></figure>
<p>连接建立后，服务器首先发一条欢迎消息，然后等待客户端数据，并加上<code>Hello</code>再发送给客户端。如果客户端发送了<code>exit</code>字符串，就直接关闭连接。</p>
<p>要测试这个服务器程序，我们还需要编写一个客户端程序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 建立连接:</span></span><br><span class="line">s.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>))</span><br><span class="line"><span class="comment"># 接收欢迎消息:</span></span><br><span class="line"><span class="built_in">print</span>(s.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> [<span class="string">b&#x27;Michael&#x27;</span>, <span class="string">b&#x27;Tracy&#x27;</span>, <span class="string">b&#x27;Sarah&#x27;</span>]:</span><br><span class="line">    <span class="comment"># 发送数据:</span></span><br><span class="line">    s.send(data)</span><br><span class="line">    <span class="built_in">print</span>(s.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">s.send(<span class="string">b&#x27;exit&#x27;</span>)</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure>

<p>我们需要打开两个命令行窗口，一个运行服务器程序，另一个运行客户端程序，就可以看到效果了</p>
<h1 id="UDP编程"><a href="#UDP编程" class="headerlink" title="UDP编程"></a>UDP编程</h1><p>TCP是建立可靠连接，并且通信双方都可以以流的形式发送数据。相对TCP，UDP则是面向无连接的协议。</p>
<p>使用UDP协议时，不需要建立连接，只需要知道对方的IP地址和端口号，就可以直接发数据包。但是，能不能到达就不知道了。</p>
<p>虽然用UDP传输数据不可靠，但它的优点是和TCP比，速度快，对于不要求可靠到达的数据，就可以使用UDP协议。</p>
<p>和TCP类似，使用UDP的通信双方也分为客户端和服务器。服务器首先需要绑定端口：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"><span class="comment"># 绑定端口:</span></span><br><span class="line">s.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>))</span><br></pre></td></tr></table></figure>

<p>创建Socket时，<code>SOCK_DGRAM</code>指定了这个Socket的类型是UDP。绑定端口和TCP一样，但是不需要调用<code>listen()</code>方法，而是直接接收来自任何客户端的数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Bind UDP on 9999...&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 接收数据:</span></span><br><span class="line">    data, addr = s.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Received from %s:%s.&#x27;</span> % addr)</span><br><span class="line">    s.sendto(<span class="string">b&#x27;Hello, %s!&#x27;</span> % data, addr)</span><br></pre></td></tr></table></figure>
<p><code>recvfrom()</code>方法返回数据和客户端的地址与端口，这样，服务器收到数据后，直接调用<code>sendto()</code>就可以把数据用UDP发给客户端。</p>
<p>客户端使用UDP时，首先仍然创建基于UDP的Socket，然后，不需要调用<code>connect()</code>，直接通过<code>sendto()</code>给服务器发数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">100</span>)):</span><br><span class="line">    <span class="comment"># 发送数据:</span></span><br><span class="line">    s.sendto(<span class="built_in">str</span>(data).encode(<span class="string">&#x27;utf-8&#x27;</span>), (<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>))</span><br><span class="line">    <span class="comment"># 接收数据:</span></span><br><span class="line">    <span class="built_in">print</span>(s.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure>
<p>从服务器接收数据仍然调用<code>recv()</code>方法。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>16.python电子邮件</title>
    <url>/hexoblog/python/16.python%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6/</url>
    <content><![CDATA[<p>使用SMTP发送邮件，使用POP3接收邮件。</p>
<span id="more"></span>

<h1 id="SMTP发送邮件"><a href="#SMTP发送邮件" class="headerlink" title="SMTP发送邮件"></a>SMTP发送邮件</h1><p>SMTP是发送邮件的协议，Python内置对SMTP的支持，可以发送纯文本邮件、HTML邮件以及带附件的邮件。</p>
<p>Python对SMTP支持有<code>smtplib</code>和<code>email</code>两个模块，<code>email</code>负责构造邮件，<code>smtplib</code>负责发送邮件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line">msg = MIMEText(<span class="string">&#x27;测试下邮件发送&#x27;</span>, <span class="string">&#x27;plain&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>注意到构造<code>MIMEText</code>对象时，第一个参数就是邮件正文，第二个参数是MIME的subtype，传入<code>&#39;plain&#39;</code>表示纯文本，最终的MIME就是<code>&#39;text/plain&#39;</code>，最后一定要用<code>utf-8</code>编码保证多语言兼容性。</p>
<p>然后，通过SMTP发出去：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"><span class="keyword">from</span> email.utils <span class="keyword">import</span> formataddr, parseaddr</span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_format_addr</span>(<span class="params">s</span>):</span><br><span class="line">    name, addr = parseaddr(s)</span><br><span class="line">    <span class="keyword">return</span> formataddr((Header(name, <span class="string">&#x27;utf-8&#x27;</span>).encode(), addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入Email地址和口令:</span></span><br><span class="line">from_addr = <span class="string">&#x27;xxxxxx&#x27;</span></span><br><span class="line">password = <span class="string">&#x27;xxxx&#x27;</span></span><br><span class="line"><span class="comment"># 输入收件人地址:</span></span><br><span class="line">to_addr = <span class="string">&#x27;xxx@qq.com&#x27;</span></span><br><span class="line"><span class="comment"># 输入SMTP服务器地址:</span></span><br><span class="line">smtp_server = <span class="string">&#x27;xxx.xxx.com&#x27;</span></span><br><span class="line"></span><br><span class="line">msg = MIMEText(<span class="string">&#x27;哈哈哈哈哈&#x27;</span>, <span class="string">&#x27;plain&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">msg[<span class="string">&#x27;From&#x27;</span>] = _format_addr(<span class="string">&#x27;测试下邮件发送 &lt;%s&gt;&#x27;</span> % from_addr)</span><br><span class="line">msg[<span class="string">&#x27;To&#x27;</span>] = _format_addr(<span class="string">&#x27;管理员 &lt;%s&gt;&#x27;</span> % to_addr)</span><br><span class="line">msg[<span class="string">&#x27;Subject&#x27;</span>] = Header(<span class="string">&#x27;来自SMTP的问候……&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>).encode()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line">server = smtplib.SMTP(smtp_server, <span class="number">25</span>) <span class="comment"># SMTP协议默认端口是25</span></span><br><span class="line">server.set_debuglevel(<span class="number">1</span>)</span><br><span class="line">server.login(from_addr, password)</span><br><span class="line">server.sendmail(from_addr, [to_addr], msg.as_string())</span><br><span class="line">server.quit()</span><br></pre></td></tr></table></figure>
<p>我们用<code>set_debuglevel(1)</code>就可以打印出和SMTP服务器交互的所有信息。SMTP协议就是简单的文本命令和响应。<code>login()</code>方法用来登录SMTP服务器，<code>sendmail()</code>方法就是发邮件，由于可以一次发给多个人，所以传入一个<code>list</code>，邮件正文是一个<code>str</code>，<code>as_string()</code>把<code>MIMEText</code>对象变成<code>str</code>。</p>
<p>必须把<code>From</code>、<code>To</code>和<code>Subject</code>添加到<code>MIMEText</code>中，才是一封完整的邮件， 否则无法显示主题，收件人等信息。</p>
<h2 id="发送HTML邮件"><a href="#发送HTML邮件" class="headerlink" title="发送HTML邮件"></a>发送HTML邮件</h2><p>如果我们要发送HTML邮件，方法很简单，在构造<code>MIMEText</code>对象时，把<code>HTML</code>字符串传进去，再把第二个参数由<code>plain</code>变为<code>html</code>就可以了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">msg = MIMEText(<span class="string">&#x27;&lt;h1&gt;哈哈哈哈哈&lt;/h1&gt;&#x27;</span>, <span class="string">&#x27;html&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="发送附件"><a href="#发送附件" class="headerlink" title="发送附件"></a>发送附件</h2><p>可以构造一个<code>MIMEMultipart</code>对象代表邮件本身，然后往里面加上一个<code>MIMEText</code>作为邮件正文，再继续往里面加上表示附件的<code>MIMEBase</code>对象即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">msg = MIMEMultipart()</span><br><span class="line">msg[<span class="string">&#x27;From&#x27;</span>] = _format_addr(<span class="string">&#x27;Python爱好者 &lt;%s&gt;&#x27;</span> % from_addr)</span><br><span class="line">msg[<span class="string">&#x27;To&#x27;</span>] = _format_addr(<span class="string">&#x27;管理员 &lt;%s&gt;&#x27;</span> % to_addr)</span><br><span class="line">msg[<span class="string">&#x27;Subject&#x27;</span>] = Header(<span class="string">&#x27;来自SMTP的问候……&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>).encode()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 邮件正文是MIMEText:</span></span><br><span class="line">msg.attach(MIMEText(<span class="string">&#x27;send with file...&#x27;</span>, <span class="string">&#x27;plain&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加附件就是加上一个MIMEBase，从本地读取一个图片:</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;D:/oldimg.jpg&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 设置附件的MIME和文件名，这里是png类型:</span></span><br><span class="line">    mime = MIMEBase(<span class="string">&#x27;image&#x27;</span>, <span class="string">&#x27;jpg&#x27;</span>, filename=<span class="string">&#x27;oldimg.jpg&#x27;</span>)</span><br><span class="line">    <span class="comment"># 加上必要的头信息:</span></span><br><span class="line">    mime.add_header(<span class="string">&#x27;Content-Disposition&#x27;</span>, <span class="string">&#x27;attachment&#x27;</span>, filename=<span class="string">&#x27;oldimg.jpg&#x27;</span>)</span><br><span class="line">    mime.add_header(<span class="string">&#x27;Content-ID&#x27;</span>, <span class="string">&#x27;&lt;0&gt;&#x27;</span>)</span><br><span class="line">    mime.add_header(<span class="string">&#x27;X-Attachment-Id&#x27;</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    <span class="comment"># 把附件的内容读进来:</span></span><br><span class="line">    mime.set_payload(f.read())</span><br><span class="line">    <span class="comment"># 用Base64编码:</span></span><br><span class="line">    encoders.encode_base64(mime)</span><br><span class="line">    <span class="comment"># 添加到MIMEMultipart:</span></span><br><span class="line">    msg.attach(mime)</span><br></pre></td></tr></table></figure>
<p>然后，按正常发送流程把msg（注意类型已变为<code>MIMEMultipart</code>）发送出去，就可以收到如下带附件的邮件</p>
<h2 id="发送图片"><a href="#发送图片" class="headerlink" title="发送图片"></a>发送图片</h2><p>如果要把一个图片嵌入到邮件正文中怎么做？直接在HTML邮件中链接图片地址行不行？答案是，大部分邮件服务商都会自动屏蔽带有外链的图片，因为不知道这些链接是否指向恶意网站。</p>
<p>要把图片嵌入到邮件正文中，我们只需按照发送附件的方式，先把邮件作为附件添加进去，然后，在HTML中通过引用<code>src=&quot;cid:0&quot;</code>就可以把附件作为图片嵌入了。如果有多个图片，给它们依次编号，然后引用不同的<code>cid:x</code>即可。</p>
<p>把上面代码加入<code>MIMEMultipart</code>的<code>MIMEText</code>从<code>plain</code>改为<code>html</code>，然后在适当的位置引用图片</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">msg.attach(MIMEText(<span class="string">&#x27;&lt;html&gt;&lt;body&gt;&lt;h1&gt;下面是一个图片&lt;/h1&gt;&lt;br/&gt;&lt;img src=&quot;cid:0&quot;&gt;&lt;/body&gt;&lt;/html&gt;&#x27;</span>, <span class="string">&#x27;html&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>


<h2 id="同时支持HTML和Plain格式"><a href="#同时支持HTML和Plain格式" class="headerlink" title="同时支持HTML和Plain格式"></a>同时支持HTML和Plain格式</h2><p>为了兼容旧设备，在发送HTML的同时再附加一个纯文本，如果收件人无法查看HTML格式的邮件，就可以自动降级查看纯文本邮件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">msg = MIMEMultipart(<span class="string">&#x27;alternative&#x27;</span>)</span><br><span class="line">msg[<span class="string">&#x27;From&#x27;</span>] = ...</span><br><span class="line">msg[<span class="string">&#x27;To&#x27;</span>] = ...</span><br><span class="line">msg[<span class="string">&#x27;Subject&#x27;</span>] = ...</span><br><span class="line"></span><br><span class="line">msg.attach(MIMEText(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;plain&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">msg.attach(MIMEText(<span class="string">&#x27;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&#x27;</span>, <span class="string">&#x27;html&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="comment"># 正常发送msg对象...</span></span><br></pre></td></tr></table></figure>

<h2 id="加密SMTP"><a href="#加密SMTP" class="headerlink" title="加密SMTP"></a>加密SMTP</h2><p>使用标准的25端口连接SMTP服务器时，使用的是明文传输，发送邮件的整个过程可能会被窃听。要更安全地发送邮件，可以加密SMTP会话，实际上就是先创建SSL安全连接，然后再使用SMTP协议发送邮件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">server = smtplib.SMTP(smtp_server, <span class="number">465</span>) </span><br><span class="line">server.starttls()</span><br></pre></td></tr></table></figure>
<p>只需要在创建SMTP对象后，立刻调用starttls()方法，就创建了安全连接。后面的代码和前面的发送邮件代码完全一样。</p>
<p>构造一个邮件对象就是一个<code>Messag</code>对象，如果构造一个<code>MIMEText</code>对象，就表示一个文本邮件对象，如果构造一个<code>MIMEImage</code>对象，就表示一个作为附件的图片，要把多个对象组合起来，就用<code>MIMEMultipart</code>对象，而<code>MIMEBase</code>可以表示任何对象。它们的继承关系如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Message</span><br><span class="line">+- MIMEBase</span><br><span class="line">   +- MIMEMultipart</span><br><span class="line">   +- MIMENonMultipart</span><br><span class="line">      +- MIMEMessage</span><br><span class="line">      +- MIMEText</span><br><span class="line">      +- MIMEImage</span><br></pre></td></tr></table></figure>
<p>这种嵌套关系就可以构造出任意复杂的邮件。</p>
<h1 id="POP3收取邮件"><a href="#POP3收取邮件" class="headerlink" title="POP3收取邮件"></a>POP3收取邮件</h1><p>Python内置一个<code>poplib</code>模块，实现了POP3协议，可以直接用来收邮件。</p>
<p>注意到POP3协议收取的不是一个已经可以阅读的邮件本身，而是邮件的原始文本，这和SMTP协议很像，SMTP发送的也是经过编码后的一大段文本。</p>
<p>要把POP3收取的文本变成可以阅读的邮件，还需要用email模块提供的各种类来解析原始文本，变成可阅读的邮件对象。</p>
<p>所以，收取邮件分两步：</p>
<p>第一步：用<code>poplib</code>把邮件的原始文本下载到本地；</p>
<p>第二步：用<code>email</code>解析原始文本，还原为邮件对象。</p>
<h2 id="通过POP3下载邮件"><a href="#通过POP3下载邮件" class="headerlink" title="通过POP3下载邮件"></a>通过POP3下载邮件</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> poplib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入邮件地址, 口令和POP3服务器地址:</span></span><br><span class="line">email = <span class="built_in">input</span>(<span class="string">&#x27;Email: &#x27;</span>)</span><br><span class="line">password = <span class="built_in">input</span>(<span class="string">&#x27;Password: &#x27;</span>)</span><br><span class="line">pop3_server = <span class="built_in">input</span>(<span class="string">&#x27;POP3 server: &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接到POP3服务器:</span></span><br><span class="line">server = poplib.POP3(pop3_server)</span><br><span class="line"><span class="comment"># 可以打开或关闭调试信息:</span></span><br><span class="line">server.set_debuglevel(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 可选:打印POP3服务器的欢迎文字:</span></span><br><span class="line"><span class="built_in">print</span>(server.getwelcome().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 身份认证:</span></span><br><span class="line">server.user(email)</span><br><span class="line">server.pass_(password)</span><br><span class="line"></span><br><span class="line"><span class="comment"># stat()返回邮件数量和占用空间:</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Messages: %s. Size: %s&#x27;</span> % server.stat())</span><br><span class="line"><span class="comment"># list()返回所有邮件的编号:</span></span><br><span class="line">resp, mails, octets = server.<span class="built_in">list</span>()</span><br><span class="line"><span class="comment"># 可以查看返回的列表类似[b&#x27;1 82923&#x27;, b&#x27;2 2184&#x27;, ...]</span></span><br><span class="line"><span class="built_in">print</span>(mails)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取最新一封邮件, 注意索引号从1开始:</span></span><br><span class="line">index = <span class="built_in">len</span>(mails)</span><br><span class="line">resp, lines, octets = server.retr(index)</span><br><span class="line"></span><br><span class="line"><span class="comment"># lines存储了邮件的原始文本的每一行,</span></span><br><span class="line"><span class="comment"># 可以获得整个邮件的原始文本:</span></span><br><span class="line">msg_content = <span class="string">b&#x27;\r\n&#x27;</span>.join(lines).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment"># 稍后解析出邮件:</span></span><br><span class="line">msg = Parser().parsestr(msg_content)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以根据邮件索引号直接从服务器删除邮件:</span></span><br><span class="line"><span class="comment"># server.dele(index)</span></span><br><span class="line"><span class="comment"># 关闭连接:</span></span><br><span class="line">server.quit()</span><br></pre></td></tr></table></figure>

<p>用POP3获取邮件其实很简单，要获取所有邮件，只需要循环使用<code>retr()</code>把每一封邮件内容拿到即可。真正麻烦的是把邮件的原始内容解析为可以阅读的邮件对象。</p>
<h2 id="解析邮件"><a href="#解析邮件" class="headerlink" title="解析邮件"></a>解析邮件</h2><p>解析邮件的过程和上一节构造邮件正好相反，因此，先导入必要的模块：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">from email.parser import Parser</span><br><span class="line">from email.header import decode_header</span><br><span class="line">from email.utils import parseaddr</span><br><span class="line"></span><br><span class="line">import poplib</span><br></pre></td></tr></table></figure>
<p>只需要一行代码就可以把邮件内容解析为<code>Message</code>对象：</p>
<p>但是这个<code>Message</code>对象本身可能是一个<code>MIMEMultipart</code>对象，即包含嵌套的其他<code>MIMEBase</code>对象，嵌套可能还不止一层。</p>
<p>所以我们要递归地打印出<code>Message</code>对象的层次结构：</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>17.python访问数据库</title>
    <url>/hexoblog/python/17.python%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p>主要介绍数据库的相关操作和SQLAlchemy框架</p>
<span id="more"></span>

<h1 id="使用SQLite"><a href="#使用SQLite" class="headerlink" title="使用SQLite"></a>使用SQLite</h1><p>Python就内置了SQLite3的驱动，可以直接使用</p>
<p>要操作关系数据库，首先需要连接到数据库，一个数据库连接称为<code>Connection</code>；</p>
<p>连接到数据库后，需要打开游标，称之为<code>Cursor</code>，通过<code>Cursor</code>执行SQL语句，然后，获得执行结果。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import sqlite3</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; conn = sqlite3.connect(<span class="string">&#x27;python.db&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; cursor = conn.cursor()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; cursor.execute(<span class="string">&#x27;create table user (id int primary key, name varchar(20))&#x27;</span>)</span></span><br><span class="line">&lt;sqlite3.Cursor object at 0x0000027FCA51F740&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; cursor.execute(<span class="string">&#x27;insert into user values  (1, &quot;张三&quot;)&#x27;</span>)</span></span><br><span class="line">&lt;sqlite3.Cursor object at 0x0000027FCA51F740&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; cursor.rowcount</span></span><br><span class="line">1</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; cursor.execute(<span class="string">&#x27;select * from user where name = &quot;张三&quot;&#x27;</span>)</span></span><br><span class="line">&lt;sqlite3.Cursor object at 0x0000027FCA51F740&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; value = cursor.fetchall()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; value</span></span><br><span class="line">[(1, &#x27;张三&#x27;)]</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用<code>Cursor</code>对象执行<code>insert</code>，<code>update</code>，<code>delete</code>语句时，执行结果由<code>rowcount</code>返回影响的行数，就可以拿到执行结果。</p>
<p>使用<code>Cursor</code>对象执行<code>select</code>语句时，通过<code>fetchall()</code>可以拿到结果集。结果集是一个<code>list</code>，每个元素都是一个<code>tuple</code>，对应一行记录。</p>
<p>如果SQL语句带有参数，那么需要把参数按照位置传递给<code>execute()</code>方法，有几个<code>?</code>占位符就必须对应几个参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; cursor.execute(<span class="string">&#x27;select * from user where id = ? or name = ?&#x27;</span>, (1, <span class="string">&#x27;李四&#x27;</span>))</span></span><br><span class="line">&lt;sqlite3.Cursor object at 0x0000027FCA51F6C0&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; value = cursor.fetchall()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; value</span></span><br><span class="line">[(1, &#x27;张三&#x27;), (2, &#x27;李四&#x27;)]</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p>要确保打开的<code>Connection</code>对象和<code>Cursor</code>对象都正确地被关闭，否则，资源就会泄露。</p>
<h1 id="使用MySql"><a href="#使用MySql" class="headerlink" title="使用MySql"></a>使用MySql</h1><p>需要安装驱动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install mysql-connector</span><br></pre></td></tr></table></figure>

<p>相关操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">conn = mysql.connector.connect(host=<span class="string">&#x27;localhost&#x27;</span>, user=<span class="string">&#x27;root&#x27;</span>, password=<span class="string">&#x27;root&#x27;</span>,database=<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cursor = conn.cursor()</span><br><span class="line">cursor.execute(<span class="string">&#x27;create table t_user(id int not null AUTO_INCREMENT primary key, name varchar(20))&#x27;</span>)</span><br><span class="line"><span class="comment"># 入库</span></span><br><span class="line">cursor.execute(<span class="string">&#x27;insert into t_user values (%s, %s)&#x27;</span>, (<span class="number">1</span>, <span class="string">&#x27;张三&#x27;</span>))</span><br><span class="line">cursor.execute(<span class="string">&#x27;insert into t_user values (%s, %s)&#x27;</span>, (<span class="number">2</span>, <span class="string">&#x27;李四&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;执行结果&#x27;</span>, cursor.rowcount)</span><br><span class="line"></span><br><span class="line">conn.commit()</span><br><span class="line">cursor.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行查询</span></span><br><span class="line">cursor = conn.cursor()</span><br><span class="line">cursor.execute(<span class="string">&#x27;select * from t_user where name = %s&#x27;</span>, (<span class="string">&#x27;张三&#x27;</span>, ))</span><br><span class="line">values = cursor.fetchall()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(values)</span><br><span class="line"><span class="built_in">print</span>(json.dumps(values, ensure_ascii=<span class="literal">False</span>))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>执行INSERT等操作后要调用<code>commit()</code>提交事务</p>
<p>MySQL的SQL占位符是<code>%s</code></p>
<h1 id="使用SQLAlchemy"><a href="#使用SQLAlchemy" class="headerlink" title="使用SQLAlchemy"></a>使用SQLAlchemy</h1><p>数据库表是一个二维表，包含多行多列。把一个表的内容用Python的数据结构表示出来的话，可以用一个list表示多行，list的每一个元素是tuple，表示一行记录，比如下面的记录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  (1, &#x27;张三&#x27;), </span><br><span class="line">  (2, &#x27;李四&#x27;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>Python的DB-API返回的数据结构就是像上面这样表示的</p>
<p>但是用tuple表示一行很难看出表的结构。如果把一个tuple用class实例来表示，就可以更容易地看出表的结构来，可以使用ORM框架进行转换，最有名的ORM框架是SQLAlchemy。</p>
<p>先安装 <code> pip install sqlalchemy</code></p>
<p>然后，利用上次我们在MySQL的test数据库中创建的<code>t_user</code>表，用SQLAlchemy来试试</p>
<p>第一步，导入SQLAlchemy，并初始化DBSession</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Column, INT, String, create_engine</span><br><span class="line"><span class="keyword">import</span> sqlalchemy</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建对象的基类:</span></span><br><span class="line">Base = sqlalchemy.orm.declarative_base()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义user对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line">    <span class="comment"># 表的名字:</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;t_user&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 表的结构:</span></span><br><span class="line">    <span class="built_in">id</span> = Column(INT, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">20</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化数据库连接:</span></span><br><span class="line">engine = create_engine(<span class="string">&#x27;mysql+mysqlconnector://root:root@localhost:3306/test&#x27;</span>)</span><br><span class="line"><span class="comment"># 创建DBSession类型:</span></span><br><span class="line">DBSession = sessionmaker(bind=engine)</span><br><span class="line"><span class="built_in">print</span>(DBSession)</span><br></pre></td></tr></table></figure>

<p>以上代码完成SQLAlchemy的初始化和具体每个表的class定义。如果有多个表，就继续定义其他class</p>
<p><code>create_engine()</code>用来初始化数据库连接。SQLAlchemy用一个字符串表示连接信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;数据库类型+数据库驱动名称://用户名:口令@机器地址:端口号/数据库名&#x27;</span><br></pre></td></tr></table></figure>

<p>由于有了ORM，我们向数据库表中添加一行记录，可以视为添加一个<code>User</code>对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建session对象</span></span><br><span class="line">session = DBSession()</span><br><span class="line"><span class="comment"># 创建新User对象</span></span><br><span class="line">user1 = User(name=<span class="string">&#x27;Jim&#x27;</span>)</span><br><span class="line"><span class="comment"># 添加到session</span></span><br><span class="line">session.add(user1)</span><br><span class="line"><span class="comment"># 提交即保存到数据库</span></span><br><span class="line">session.commit()</span><br><span class="line"><span class="comment"># 关闭session</span></span><br><span class="line">session.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>关键是获取<code>session</code>，然后把对象添加到<code>session</code>，最后提交并关闭。<code>DBSession</code>对象可视为当前数据库连接</p>
<p>查询操作，查询出来的可以不再是<code>tuple</code>，而是<code>User</code>对象。SQLAlchemy提供的查询接口如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">session = DBSession()</span><br><span class="line"><span class="comment"># 创建Query查询，filter是where条件，最后调用one()返回唯一行，如果调用all()则返回所有行</span></span><br><span class="line">user2 = session.query(User).<span class="built_in">filter</span>(User.<span class="built_in">id</span> == <span class="number">2</span>).one()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;type:&#x27;</span>, <span class="built_in">type</span>(user2))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;name:&#x27;</span>, user2.name)</span><br><span class="line"><span class="comment"># 查询多条</span></span><br><span class="line">user_list = session.query(User).<span class="built_in">filter</span>(User.<span class="built_in">id</span> &gt; <span class="number">0</span>).<span class="built_in">all</span>()</span><br><span class="line"><span class="built_in">print</span>(user_list)</span><br></pre></td></tr></table></figure>

<p>ORM就是把数据库表的行与相应的对象建立关联，互相转换。</p>
<h2 id="查询结果JSON序列化"><a href="#查询结果JSON序列化" class="headerlink" title="查询结果JSON序列化"></a>查询结果JSON序列化</h2><p>直接进行JSON序列化会报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">TypeError: Object of type User is not JSON serializable</span><br></pre></td></tr></table></figure>

<p>使用 <code>default=lambda obj: obj.dict</code> 一样报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">print(json.dumps(user2, default=lambda obj: obj.dict, ensure_ascii=False))</span><br><span class="line"></span><br><span class="line">AttributeError: &#x27;User&#x27; object has no attribute &#x27;dict&#x27;</span><br></pre></td></tr></table></figure>

<p>正确的方式</p>
<p>使用 SQLAlchemy 对象进行 JSON 序列化时，可以使用 SQLAlchemy 提供的 <code>sqlalchemy.ext.declarative.as_declarative()</code> 装饰器和 <code>sqlalchemy.ext.declarative.declared_attr()</code> 装饰器来定义自定义的序列化方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@as_declarative()</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>:</span><br><span class="line"><span class="meta">    @declared_attr</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__tablename__</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="keyword">return</span> cls.__name__.lower()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">to_dict</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> &#123;c.name: <span class="built_in">getattr</span>(self, c.name) <span class="keyword">for</span> c <span class="keyword">in</span> self.__table__.columns&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 序列化时改用 </span></span><br><span class="line"><span class="built_in">print</span>(json.dumps(user2.to_dict(), ensure_ascii=<span class="literal">False</span>))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>18.python-web开发</title>
    <url>/hexoblog/python/18.python-web%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p>C&#x2F;S架构，B&#x2F;S架构，web开发主要指B&#x2F;S架构。</p>
<span id="more"></span>

<h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><p>每个HTTP请求和响应都遵循相同的格式，一个HTTP包含Header和Body两部分，其中Body是可选的。</p>
<p>HTTP协议是一种文本协议，所以，它的格式也非常简单。HTTP GET请求的格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /path HTTP/1.1</span><br><span class="line">Header1: Value1</span><br><span class="line">Header2: Value2</span><br><span class="line">Header3: Value3</span><br></pre></td></tr></table></figure>
<p>每个Header一行一个，换行符是<code>\r\n</code></p>
<p>HTTP POST请求的格式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">POST /path HTTP/1.1</span><br><span class="line">Header1: Value1</span><br><span class="line">Header2: Value2</span><br><span class="line">Header3: Value3</span><br><span class="line"></span><br><span class="line">body data goes here...</span><br></pre></td></tr></table></figure>
<p>当遇到连续两个<code>\r\n</code>时，Header部分结束，后面的数据全部是Body</p>
<p>HTTP响应的格式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">200 OK</span><br><span class="line">Header1: Value1</span><br><span class="line">Header2: Value2</span><br><span class="line">Header3: Value3</span><br><span class="line"></span><br><span class="line">body data goes here...</span><br></pre></td></tr></table></figure>

<p>HTTP响应如果包含body，也是通过<code>\r\n\r\n</code>来分隔的。Body的数据类型由<code>Content-Type</code>头来确定，如果是网页，Body就是文本，如果是图片，Body就是图片的二进制数据</p>
<p>看到<code>Content-Encoding: gzip</code>时，需要将Body数据先解压缩，才能得到真正的数据。压缩的目的在于减少Body的大小，加快网络传输。</p>
<h1 id="WSGI接口"><a href="#WSGI接口" class="headerlink" title="WSGI接口"></a>WSGI接口</h1><p>WSGI：Web Server Gateway Interface, 用于处理http内容的响应。</p>
<p>WSGI接口定义非常简单，它只要求Web开发者实现一个函数，就可以响应HTTP请求</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">application</span>(<span class="params">environ, start_response</span>):</span><br><span class="line">    start_response(<span class="string">&#x27;200 OK&#x27;</span>, [(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/html&#x27;</span>)])</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">b&#x27;&lt;h1&gt;Hello, web!&lt;/h1&gt;&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>上面的<code>application()</code>函数就是符合WSGI标准的一个HTTP处理函数，它接收两个参数</p>
<ul>
<li>environ：一个包含所有HTTP请求信息的<code>dict</code>对象</li>
<li>start_response：一个发送HTTP响应的函数</li>
</ul>
<p>在<code>application()</code>函数中，调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">start_response(<span class="string">&#x27;200 OK&#x27;</span>, [(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/html&#x27;</span>)])</span><br></pre></td></tr></table></figure>
<p>就发送了HTTP响应的Header，注意Header只能发送一次，也就是只能调用一次<code>start_response()</code>函数。<code>start_response()</code>函数接收两个参数，一个是HTTP响应码，一个是一组<code>list</code>表示的HTTP Header，每个Header用一个包含两个<code>str</code>的<code>tuple</code>表示。</p>
<p>通常情况下，都应该把<code>Content-Type</code>头发送给浏览器。其他很多常用的HTTP Header也应该发送。</p>
<p>然后，函数的返回值<code>b&#39;&lt;h1&gt;Hello, web!&lt;/h1&gt;&#39;</code>将作为HTTP响应的Body发送给浏览器。</p>
<p>有了WSGI，我们关心的就是如何从<code>environ</code>这个<code>dict</code>对象拿到HTTP请求信息，然后构造HTML，通过<code>start_response()</code>发送Header，最后返回Body。</p>
<p>整个<code>application()</code>函数本身没有涉及到任何解析HTTP的部分，也就是说，底层代码不需要我们自己编写，我们只负责在更高层次上考虑如何响应请求就可以了。</p>
<p><code>application()</code>函数必须由WSGI服务器来调用。可以选择符合WSGI规范的服务器。</p>
<p>Python内置了一个WSGI服务器，这个模块叫<code>wsgiref</code>，它是用纯Python编写的WSGI服务器的参考实现，仅用于开发和测试使用。</p>
<h2 id="运行WSGI服务"><a href="#运行WSGI服务" class="headerlink" title="运行WSGI服务"></a>运行WSGI服务</h2><p>先编写 <code>hello.py</code>, 实现Web应用程序的WSGI处理函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hello.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">application</span>(<span class="params">environ, start_response</span>):</span><br><span class="line">    start_response(<span class="string">&#x27;200 OK&#x27;</span>, [(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/html&#x27;</span>)])</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">b&#x27;&lt;h1&gt;Hello, web!&lt;/h1&gt;&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>再编写一个<code>server.py</code>，负责启动WSGI服务器，加载<code>application()</code>函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># server.py</span></span><br><span class="line"><span class="comment"># 从wsgiref模块导入:</span></span><br><span class="line"><span class="keyword">from</span> wsgiref.simple_server <span class="keyword">import</span> make_server</span><br><span class="line"><span class="comment"># 导入我们自己编写的application函数:</span></span><br><span class="line"><span class="keyword">from</span> hello <span class="keyword">import</span> application</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个服务器，IP地址为空，端口是8000，处理函数是application:</span></span><br><span class="line">httpd = make_server(<span class="string">&#x27;&#x27;</span>, <span class="number">8000</span>, application)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Serving HTTP on port 8000...&#x27;</span>)</span><br><span class="line"><span class="comment"># 开始监听HTTP请求:</span></span><br><span class="line">httpd.serve_forever()</span><br></pre></td></tr></table></figure>

<p>无论多么复杂的Web应用程序，入口都是一个WSGI处理函数。HTTP请求的所有输入信息都可以通过<code>environ</code>获得，HTTP响应的输出都可以通过<code>start_response()</code>加上函数返回值作为Body。</p>
<h1 id="使用Web框架"><a href="#使用Web框架" class="headerlink" title="使用Web框架"></a>使用Web框架</h1><p>一个Web App，就是写一个WSGI的处理函数，针对每个HTTP请求进行响应。但是如果url数量过多，代码就很复杂了，所以可以使用web框架。比如轻量级的Flask和功能强大的Django</p>
<p>下面用Flask进行演示。</p>
<p>编写一个<code>app.py</code> 处理3个url</p>
<ol>
<li><code>GET /</code>， 首页</li>
<li><code>GET /signin</code>，登录页面，返回登录表单</li>
<li><code>POST /login</code>， 处理登录请求</li>
</ol>
<p>Flask通过Python的装饰器在内部自动地把URL和函数给关联起来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">home</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&lt;h1&gt;Hello&lt;/H1&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/signin&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">signin_form</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;&#x27;&lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;p&gt;&lt;input name=&quot;username&quot;&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">            &lt;p&gt;&lt;input name=&quot;password&quot; type=&quot;password&quot;&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">            &lt;p&gt;&lt;button type=&quot;submit&quot;&gt;Sign In&lt;/button&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">            &lt;/form&gt;&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/login&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>():</span><br><span class="line">    <span class="comment"># 需要从request对象读取表单内容：</span></span><br><span class="line">    <span class="keyword">if</span> request.form[<span class="string">&#x27;username&#x27;</span>] == <span class="string">&#x27;admin&#x27;</span> <span class="keyword">and</span> request.form[<span class="string">&#x27;password&#x27;</span>] == <span class="string">&#x27;admin&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&lt;h2&gt;login success&lt;/h2&gt;&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&lt;h2&gt;用户名或密码错误&lt;/h2&gt;&#x27;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>

<p>在编写URL处理函数时，除了配置URL外，从HTTP请求拿到用户数据也是非常重要的。Web框架都提供了自己的API来实现这些功能。Flask通过<code>request.form[&#39;name&#39;]</code>来获取表单的内容。</p>
<h1 id="使用模板"><a href="#使用模板" class="headerlink" title="使用模板"></a>使用模板</h1><p>Web框架把我们从WSGI中拯救出来了。现在，我们只需要不断地编写函数，带上URL，就可以继续Web App的开发了。</p>
<p>Web App不仅仅是处理逻辑，展示给用户的页面也非常重要。在Python代码里拼字符串是不现实的，所以，模板技术出现了。</p>
<p>使用模板，我们需要预先准备一个HTML文档，这个HTML文档不是普通的HTML，而是嵌入了一些变量和指令，然后，根据我们传入的数据，替换后，得到最终的HTML，发送给用户</p>
<p>变量名比如 <code>&#123;&#123;name&#125;&#125;</code></p>
<p>这就是传说中的MVC：Model-View-Controller，中文名“模型-视图-控制器”。</p>
<p>Python处理URL的函数就是C：Controller，Controller负责业务逻辑，比如检查用户名是否存在，取出用户信息等等；</p>
<p>包含变量<code>&#123;&#123; name &#125;&#125;</code>的模板就是V：View，View负责显示逻辑，通过简单地替换一些变量，View最终输出的就是用户看到的HTML。</p>
<p>MVC中的Model在哪？Model是用来传给View的，这样View在替换变量的时候，就可以从Model中取出相应的数据。</p>
<p>Model可以是一个 <code>dict</code></p>
<p>因为Python支持关键字参数，很多Web框架允许传入关键字参数，然后，在框架内部组装出一个<code>dict</code>作为Model。</p>
<p>Flask通过<code>render_template()</code>函数来实现模板的渲染。和Web框架类似，Python的模板也有很多种。Flask默认支持的模板是<code>jinja2</code>，所以我们先直接安装<code>jinja2</code>：</p>
<p>可以把上面输出html字符串的改为使用模板</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request, render_template</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">home</span>():</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;home.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录页面</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/signin&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">signin</span>():</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;form.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/login&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>():</span><br><span class="line">    name = request.form[<span class="string">&#x27;username&#x27;</span>]</span><br><span class="line">    pwd = request.form[<span class="string">&#x27;password&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">&#x27;admin&#x27;</span> <span class="keyword">and</span> pwd == <span class="string">&#x27;password&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">&#x27;success.html&#x27;</span>, username = name)</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;form.html&#x27;</span>, message = <span class="string">&#x27;用户名或密码错误&#x27;</span>, username = name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>

<p><strong>首页</strong>  <code>home.html</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是首页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>表单页</strong> <code>form.html</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>登录页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        &#123;% if message %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color:red&quot;</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        &#123;% endif %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">legend</span>&gt;</span>请登录:<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;用户名&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123; username &#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;密码&quot;</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>成功页</strong> <code>success.html</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Welcome, &#123;&#123; username &#125;&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Welcome, &#123;&#123; username &#125;&#125;!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;% for i in range(pageSize) %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/page/&#123;&#123; i &#125;&#125;&quot;</span>&gt;</span>第&#123;&#123; i + 1 &#125;&#125;页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">共 &#123;&#123;pageSize&#125;&#125; 页</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在<code>form.html</code>中加了一点条件判断，把<code>form.html</code>重用为登录失败的模板</p>
<p>一定要把模板放到正确的<code>templates</code>目录下，<code>templates</code>和<code>app.py</code>在同级目录下</p>
<p>通过MVC，我们在Python代码中处理M：Model和C：Controller，而V：View是通过模板处理的，这样，我们就成功地把Python代码和HTML代码最大限度地分离了。</p>
<p>使用模板的另一大好处是，模板改起来很方便，而且，改完保存后，刷新浏览器就能看到最新的效果。</p>
<p>在Jinja2模板中，我们用<code>&#123;&#123; name &#125;&#125;</code>表示一个需要替换的变量。很多时候，还需要循环、条件判断等指令语句，在Jinja2中，用<code>&#123;% ... %&#125;</code>表示指令</p>
<p>有了MVC，我们就分离了Python代码和HTML代码。HTML代码全部放到模板里，写起来更有效率。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>19.python异步IO</title>
    <url>/hexoblog/python/19.python%E5%BC%82%E6%AD%A5IO/</url>
    <content><![CDATA[<p>CPU的处理速度和IO的读写速度远远不匹配，会出现阻塞等待的情况，所以引入了多线程或者多进程来提升并行效率，但是线程数量也不能无限增加，否则将会耗费大量的时间在线程切换上。</p>
<p>除了多线程和多进程之外，另一种解决IO问题的方法是异步IO。</p>
<span id="more"></span>

<p>当代码需要执行一个耗时的IO操作时，它只发出IO指令，并不等待IO结果，然后就去执行其他代码了。一段时间后，当IO返回结果时，再通知CPU进行处理。</p>
<p>同步IO模型的代码是无法实现异步IO模型的。异步IO模型需要一个消息循环，在消息循环中，主线程不断地重复“读取消息-处理消息”这一过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">loop = get_event_loop()</span><br><span class="line">while True:</span><br><span class="line">    event = loop.get_event()</span><br><span class="line">    process_event(event)</span><br></pre></td></tr></table></figure>
<p>同步IO下，主线程只能挂起等待，异步IO的情况下，主线程可以去处理其他事情，大大提升了IO密集型程序下系统的多任务处理能力。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 真正意义上的 异步IO 是说内核直接将数据拷贝至用户态的内存单元，再通知程序直接去读取数据。</span><br><span class="line"># select / poll / epoll 都是同步IO的多路复用模式</span><br><span class="line"></span><br><span class="line"># 1.同步和异步</span><br><span class="line"># 同步和异步关注的是消息通信机制</span><br><span class="line"># 所谓同步，就是在发出一个*调用*时，没得到结果之前，该*调用*就不返回。但是一旦调用返回就得到返回值了，*调用者*主动等待这个*调用*的结果</span><br><span class="line"># 所谓异步，就是在发出一个*调用*时，这个*调用*就直接返回了，不管返回有没有结果。当一个异步过程调用发出后，*被调用者*通过状态，通知来通知*调用者*，或者通过回调函数处理这个调用</span><br><span class="line"></span><br><span class="line"># 2.阻塞和非阻塞</span><br><span class="line"># 阻塞和非阻塞关注的是程序在等待调用结果时的状态</span><br><span class="line"># 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才返回</span><br><span class="line"># 非阻塞调用是指在不能立即得到结果之前，该调用不会阻塞当前线程</span><br><span class="line"></span><br><span class="line"># 网络上的例子</span><br><span class="line">#老张爱喝茶，废话不说，煮开水。</span><br><span class="line">#出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。</span><br><span class="line">#1 老张把水壶放到火上，立等水开。（同步阻塞）；立等就是阻塞了老张去干别的事，老张得一直主动的看着水开没，这就是同步</span><br><span class="line">#2 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）；老张去看电视了，这就是非阻塞了，但是老张还是得关注着水开没，这也就是同步了</span><br><span class="line">#3 老张把响水壶放到火上，立等水开。（异步阻塞）；立等就是阻塞了老张去干别的事，但是老张不用时刻关注水开没，因为水开了，响水壶会提醒他，这就是异步了</span><br><span class="line">#4 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）；老张去看电视了，这就是非阻塞了，而且，等水开了，响水壶会提醒他，这就是异步了</span><br><span class="line">#所谓同步异步，只是对于水壶而言。普通水壶，同步；响水壶，异步。对应的也就是消息通信机制</span><br><span class="line">#虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。</span><br><span class="line">#所谓阻塞非阻塞，仅仅对于老张而言。立等的老张，阻塞；对应的也就是程序等待结果时的状态</span><br><span class="line">#看电视的老张，非阻塞。</span><br><span class="line">#情况1和情况3中老张就是阻塞的，媳妇喊他都不知道。虽然3中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。</span><br></pre></td></tr></table></figure>


<h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>协程，又称微线程，纤程。英文名Coroutine。</p>
<p>子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。</p>
<p>子程序调用是通过栈实现的，一个线程就是执行一个子程序。子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。</p>
<p>协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。</p>
<p>比如例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">A</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">B</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;z&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>假设由协程执行，在执行A的过程中，可以随时中断，去执行B，B也可能在执行过程中中断再去执行A，结果可能是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">x</span><br><span class="line">y</span><br><span class="line">3</span><br><span class="line">z</span><br></pre></td></tr></table></figure>

<p>看起来A、B的执行有点像多线程，但协程的特点在于是一个线程执行，那和多线程比，协程有何优势？</p>
<p>最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。</p>
<p>第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p>
<p>因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。</p>
<p>Python对协程的支持是通过generator实现的。</p>
<p>在generator中，我们不但可以通过<code>for</code>循环来迭代，还可以不断调用<code>next()</code>函数获取由<code>yield</code>语句返回的下一个值。</p>
<p>但是Python的<code>yield</code>不但可以返回一个值，它还可以接收调用者发出的参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>():</span><br><span class="line">    r = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = <span class="keyword">yield</span> r</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[consumer] 消费消息 %s ...&#x27;</span> % n)</span><br><span class="line">        r = <span class="string">&#x27;200 OK&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">producer</span>(<span class="params">c</span>):</span><br><span class="line">    c.send(<span class="literal">None</span>)</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="number">5</span>:</span><br><span class="line">        n = n+<span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[producer] 生产消息 %s ...&#x27;</span> % n)</span><br><span class="line">        r = c.send(n)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[producer] 消费者返回的结果为 %s ...&#x27;</span> % r)</span><br><span class="line"></span><br><span class="line">    c.close()</span><br><span class="line"></span><br><span class="line">c  = consumer()</span><br><span class="line">producer(c)</span><br></pre></td></tr></table></figure>
<p><code>consumer</code>函数是一个<code>generator</code>，把一个<code>consumer</code>传入producer后：</p>
<p><code>n = yield r</code> 的理解: </p>
<ul>
<li><code>yield r</code> 是将 <code>r</code> 返回给外部调用程序，交出控制权，暂停</li>
<li><code>n = yield</code> 可以接收外部程序通过<code>send()</code>发送的信息，并赋值给 <code>n</code>。 赋值语句在下一次启动生成器的时候首先被执行</li>
</ul>
<p>上面例子的执行过程</p>
<ol>
<li>首先调用<code>c.send(None)</code>启动生成器。功能类似于<code>next(c)</code></li>
<li>然后，一旦生产了东西，通过c.send(n)切换到consumer执行</li>
<li><code>consumer</code>通过<code>yield</code>拿到消息，处理，又通过<code>yield</code>把结果传回</li>
<li><code>produce</code>拿到<code>consumer</code>处理的结果，继续生产下一条消息</li>
<li><code>produce</code>决定不生产了，通过<code>c.close()</code>关闭<code>consumer</code>，整个过程结束</li>
</ol>
<p>整个流程无锁，由一个线程执行，<code>produce</code>和<code>consumer</code>协作完成任务，所以称为“协程”，而非线程的抢占式多任务。</p>
<p>“子程序就是协程的一种特例。”</p>
<h1 id="asyncio-async-await"><a href="#asyncio-async-await" class="headerlink" title="asyncio async&#x2F;await"></a>asyncio async&#x2F;await</h1><p><code>asyncio</code>的编程模型就是一个消息循环。我们从<code>asyncio</code>模块中直接获取一个<code>EventLoop</code>的引用，然后把需要执行的协程扔到<code>EventLoop</code>中执行，就实现了异步IO。</p>
<p>旧版本的使用方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;World&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取Event loop:</span></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"><span class="comment"># 执行coroutine</span></span><br><span class="line">loop.run_until_complete(main())</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure>

<p>在 Python 3.7+ 后，我们常常使用 <code>asyncio.run(coroutine)</code> 来代替以上获取<code> eventloop</code>、运行和关闭的操作，因为 <code>asyncio.run</code> 内部已经进行了封装。上述代码可以简化为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello world! %s &quot;</span> % threading.current_thread().name)</span><br><span class="line">    <span class="comment"># 异步调用asyncio.sleep(1):</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello again!  %s &quot;</span> % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line">asyncio.run(hello())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以在实际编程中，我们很少直接操作 <code>Eventloop</code>，更多的是使用 <code>asyncio</code> 提供的更高层的 API （如 <code>asyncio.run()</code>, <code>asyncio.create_task()</code>, <code>asyncio.sleep()</code> 等）。Eventloop 更多的是被用在开发更底层的库或者理解 asyncio 原理上。</p>
<p>我们用asyncio的异步网络连接来获取多个网站的首页</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">wget</span>(<span class="params">host</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;wget %s...&#x27;</span> % host)</span><br><span class="line">    connect = asyncio.open_connection(host, <span class="number">80</span>)</span><br><span class="line">    reader, writer = <span class="keyword">await</span> connect</span><br><span class="line">    header = <span class="string">&#x27;GET / HTTP/1.0\r\nHost: %s\r\n\r\n&#x27;</span> % host</span><br><span class="line">    writer.write(header.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    <span class="keyword">await</span> writer.drain()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        line = <span class="keyword">await</span> reader.readline()</span><br><span class="line">        <span class="keyword">if</span> line == <span class="string">b&#x27;\r\n&#x27;</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s header &gt; %s&#x27;</span> % (host, line.decode(<span class="string">&#x27;utf-8&#x27;</span>).rstrip()))</span><br><span class="line">    <span class="comment"># Ignore the body, close the socket</span></span><br><span class="line">    writer.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">multiTasks</span>():</span><br><span class="line">    tasks = [wget(host) <span class="keyword">for</span> host <span class="keyword">in</span> [<span class="string">&#x27;www.sina.com.cn&#x27;</span>, <span class="string">&#x27;www.sohu.com&#x27;</span>, <span class="string">&#x27;www.163.com&#x27;</span>]]</span><br><span class="line">    results = <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(multiTasks())</span><br></pre></td></tr></table></figure>

<h1 id="aiohttp"><a href="#aiohttp" class="headerlink" title="aiohttp"></a>aiohttp</h1><p><code>asyncio</code>可以实现单线程并发IO操作。如果仅用在客户端，发挥的威力不大。如果把<code>asyncio</code>用在服务器端，例如Web服务器，由于HTTP连接就是IO操作，因此可以用单线程+协程实现多用户的高并发支持。</p>
<p><code>asyncio</code>实现了TCP、UDP、SSL等协议，<code>aiohttp</code>则是基于<code>asyncio</code>实现的HTTP框架。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>2.python函数</title>
    <url>/hexoblog/python/2.python%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>主要介绍python中函数的定义，调用， python的内置函数等。</p>
<span id="more"></span>

<h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><p>python中有许多内置函数 <a href="https://docs.python.org/3/library/functions.html">Built-in Functions</a></p>
<p>调用函数时，传入的参数数量不对 或者 参数数据类型不对， 都会报错。</p>
<p>内置函数还包含数据类型转换的函数</p>
<h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><p>定义函数需要使用<code>def</code> 语句，后面依次写出函数名，括号，括号中的参数和冒号: ， 在缩进块中写函数体，返回值使用 <code>return</code> 返回</p>
<p>在Python交互环境中定义函数时，注意Python会出现…的提示。函数定义结束后需要按两次回车重新回到&gt;&gt;&gt;提示符下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; def func1(x):</span></span><br><span class="line">...   print(x)</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>空函数</strong></p>
<p>函数体使用 <code>pass</code> 语句，说明什么也不做。</p>
<p>可以用来做占位符，方便后续再补充函数体的内容。</p>
<p><strong>参数检查</strong></p>
<p>函数中可以使用参数检查函数 <code>isinstance</code> 来确保参数类型的准确性。</p>
<p><strong>返回多个值</strong></p>
<p>返回多个值，实际上返回的是一个tuple， 多个变量可以同时接收一个tuple，按位置赋给对应的值。</p>
<h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><p><strong>位置参数</strong></p>
<p>比如函数 <code>fun(x,y)</code>, 这两个参数都是位置参数，调用函数时，传入的两个值按照位置顺序依次赋值给 <code>x</code> 和 <code>y</code></p>
<p><strong>默认参数</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">def power(x, n=2):</span><br><span class="line">    s = 1</span><br><span class="line">    while n &gt; 0:</span><br><span class="line">        n = n - 1</span><br><span class="line">        s = s * x</span><br><span class="line">    return s</span><br></pre></td></tr></table></figure>

<p>默认参数注意事项：</p>
<ol>
<li>必选参数在前，默认参数在后</li>
<li>变化大的参数在前，变化小的参数在后，变化小的可以作为默认参数。</li>
<li>默认参数可以用来兼容旧的函数，避免修改后其他调用的地方报错。</li>
<li>默认参数可以降低调用函数的难度。</li>
<li>默认参数的坑 <strong>默认参数必须指向不变的对象</strong></li>
</ol>
<p><strong>可变参数</strong></p>
<p>在参数前面加一个 <code>*</code> 号， 在函数内部，参数接收到的是一个tuple</p>
<p>Python允许你在list或tuple前面加一个<code>*</code>号，把list或tuple的元素变成可变参数传进去。</p>
<p><strong>关键字参数</strong></p>
<p>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。</p>
<p>关键字参数， 可以扩展函数的功能，比如注册功能，将一些可选项，通过关键字参数传入进去。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">def person(name, age, **kw):</span><br><span class="line">    print(&#x27;name:&#x27;, name, &#x27;age:&#x27;, age, &#x27;other:&#x27;, kw)</span><br></pre></td></tr></table></figure>
<p>函数除了接受必选参数外，还可以接受关键字参数 <code>kw</code>, 调用函数时， 可以传入任意个数的关键字参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; person(<span class="string">&#x27;Michael&#x27;</span>, 30)</span></span><br><span class="line">name: Michael age: 30 other: &#123;&#125;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; person(<span class="string">&#x27;Bob&#x27;</span>, 35, city=<span class="string">&#x27;Beijing&#x27;</span>)</span></span><br><span class="line">name: Bob age: 35 other: &#123;&#x27;city&#x27;: &#x27;Beijing&#x27;&#125;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; person(<span class="string">&#x27;Adam&#x27;</span>, 45, gender=<span class="string">&#x27;M&#x27;</span>, job=<span class="string">&#x27;Engineer&#x27;</span>)</span></span><br><span class="line">name: Adam age: 45 other: &#123;&#x27;gender&#x27;: &#x27;M&#x27;, &#x27;job&#x27;: &#x27;Engineer&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>也可以先组装一个dict， 把dict作为关键字参数传递进去。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; extra = &#123;<span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;Beijing&#x27;</span>, <span class="string">&#x27;job&#x27;</span>: <span class="string">&#x27;Engineer&#x27;</span>&#125;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; person(<span class="string">&#x27;Jack&#x27;</span>, 24, **extra)</span></span><br><span class="line">name: Jack age: 24 other: &#123;&#x27;city&#x27;: &#x27;Beijing&#x27;, &#x27;job&#x27;: &#x27;Engineer&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p><code>**extra</code> 表示将<code>extra</code>这个dict的所有key-value用关键字参数传入到函数的<code>**kw</code>, <code>kw</code>将获得一个dict，是<code>extra</code>的一份拷贝，对<code>kw</code>的改动将不影响<code>extra</code>里面的数据。</p>
<p><strong>命名关键字参数</strong></p>
<p>对于关键字参数，函数调用者可以传入任意不受限制的关键字参数，如果要检查传入了哪些，就需要在函数内部通过 <code>kw</code> 进行检查，但是调用者依然可以传入任意参数。</p>
<p>如果要限制关键字参数的参数名，可以使用命名关键字参数。比如只接收<code>city</code>和<code>job</code>作为关键字参数，方式如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">def person(name, age, *, city, job):</span><br><span class="line">    print(name, age, city, job)</span><br></pre></td></tr></table></figure>
<p>命名关键字参数需要一个特殊的分隔符 <code>*</code>, <code>*</code> 后面的参数被视为命名关键字参数。</p>
<p>调用方式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; person(<span class="string">&#x27;Jack&#x27;</span>, 24, city=<span class="string">&#x27;Beijing&#x27;</span>, job=<span class="string">&#x27;Engineer&#x27;</span>)</span></span><br><span class="line">Jack 24 Beijing Engineer</span><br></pre></td></tr></table></figure>
<p>两个参数必须都要传入， 否则就会报错</p>
<blockquote>
<p>TypeError: person1() missing 1 required keyword-only argument: ‘job’</p>
</blockquote>
<p>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符<code>*</code>了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">def person(name, age, *args, city, job):</span><br><span class="line">    print(name, age, args, city, job)</span><br></pre></td></tr></table></figure>
<p>命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; person(<span class="string">&#x27;Jack&#x27;</span>, 24, <span class="string">&#x27;Beijing&#x27;</span>, <span class="string">&#x27;Engineer&#x27;</span>)</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: person() missing 2 required keyword-only arguments: &#x27;city&#x27; and &#x27;job&#x27;</span><br></pre></td></tr></table></figure>

<p>由于调用时缺少参数名<code>city</code>和<code>job</code>，Python解释器把前两个参数视为位置参数，后两个参数传给<code>*args</code>，但缺少命名关键字参数导致报错。</p>
<p>命名关键字参数也可以有缺省值，从而简化调用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">def person(name, age, *, city=&#x27;Beijing&#x27;, job):</span><br><span class="line">    print(name, age, city, job)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; person(<span class="string">&#x27;Jack&#x27;</span>, 24, job=<span class="string">&#x27;Engineer&#x27;</span>)</span></span><br><span class="line">Jack 24 Beijing Engineer</span><br></pre></td></tr></table></figure>

<p>使用命名关键字参数时，如果没有可变参数，就必须加上分隔符<code>*</code> ， 如果缺少<code>*</code>，会被当做位置参数处理。</p>
<p><strong>参数组合</strong></p>
<p>可以使用上面几种参数类型进行组合，但是顺序要保证是： 必选参数，默认参数，可变参数，关键字参数和命名关键字参数。</p>
<p>通过一个<code>tuple</code> 和 <code>dict</code> 可以调用任意函数。<code>func(*args, **kw)</code></p>
<p><strong>总结</strong></p>
<ol>
<li>默认参数一定要用不可变参数， 否则会有逻辑错误</li>
<li><code>*args</code> 是可变参数， 接收的是一个tuple</li>
<li><code>**kw</code> 是关键字参数， 接收的是一个dict</li>
<li><code>*args</code> 和 <code>**kw</code> 是python的习惯写法， 最好使用习惯写法</li>
<li>注意调用可变参数和关键字参数时候的传值方式。</li>
</ol>
<h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>使用递归函数要防止栈溢出。 函数调用是通过栈<code>stack</code> 这种数据结构实现的。</p>
<p>解决递归调用栈溢出的方式是使用<code>尾递归</code> 优化，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>3.python高级特性</title>
    <url>/hexoblog/python/3.python%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p>主要介绍切片，迭代，列表生成式，生成器，迭代器等高级特性。</p>
<span id="more"></span>

<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>取一个list或tuple的部分元素，对于指定索引范围的操作，python提供了切片(Slice)操作符。</p>
<p>比如一个list如下</p>
<blockquote>
<p>L&#x3D;[1,2,3,4,5,6,7,8,9]</p>
</blockquote>
<p>可以如下操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; L[0:4]</span></span><br><span class="line">[1, 2, 3, 4]</span><br></pre></td></tr></table></figure>
<p><code>L[0:4]</code> 表示 从索引<code>0</code> 开始，直到索引<code>4</code> 为止，不包含结尾的索引<code>4</code> ， 所以取的是索引位置  <code>0</code> <code>1</code> <code>2</code> <code>3</code> 对应的元素。</p>
<p>如果第一个索引位置是0 ， 也可以省略</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; L[:2]</span></span><br><span class="line">[1, 2]</span><br></pre></td></tr></table></figure>
<p>python支持按照倒序通过索引获取元素，同样也支持按照倒序进行切片。 倒序的第一个索引是 <code>-1</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; L[-2:]</span></span><br><span class="line">[8, 9]</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; L[-4:-2]</span></span><br><span class="line">[6, 7]</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; L[0:-2]</span></span><br><span class="line">[1, 2, 3, 4, 5, 6, 7]</span><br></pre></td></tr></table></figure>

<p>也可以对空集合进行切片, 对空集合直接只用索引访问会报错，但是切片不会。 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; L=[]</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; L[0]</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">IndexError: list index out of range</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; L[0:]</span></span><br><span class="line">[]</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; L[0:1]</span></span><br><span class="line">[]</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; L[:1]</span></span><br><span class="line">[]</span><br></pre></td></tr></table></figure>

<p>使用场景</p>
<p>比如创建一个0-99的数列。</p>
<blockquote>
<p>L&#x3D;list(range(100))</p>
</blockquote>
<p>取前10个</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; L[:10]</span></span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure>

<p>后10个</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; L[-10:]</span></span><br><span class="line">[90, 91, 92, 93, 94, 95, 96, 97, 98, 99]</span><br></pre></td></tr></table></figure>
<p>前10个数，每两个取一个：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; L[:10:2]</span></span><br><span class="line">[0, 2, 4, 6, 8]</span><br></pre></td></tr></table></figure>
<p>所有数，每5个取一个：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; L[::5]</span></span><br><span class="line">[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]</span><br></pre></td></tr></table></figure>

<p>只写 <code>[:]</code> 原样复制一个list</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; L[:]</span></span><br><span class="line">[0, 1, 2, 3, ..., 99]</span><br></pre></td></tr></table></figure>
<p>tuple 也可以做上述操作，只是tuple切片的结果依然是tuple。</p>
<p>字符串 <code>xxxxx</code> 也可以看成是一种list，每个元素就是一个字符,  也可以进行切片。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="string">&#x27;abcdefg&#x27;</span>[0:1]</span></span><br><span class="line">&#x27;a&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="string">&#x27;abcdefg&#x27;</span>[2:]</span></span><br><span class="line">&#x27;cdefg&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="string">&#x27;abcdefg&#x27;</span>[::]</span></span><br><span class="line">&#x27;abcdefg&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="string">&#x27;abcdefg&#x27;</span>[::3]</span></span><br><span class="line">&#x27;adg&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>通过for循环来遍历集合，称为迭代。</p>
<p>在python中， 迭代是通过 <code>for ... in</code>  来完成的。和 java的迭代类似。</p>
<p>dict的迭代</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">迭代 key</span></span><br><span class="line">d = &#123;&quot;k1&quot;:&quot;v1&quot;, &quot;k2&quot; : &quot;v2&quot;, &quot;k3&quot;:&quot;v3&quot;&#125;</span><br><span class="line">for k in d:</span><br><span class="line">    print(k)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">迭代value</span></span><br><span class="line">for v in d.values():</span><br><span class="line">    print(v)</span><br><span class="line">    </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同时迭代 key和value</span></span><br><span class="line">for k, v in d.items():</span><br><span class="line">    print(k, v)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>dict 默认迭代的是 <code>key</code>， 迭代出的顺序可能不一样。</p>
<p>字符串也可以进行迭代，输出每一个字符。  </p>
<p>只要一个对象是可迭代的， <code>for</code> 循环就可以运行。</p>
<p>通过 <code>collections.abc</code> 模块的 <code>Iterable</code> 判断对象是否是可迭代的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from collections.abc import Iterable</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; isinstance(<span class="string">&#x27;abc&#x27;</span>, Iterable) <span class="comment"># str是否可迭代</span></span></span><br><span class="line">True</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; isinstance([1,2,3], Iterable) <span class="comment"># list是否可迭代</span></span></span><br><span class="line">True</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; isinstance(123, Iterable) <span class="comment"># 整数是否可迭代</span></span></span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p>对list使用下标循环， 可以使用 <code>enumerate</code> 将list转换为 索引-元素对</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">L=[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span><br><span class="line">for i, v in enumerate(L):</span><br><span class="line">    print(i, v) </span><br></pre></td></tr></table></figure>

<h2 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h2><p>要生成list <code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code> 可以用<code>list(range(1, 11))</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; list(range(1, 11))</span></span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br></pre></td></tr></table></figure>
<p>生成 <code>[1x1, 2x2, 3x3, ..., 10x10]</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; [x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(1, 11)]</span></span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span><br></pre></td></tr></table></figure>
<p>把要生成的元素<code>x*x</code> 放在前面， 后面跟上 <code>for</code> 循环。 </p>
<p>for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; [x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(1, 11) <span class="keyword">if</span> x % 2 == 0]</span></span><br><span class="line">[4, 16, 36, 64, 100]</span><br></pre></td></tr></table></figure>

<p><strong>if else</strong></p>
<p>列表生成式， for 后面的<code>if</code> 是筛选条件， 所以不能加上 <code>else</code>， 否则无法筛选。</p>
<p><code>for</code> 前面的<code>if</code> 是表达式， 必须加上else </p>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>列表生成式，直接把元素都创建出来了，会占用内存，数量也会受到内存的限制。</p>
<p>所以，如果元素按照某种算法推算出来，在循环中不断推算出后面的元素，就不必创建完整的list， 这种一边循环一边计算的机制，称为生成器 generator</p>
<p>创建 generator 有很多种方法，可以把生成式的 <code>[]</code> 改成 <code>()</code> ，就创建了一个 generator</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(10))</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; g</span></span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x000001A96593F780&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="keyword">for</span> i <span class="keyword">in</span> g:</span></span><br><span class="line">...   print(i)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>可以调用 <code>next(g)</code> 方法获取下一个元素， 也可以使用for 循环进行迭代。</p>
<p>要把普通函数改造成 generator函数，需要加上 <code>yield</code> 关键字。</p>
<p>generator函数在每次调用<code>next()</code>的时候执行，遇到<code>yield</code>语句返回，再次执行时从上次返回的<code>yield</code>语句处继续执行。</p>
<p><strong>调用generator函数会创建一个generator对象，多次调用generator函数会创建多个相互独立的generator。</strong></p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>可以直接作用于<code>for</code> 循环的对象，统称为可迭代对象<code>Iterable</code></p>
<p>可以被<code>next()</code>函数调用并不断返回下一个值的对象称为迭代器：<code>Iterator</code>. 可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterator</code>对象</p>
<p>把<code>list</code> <code>dict</code>  <code>str</code> 等 <code>Iterable</code>变成 <code>Iterator</code> 可以使用 <code>iter()</code> 函数。 和java 的<code>iterator()</code>方法类似。</p>
<p><code>Iterator</code>对象表示的是一个数据流， Iterator对象可以不断被<code>next()</code>函数调用并返回下一个数据，计算是惰性的，只有在需要返回下一个对象时才进行计算。</p>
<p><code>for</code>循环本质上就是通过不断调用<code>next()</code>函数实现的</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>4.python函数式编程</title>
    <url>/hexoblog/python/4.python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>我们通过把大段的代码拆分成函数，通过一层层的函数调用，来把复杂的任务分解成简单的任务，这种分解可以称为面向过程的程序设计。</p>
<p>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。</p>
<span id="more"></span>

<h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><p>变量名可以指向函数，函数名其实就是指向函数的一个变量。</p>
<p>既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。</p>
<h2 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map&#x2F;reduce"></a>map&#x2F;reduce</h2><blockquote>
<p>MapReduce 的原理在于将大规模的数据处理任务划分为多个并行的 Map 和 Reduce 操作，充分利用了集群中的计算资源，实现了高效的分布式计算。通过将数据处理过程分解为 Map 和 Reduce 两个阶段，并在其中引入数据的分组和排序操作，MapReduce 能够有效地处理大规模数据集，并具备容错性和可扩展性。</p>
</blockquote>
<p><code>map()</code>函数接收两个参数，一个是函数，一个是<code>Iterable</code>，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。</p>
<p>比如将一个整数集合转换为字符串</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; L=[1,2,3,4,5,6,7,8,9]</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; r = map(str, L)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; list(r)</span></span><br><span class="line">[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;]</span><br></pre></td></tr></table></figure>

<p><code>map()</code> 作为高阶函数，把运算规则抽象化了。</p>
<p><code>reduce</code> 把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上, 这个函数必须接收两个参数，<code>reduce</code>把<strong>结果</strong>继续和序列的下一个元素做累积计算，其效果就是</p>
<blockquote>
<p>reduce(f, [x1, x2, x3, x4]) &#x3D; f(f(f(x1, x2), x3), x4)</p>
</blockquote>
<h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p><code>filter()</code> 函数用于过滤序列。</p>
<p><code>filter()</code>也接收一个函数和一个序列。<code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。</p>
<p>filter的关键在于正确实现一个筛选函数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; list(filter(lambda x : x%2==0 , range(10)))</span></span><br><span class="line">[0, 2, 4, 6, 8]</span><br></pre></td></tr></table></figure>

<h2 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h2><p>内置的<code>sorted()</code>函数可以对list进行排序。默认按照升序排列。</p>
<p><code>sorted()</code>函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序, key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。</p>
<p><code>sorted()</code>对字符串排序，是按照ASCII的大小比较的, 可以使用<code>ord()</code>函数将字母转为数字来查看大小。由于<code>&#39;Z&#39; &lt; &#39;a&#39;</code>，结果，大写字母Z会排在小写字母a的前面。</p>
<p>反向排序，可以传入第三个参数 <code>reverse=True</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; sorted([<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;about&#x27;</span>, <span class="string">&#x27;Zoo&#x27;</span>, <span class="string">&#x27;Credit&#x27;</span>], key=str.lower, reverse=True)</span></span><br><span class="line">[&#x27;Zoo&#x27;, &#x27;Credit&#x27;, &#x27;bob&#x27;, &#x27;about&#x27;]</span><br></pre></td></tr></table></figure>

<h1 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h1><p>高阶函数可以把函数作为结果返回，不是直接返回的值，调用函数时，返回的是函数，只有当再次调用返回函数时，才会进行计算。例如 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">def lazy_sum(*args):</span><br><span class="line">    def sum():</span><br><span class="line">        ax = 0</span><br><span class="line">        for n in args:</span><br><span class="line">            ax = ax + n</span><br><span class="line">        return ax</span><br><span class="line">    return sum</span><br></pre></td></tr></table></figure>

<p>在函数 <code>lazy_sum</code>中又定义了函数<code>sum</code>，内部函数可以引用外部函数的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为 “闭包(Closure)”</p>
<p>每次调用 <code>lazy_sum()</code>时，返回的是一个新的函数，两次调用的结果不相等。</p>
<p><strong>闭包</strong></p>
<blockquote>
<p> 返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</p>
</blockquote>
<p><strong>nonlocal</strong></p>
<p>使用闭包时，内层函数引用了外层函数的局部变量，读取时没问题，如果修改，会报错</p>
<blockquote>
<p>UnboundLocalError: cannot access local variable ‘x’ where it is not associated with a value</p>
</blockquote>
<p>例如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">def inc():</span><br><span class="line">    x = 0</span><br><span class="line">    def fn():</span><br><span class="line">        # nonlocal x</span><br><span class="line">        x = x + 1</span><br><span class="line">        return x</span><br><span class="line">    return fn</span><br><span class="line"></span><br><span class="line">f = inc()</span><br><span class="line">print(f()) # 1</span><br><span class="line">print(f()) # 2</span><br></pre></td></tr></table></figure>
<p>原因是 <code>x</code> 作为局部变量没有初始化，需要在fn函数内部加上一个 <code>nonlocal x</code> 的声明，加上后，解释器会把<code>fn()</code>内部的 <code>x</code> 看做外层函数的局部变量。</p>
<blockquote>
<p> 使用闭包时，对外层变量赋值前，需要先使用nonlocal声明该变量不是当前函数的局部变量。</p>
</blockquote>
<h1 id="匿名函数lambda"><a href="#匿名函数lambda" class="headerlink" title="匿名函数lambda"></a>匿名函数lambda</h1><p>我们在传入函数时，有时候不需要显示的定义函数，直接传入匿名函数更方便。例如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))</span><br></pre></td></tr></table></figure>
<p>匿名函数 <code>lambda x: x * x</code> 实际上就是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">def f(x):</span><br><span class="line">    return x * x</span><br></pre></td></tr></table></figure>
<p>关键字 <code>lambda</code> 表示匿名函数，冒号前面的 <code>x</code> 表示参数。匿名函数只能有一个表达式，不用return， 返回值就是表达式的结果。</p>
<p>匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; f = lambda x : x + x</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; f</span></span><br><span class="line">&lt;function &lt;lambda&gt; at 0x000001A9659FA160&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; f(5)</span></span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>也可以把匿名函数作为返回值返回</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">def build(x, y):</span><br><span class="line">    return lambda: x * x + y * y</span><br></pre></td></tr></table></figure>
<h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><p>由于函数是一个对象，函数可以赋值给一个变量，通过变量也能调用该函数。函数对象有一个 <code>__name__</code> 属性，可以拿到函数名。</p>
<p>假设要增加函数的功能，不修改函数的定义，这种在代码运行期间动态增加功能的方式，称为 “装饰器”(Decorator)。 类似java的 <code>AOP</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">def log(func):</span><br><span class="line">    # @functools.wraps(func)</span><br><span class="line">    def wrapper(*args, **kw):</span><br><span class="line">        print(&#x27;call function %s&#x27; % func.__name__)</span><br><span class="line">        return func(*args, **kw)</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line">@log</span><br><span class="line">def now():</span><br><span class="line">    print(&#x27;2023-11-01&#x27;)</span><br><span class="line"></span><br><span class="line">now()</span><br></pre></td></tr></table></figure>

<p>把<code>@log</code> 放到 <code>now()</code>函数的定义处，相当于执行了</p>
<blockquote>
<p>now &#x3D; log(now)</p>
</blockquote>
<p>原来的<code>now</code>函数依然存在，只是现在的 <code>now</code> 指向了新的函数。就是 <code>log</code> 中返回的 <code>wrapper</code> 函数。</p>
<p>如果decorator本身需要传入参数，就需要再包一层函数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">def log(text):</span><br><span class="line">    def decorator(func):</span><br><span class="line">        # @functools.wraps(func)</span><br><span class="line">        def wrapper(*args, **kw):</span><br><span class="line">            print(&#x27;%s %s()&#x27; % (text, func.__name__))</span><br><span class="line">            return func(*args, **kw)</span><br><span class="line">        </span><br><span class="line">        return wrapper</span><br><span class="line">    return decorator</span><br><span class="line"></span><br><span class="line">@log(&#x27;执行了&#x27;)</span><br><span class="line">def now():</span><br><span class="line">    print(&#x27;2023-11-01&#x27;)</span><br><span class="line"></span><br><span class="line">now()</span><br></pre></td></tr></table></figure>

<p>上面的2种写法，会导致调用函数时，返回的<code>__name__</code> 发生变化，因为实际上函数名已经指向新的函数了。所以需要把原始函数的<code>__name__</code>等属性赋值给新函数， 否则有些依赖函数签名的代码会执行错误。</p>
<p>使用内置的 <code>functools.wraps</code> 来进行处理。 如上面代码块中注释掉的部分。</p>
<h1 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h1><p><code>functools</code> 模块提供了很多功能， 其中一个就是偏函数(Partial function)</p>
<p>函数通过设定参数的默认值，可以降低调用难度，偏函数也可以做到，比如 <code>int()</code>类型转换</p>
<p><strong>偏函数就是将某些参数固定住，简化调用</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; int(<span class="string">&#x27;1111&#x27;</span>)</span></span><br><span class="line">1111</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; int(<span class="string">&#x27;1111&#x27;</span>, base=2)</span></span><br><span class="line">15</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; int(<span class="string">&#x27;1111&#x27;</span>, base=16)</span></span><br><span class="line">4369</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; int(<span class="string">&#x27;1111&#x27;</span>, base=8)</span></span><br><span class="line">585</span><br></pre></td></tr></table></figure>

<p>假设我们需要做大量的二进制转换，每次传入 <code>base=2</code>会很麻烦， 可以定义一个 int2() 函数， 默认把<code>base=2</code> 传入进去。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">def int2(x, base=2):</span><br><span class="line">    return int(x, base)</span><br></pre></td></tr></table></figure>

<p><code>functools.partial</code>就是帮助我们创建一个偏函数，不需要自己定义 <code>int2()</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import functools</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; int8=functools.partial(int, base=8)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; int8(<span class="string">&#x27;1111&#x27;</span>)</span></span><br><span class="line">585</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; int8(<span class="string">&#x27;111100&#x27;</span>)</span></span><br><span class="line">37440</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; int8(<span class="string">&#x27;11001&#x27;</span>)</span></span><br><span class="line">4609</span><br></pre></td></tr></table></figure>

<p>所以<code>functools.partial</code>的作用就是， 把一个函数的某些参数固定住(设置默认值)， 返回一个新函数，调用新函数会更简单。</p>
<p>新函数仅仅是把参数设置了默认值，但是调用的时候依然可以传入其他的值.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; int8(<span class="string">&#x27;1111&#x27;</span>,  base=10)</span></span><br><span class="line">1111</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建偏函数时，实际上可以接收函数对象、<code>*args</code>和<code>**kw</code>这3个参数<br>当传入</p>
<blockquote>
<p>max2 &#x3D; functools.partial(max, 10)</p>
</blockquote>
<p>实际上会把<code>10</code>作为<code>*args</code>的一部分自动加到左边</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">max2(5, 6, 7)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">相当于:</span></span><br><span class="line">args = (10, 5, 6, 7)</span><br><span class="line">max(*args)</span><br></pre></td></tr></table></figure>
<p>实际的结果是 <code>10</code></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>6.python面向对象编程</title>
    <url>/hexoblog/python/6.python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。</p>
<span id="more"></span>

<h1 id="OOP概念"><a href="#OOP概念" class="headerlink" title="OOP概念"></a>OOP概念</h1><p>OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。</p>
<p>面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。</p>
<p>OOP设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。</p>
<p>下面举例说明面向过程和面向对象的在程序流程上的不同。</p>
<p>假设我们要处理学生的成绩表，为了表示一个学生的成绩，面向过程的程序可以用一个dict表示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">std1 = &#123; &#x27;name&#x27;: &#x27;Michael&#x27;, &#x27;score&#x27;: 98 &#125;</span><br><span class="line">std2 = &#123; &#x27;name&#x27;: &#x27;Bob&#x27;, &#x27;score&#x27;: 81 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>而处理学生成绩可以通过函数实现，比如打印学生的成绩：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">def print_score(std):</span><br><span class="line">    print(&#x27;%s: %s&#x27; % (std[&#x27;name&#x27;], std[&#x27;score&#x27;]))</span><br></pre></td></tr></table></figure>
<p>如果采用OOP的设计思想，首先思考的不是程序的执行流程，而是 <code>Student</code> 这种数据类型应该被视为一个对象。这个对象拥有<code>name</code>和<code>score</code>这两个属性（Property）。如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个<code>print_score</code>消息，让对象自己把自己的数据打印出来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_score</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s: %s&#x27;</span> % (self.name, self.score))</span><br></pre></td></tr></table></figure>
<p>给对象发消息实际上就是调用对象对应的关联函数，我们称之为对象的方法（Method）。面向对象的程序写出来就像这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bart = Student(<span class="string">&#x27;Bart Simpson&#x27;</span>, <span class="number">59</span>)</span><br><span class="line">lisa = Student(<span class="string">&#x27;Lisa Simpson&#x27;</span>, <span class="number">87</span>)</span><br><span class="line">bart.print_score()</span><br><span class="line">lisa.print_score()</span><br></pre></td></tr></table></figure>

<p>类（Class）和实例（Instance）, Class是一种抽象概念，比如我们定义的Class——Student，是指学生这个概念，而实例（Instance）则是一个个具体的Student，比如，Bart Simpson和Lisa Simpson是两个具体的Student。</p>
<p>所以，面向对象的设计思想是抽象出Class，根据Class创建Instance。</p>
<p>面向对象的抽象程度又比函数要高，因为一个Class既包含数据，又包含操作数据的方法。</p>
<p>封装，继承，多态，三大特点，和java一样。</p>
<h1 id="类和实例"><a href="#类和实例" class="headerlink" title="类和实例"></a>类和实例</h1><p>面向对象最重要的概念就是类（Class）和实例（Instance），类是抽象的模板。</p>
<p>在Python中，定义类是通过<code>class</code>关键字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p><code>class</code>后面紧接着是类名，即<code>Student</code>，类名通常是大写开头的单词，紧接着是<code>(object)</code>，表示该类是从哪个类继承下来的，通常，如果没有合适的继承类，就使用<code>object</code>类，这是所有类最终都会继承的类。</p>
<p>定义好了类，就可以通过类创建出实例。创建实例是通过类名+()实现的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Student</span></span><br><span class="line">&lt;class &#x27;__main__.Student&#x27;&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s = Student()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s</span></span><br><span class="line">&lt;__main__.Student object at 0x000001A965ADA690&gt;</span><br></pre></td></tr></table></figure>

<p>实例创建后可以自由地给实例变量绑定属性。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s.name = <span class="string">&#x27;张三&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s.name</span></span><br><span class="line">&#x27;张三&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p>由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的<code>__init__</code>方法，在创建实例的时候，就把<code>name</code>，<code>score</code>等属性绑上去：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br></pre></td></tr></table></figure>

<blockquote>
<p>特殊方法“__init__”前后分别有两个下划线！！！</p>
</blockquote>
<p><code>__init__</code>方法的第一个参数永远是<code>self</code>，表示创建的实例本身，因此，在<code>__init__</code>方法内部，就可以把各种属性绑定到<code>self</code>，因为<code>self</code>就指向创建的实例本身。</p>
<p>有了<code>__init__</code>方法，在创建实例的时候，必须传入与<code>__init__</code>方法匹配的参数，但<code>self</code>不需要传，Python解释器自己会把实例变量传进去：</p>
<p>和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量<code>self</code>，并且，调用时，不用传递该参数。</p>
<p><strong>数据封装</strong></p>
<p>封装通过将数据和对数据的操作（方法）捆绑在一起，形成一个独立的、可复用的单位，对外部隐藏内部实现细节，只暴露出简单的接口供其他代码使用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; class Student(object):</span></span><br><span class="line">...   def hello(self):</span><br><span class="line">...     print(&#x27;hello&#x27;)</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s1 = Student()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s1.hello</span></span><br><span class="line">&lt;bound method Student.hello of &lt;__main__.Student object at 0x0000015DEB716B10&gt;&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s1.hello()</span></span><br><span class="line">hello</span><br></pre></td></tr></table></figure>
<p>通过实例变量访问方法时，如果不加括号，输出的是方法的信息，要调用方法必须要加上<code>()</code></p>
<h1 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h1><p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。</p>
<p>这样就确保外部无法随意修改对象内部的状态。</p>
<p>如果想要访问或者修改对象内部的数据，可以给类增加 get 和 set 方法， 和java类似。可以在方法中对参数做校验。</p>
<p>变量名类似<code>__xxx__</code>的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用<code>__name__</code>、<code>__score__</code>这样的变量名。</p>
<p>以一个下划线开头的实例变量名，比如<code>_name</code>，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，这样的变量不能随意访问。</p>
<p>Python解释器对外把<code>__name</code>变量改成了<code>_Student__name</code>，所以，仍然可以通过<code>_Student__name</code>来访问<code>__name</code>变量，但是强烈不建议这么做。</p>
<h1 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h1><p><strong>继承</strong></p>
<p>当我们定义一个class时，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）</p>
<p>继承有什么好处？最大的好处是子类获得了父类的全部功能。继承可以实现代码的重用和扩展。</p>
<p><strong>多态</strong></p>
<p>子类重写父类方法。</p>
<p>子类的实例的数据类型也可以看做是父类的数据类型，反过来不行。</p>
<p>多态的好处，当函数需要接收子类时，只需要定义时接收父类就行。调用函数时，可以传入不同的子类的实例。</p>
<blockquote>
<p>java中叫 父类引用指向子类对象？</p>
</blockquote>
<p><strong>静态语言 vs 动态语言</strong></p>
<p>对于静态语言（例如Java）来说，如果需要传入<code>Animal</code>类型，则传入的对象必须是<code>Animal</code>类型或者它的子类，否则，将无法调用<code>run()</code>方法。</p>
<p>对于Python这样的动态语言来说，则不一定需要传入<code>Animal</code>类型。我们只需要保证传入的对象有一个<code>run()</code>方法就可以了：</p>
<p>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</p>
<p>Python的“file-like object“就是一种鸭子类型。</p>
<h1 id="获取对象信息"><a href="#获取对象信息" class="headerlink" title="获取对象信息"></a>获取对象信息</h1><p><strong>type()</strong></p>
<p>使用 <code>type()</code> 方法， 可以判断某个对象是什么类型。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">type</span>(11)</span></span><br><span class="line">&lt;class &#x27;int&#x27;&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; L=[1,2,3,4]</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">type</span>(L)</span></span><br><span class="line">&lt;class &#x27;list&#x27;&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">type</span>(<span class="string">&#x27;aa&#x27;</span>)</span></span><br><span class="line">&lt;class &#x27;str&#x27;&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; def func():</span></span><br><span class="line">...   pass</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">type</span>(func())</span></span><br><span class="line">&lt;class &#x27;NoneType&#x27;&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">type</span>(func)</span></span><br><span class="line">&lt;class &#x27;function&#x27;&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">type</span>(abs)</span></span><br><span class="line">&lt;class &#x27;builtin_function_or_method&#x27;&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>type()</code> 返回的是对象的Class类型。可以进行 <code>==</code> 比较，判断是否是相同的类。</p>
<p><strong>使用isinstance()</strong></p>
<p>如果有继承关系，使用<code>type()</code> 就不方便判断了， 可以使用 <code>isinstance()</code></p>
<p><code>isinstance()</code>判断的是一个对象是否是该类型本身，或者位于该类型的父继承链上。</p>
<p>能用<code>type()</code>判断的基本类型也可以用<code>isinstance()</code>判断。并且还可以判断一个变量是否是某些类型中的一种。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; isinstance([1,2,3], (list, tuple))</span></span><br><span class="line">True</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; isinstance([1,2,3], (dict, tuple))</span></span><br><span class="line">False</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; isinstance((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>), (set, tuple))</span></span><br><span class="line">True</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p>所以可以优先使用 <code>isinstance()</code>来判断类型。</p>
<p><strong>使用dir()</strong></p>
<p>使用<code>dir()</code> 方法可以获取一个对象的所有属性和方法，返回的是一个包含字符串的list。</p>
<p>仅仅把属性和方法列出来是不够的，配合<code>getattr()</code>、<code>setattr()</code>以及<code>hasattr()</code>，我们可以直接操作一个对象的状态</p>
<p>如果试图获取不存在的属性，会抛出AttributeError的错误， 可以在方法中加上默认值。 例如：<code>getattr(obj, &#39;z&#39;, 404)</code></p>
<p>也可以使用 <code>hasattr()</code>，<code>getattr()</code> 判断和获取对象的方法。</p>
<h1 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h1><p>给实例绑定属性的方法是通过实例变量，或者通过self变量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">s = Student(<span class="string">&#x27;Bob&#x27;</span>)</span><br><span class="line">s.score = <span class="number">90</span></span><br></pre></td></tr></table></figure>

<p>但是，如果<code>Student</code>类本身需要绑定一个属性呢？可以直接在class中定义属性，这种属性是类属性，归<code>Student</code>类所有</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    name = <span class="string">&#x27;Student&#x27;</span></span><br></pre></td></tr></table></figure>

<p>类属性，类的所有实例都可以访问到。和java中继承很相似。</p>
<p>在编写程序的时候，千万不要对实例属性和类属性使用相同的名字，避免出现错误。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>5.python模块</title>
    <url>/hexoblog/python/5.python%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>为了编写可维护的代码，我们把很多函数分组，放到不同的文件中，这样每个文件包含的代码就相对较少，在python中，一个.py文件就称为一个模块(module)。</p>
<span id="more"></span>

<h1 id="模块的概念"><a href="#模块的概念" class="headerlink" title="模块的概念"></a>模块的概念</h1><p>模块可以提升代码的可维护性，可以复用代码，避免函数名和变量名冲突等。</p>
<p>为了避免模块名冲突，又引入了包（Package），按照目录来组织模块。比如将模块放到同一个包<code>mycompany</code> 下面，这样 <code>abc.py</code> 的模块名就变成了 <code>mycompany.abc</code>。</p>
<p>每一个包目录下面都会有一个<code>__init__.py</code>的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包，<code>__init__.py</code>可以是空文件，也可以有Python代码。</p>
<p>也可以有多级目录，组成多级层次的包结构。</p>
<p><strong>模块名不要和系统模块名冲突，否则会导致系统模块引入失败。</strong></p>
<h1 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h1><p>如示例： <code>hello.py</code> 文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27; a test module &#x27;</span></span><br><span class="line"></span><br><span class="line">__author__ = <span class="string">&quot;张三&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    args = sys.argv</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">len</span>(args)==<span class="number">2</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;hello %s&#x27;</span> % args[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;参数过多&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第1行和第2行是标准注释，第一行可以让该文件在linux下直接运行，第二行注释说明了使用的编码。</p>
<p>第4行是一个字符串，是模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释</p>
<p>第6行使用<code>__author__</code>变量把作者写进去</p>
<p>上面就是python模块的标准文件模板。后面开始就是真正的代码部分。</p>
<p>导入<code>sys</code>模块后，我们就有了变量<code>sys</code>指向该模块，利用<code>sys</code>这个变量，就可以访问<code>sys</code>模块的所有功能。</p>
<p>最后的两行特殊的代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if __name__==&#x27;__main__&#x27;:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure>
<p>在命令行运行<code>hello</code>模块文件时，Python解释器把一个特殊变量<code>__name__</code>置为<code>__main__</code>，而如果在其他地方导入该<code>hello</code>模块时，<code>if</code>判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>一个模块中，可能有很多的变量和函数，有些函数和变量希望给别人使用，有的函数和变量希望仅仅在模块内部使用，在python中，是通过前缀<code>_</code> 实现的。</p>
<p>正常的函数和变量名是公开的(public)， 可以被直接引用，如<code>abc</code>，<code>hello</code>等。</p>
<p>类似<code>__xx__</code>这样的变量是特殊变量，可以被直接引用，但是有特殊的用途。模块的文档注释也可以用<code>__doc__</code>变量来访问。我们自己的变量一般不要用这样的变量名。</p>
<p>类似<code>_xxx</code>和<code>__xxx</code> 这样的变量或者函数就是非公开的(private)，不应该被直接引用。</p>
<p>之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。</p>
<blockquote>
<p>外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。</p>
</blockquote>
<h1 id="安装第三方模块"><a href="#安装第三方模块" class="headerlink" title="安装第三方模块"></a>安装第三方模块</h1><p>可以通过命令来安装第三方模块。</p>
<blockquote>
<p>pip install xxx</p>
</blockquote>
<p><strong>模块搜索路径</strong></p>
<p>默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在<code>sys</code>模块的<code>path</code>变量中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import sys</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; sys.path</span></span><br><span class="line">[&#x27;&#x27;, &#x27;C:\\Python312\\python312.zip&#x27;, &#x27;C:\\Python312\\DLLs&#x27;, &#x27;C:\\Python312\\Lib&#x27;, &#x27;C:\\Python312&#x27;, &#x27;C:\\Python312\\Lib\\site-packages&#x27;]</span><br></pre></td></tr></table></figure>

<p>如果我们要添加自己的搜索路径，可以设置环境变量 <code>PYTHONPATH</code>， 该环境变量的内容会被自动添加到模块搜索路径中。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>7.python面向对象高级编程</title>
    <url>/hexoblog/python/7.python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>封装、继承和多态只是面向对象程序设计中最基础的3个概念。在Python中，面向对象还有很多高级特性，下面会讨论多重继承、定制类、元类等概念。</p>
<span id="more"></span>

<h1 id="使用-slots"><a href="#使用-slots" class="headerlink" title="使用 slots"></a>使用 <strong>slots</strong></h1><p>正常情况下，可以给一个类的实例创建任何属性和方法，这就是动态语言的灵活性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>绑定属性</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s = Student()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s.name = <span class="string">&#x27;Michael&#x27;</span> <span class="comment"># 动态给实例绑定一个属性</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(s.name)</span></span><br><span class="line">Michael</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也可以绑定一个方法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; def set_age(self, age): <span class="comment"># 定义一个函数作为实例方法</span></span></span><br><span class="line">...     self.age = age</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from types import MethodType</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s.set_age = MethodType(set_age, s) <span class="comment"># 给实例绑定一个方法</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s.set_age(25) <span class="comment"># 调用实例方法</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s.age <span class="comment"># 测试结果</span></span></span><br><span class="line">25</span><br></pre></td></tr></table></figure>
<p>给实例绑定的方法，对另一个实例无效，所以可以绑定到类上。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; def set_score(self, score):</span></span><br><span class="line">...     self.score = score</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Student.set_score = set_score</span></span><br></pre></td></tr></table></figure>
<p>通常情况下，上面的<code>set_score</code>方法可以直接定义在class中，但动态绑定允许我们在程序运行的过程中动态给class加上功能，这在静态语言中很难实现。</p>
<p><strong>使用__slots__</strong></p>
<p>如果我们想要限制实例的属性怎么办？比如，只允许对<code>Student</code>实例添加<code>name</code>和<code>age</code>属性。</p>
<p>为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的<code>__slots__</code>变量，来限制该class实例能添加的属性：</p>
<p><code>__slots__</code>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的。子类实例允许定义的属性就是自身的<code>__slots__</code>加上父类的<code>__slots__</code>。</p>
<p>验证如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    __slots__ = (<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p1 = Person()</span><br><span class="line">p1.name = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(p1.name)</span><br><span class="line"><span class="comment"># 添加score属性会报错</span></span><br><span class="line"><span class="comment">#p1.score = 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    __slots__ = (<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;score&#x27;</span>)</span><br><span class="line"></span><br><span class="line">s1 = Student()</span><br><span class="line"></span><br><span class="line">s1.name = <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">s1.age = <span class="string">&#x27;14&#x27;</span></span><br><span class="line">s1.score = <span class="number">98</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s1.name, s1.age, s1.score)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="使用-property"><a href="#使用-property" class="headerlink" title="使用@property"></a>使用@property</h1><p>如果给属性加上访问限制，使用get set方法，也可以在赋值时检查数据的合理性。这样操作略显复杂。</p>
<p>Python内置的<code>@property</code>装饰器就是负责把一个方法变成属性调用的</p>
<p>把一个getter方法变成属性，只需要加上<code>@property</code>就可以了。我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过getter和setter方法来实现的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">birth</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._birth</span><br><span class="line"></span><br><span class="line"><span class="meta">    @birth.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">birth</span>(<span class="params">self, value</span>):</span><br><span class="line">        self._birth = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">age</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2015</span> - self._birth</span><br></pre></td></tr></table></figure>
<p>只定义getter方法，不定义setter方法就是一个只读属性，上面的<code>birth</code>是可读写属性，而<code>age</code>就是一个只读属性，因为<code>age</code>可以根据<code>birth</code>和当前时间计算出来。</p>
<p>要特别注意：属性的方法名不要和实例变量重名，下面的就是错误的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 方法名称和实例变量均为birth:</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">birth</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.birth</span><br></pre></td></tr></table></figure>

<p>这是因为调用<code>s.birth</code>时，首先转换为方法调用，在执行<code>return self.birth</code>时，又视为访问<code>self</code>的属性，于是又转换为方法调用，造成无限递归，最终导致栈溢出报错<code>RecursionError</code></p>
<h1 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h1><p>如果是单继承的话，层级结构如下。</p>
<pre class="mermaid">graph TD
动物 --> 会飞的
动物 --> 会跑的
会飞的 --> 鹦鹉
会飞的 --> 老鹰
会跑的 --> 狗
会跑的 --> 猫</pre>
<p>如果需要再添加新的继承关系，就会很复杂了， 所以可以采用多重继承的方式。 比如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(Mammal, Runnable):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>通过多重继承，一个子类就可以同时获得多个父类的所有功能。</p>
<p><strong>MixIn</strong></p>
<p>在设计类的继承关系时，通常，主线都是单一继承下来的，例如，<code>Ostrich</code>继承自<code>Bird</code>。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让<code>Ostrich</code>除了继承自<code>Bird</code>外，再同时继承<code>Runnable</code>。这种设计通常称之为<code>MixIn</code>。</p>
<p>MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。</p>
<p>由于Python允许使用多重继承，因此，MixIn就是一种常见的设计。</p>
<p>java中只允许单继承，但是可以通过 implements 多个接口来实现类似的功能。</p>
<h1 id="定制类"><a href="#定制类" class="headerlink" title="定制类"></a>定制类</h1><p>看到类似<code>__slots__</code>这种形如<code>__xxx__</code>的变量或者函数名就要注意，这些在Python中是有特殊用途的。</p>
<p><code>__slots__</code> 用于限制实例的属性</p>
<p><code>__len__()</code> 让类作用于<code>len()</code>函数</p>
<p>Python的class中还有许多这样有特殊用途的函数，可以帮助我们定制类。</p>
<p><code>__str__</code></p>
<p>类似java的 <code>toString()</code>方法， 自定义对象的输出信息。可以将实例内部的信息输出。</p>
<p><code>__str__()</code>返回用户看到的字符串，而<code>__repr__()</code>返回程序开发者看到的字符串(对象的内存地址信息等),比如<code>&lt;__main__.Student object at 0x000001A342D19F70&gt;</code>，也就是说 <code>__repr__()</code>是为调试服务的。</p>
<p><code>__iter__</code></p>
<p>如果一个类想被用于<code>for ... in</code>循环，类似<code>list</code>或<code>tuple</code>那样，就必须实现一个<code>__iter__()</code>方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的<code>__next__()</code>方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fib</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.a, self.b = <span class="number">0</span>, <span class="number">1</span> <span class="comment"># 初始化两个计数器a，b</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self <span class="comment"># 实例本身就是迭代对象，故返回自己</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        self.a, self.b = self.b, self.a + self.b <span class="comment"># 计算下一个值</span></span><br><span class="line">        <span class="keyword">if</span> self.a &gt; <span class="number">100000</span>: <span class="comment"># 退出循环的条件</span></span><br><span class="line">            <span class="keyword">raise</span> StopIteration()</span><br><span class="line">        <span class="keyword">return</span> self.a <span class="comment"># 返回下一个值</span></span><br></pre></td></tr></table></figure>

<p><code>__getitem__</code></p>
<p>如果需要像list那样按照下标取元素，就需要实现<code>__getitem__()</code>方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fib</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, n</span>):</span><br><span class="line">        a, b = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            a, b = b, a + b</span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>

<p>如果把对象看成<code>dict</code>，<code>__getitem__()</code>的参数也可能是一个可以作key的object，例如<code>str</code></p>
<p>与之相对应的是 <code>__setitem__()</code>，把对象当做list或者dict来进行赋值，<code>__delitem__()</code> 用于删除某个元素。</p>
<p><code>__getattr__</code></p>
<p>正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。Python提供了一个机制，那就是写一个<code>__getattr__()</code>方法，动态返回一个属性或者函数。</p>
<p>这就可以把一个类的所有属性和方法调用全部动态化处理了，不需要任何特殊手段。</p>
<p>这种特性可以用来针对完全动态的情况作调用。比如 url中的动态路径。</p>
<p><code>__call__</code></p>
<p>我们用<code>instance.method()</code>来调用对象的方法，也可以在实例本身上调用，需要定义一个<code>__call__()</code>方法即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;My name is %s.&#x27;</span> % self.name)</span><br></pre></td></tr></table></figure>

<p><code>__call__()</code>还可以定义参数。对实例进行直接调用就好比对一个函数进行调用一样。</p>
<p>如果你把对象看成函数，那么函数本身其实也可以在运行期动态创建出来，因为类的实例都是运行期创建出来的，这么一来，我们就模糊了对象和函数的界限。</p>
<p>判断一个对象是否能被调用，能被调用的对象就是一个<code>Callable</code>对象，通过<code>callable()</code> 函数判断对象是否是”可调用”的对象</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; callable(str)</span></span><br><span class="line">True</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; callable(int)</span></span><br><span class="line">True</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; callable(None)</span></span><br><span class="line">False</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; callable((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span></span><br><span class="line">False</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h1><p>当我们定义常量时，简单的方法是用大写变量通过常数来定义，但是缺点是类型是<code>int</code>， 并且依然是变量。</p>
<p>更好的方法是使用<code>Enum</code>来定义一个枚举类。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line">Month = Enum(<span class="string">&#x27;Month&#x27;</span>, (<span class="string">&#x27;Jan&#x27;</span>, <span class="string">&#x27;Feb&#x27;</span>, <span class="string">&#x27;Mar&#x27;</span>, <span class="string">&#x27;Apr&#x27;</span>, <span class="string">&#x27;May&#x27;</span>, <span class="string">&#x27;Jun&#x27;</span>, <span class="string">&#x27;Jul&#x27;</span>, <span class="string">&#x27;Aug&#x27;</span>, <span class="string">&#x27;Sep&#x27;</span>, <span class="string">&#x27;Oct&#x27;</span>, <span class="string">&#x27;Nov&#x27;</span>, <span class="string">&#x27;Dec&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>我们可以使用<code>Month.Jan</code>来引用一个常量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> name, member <span class="keyword">in</span> Month.__members__.items():</span><br><span class="line">    <span class="built_in">print</span>(name, <span class="string">&#x27;=&gt;&#x27;</span>, member, <span class="string">&#x27;,&#x27;</span>, member.value)</span><br></pre></td></tr></table></figure>

<p><code>value</code>属性则是自动赋给成员的<code>int</code>常量，默认从<code>1</code>开始计数。</p>
<p>如果需要更精确地控制枚举类型，可以从<code>Enum</code>派生出自定义类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum, unique</span><br><span class="line"></span><br><span class="line"><span class="meta">@unique</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Weekday</span>(<span class="title class_ inherited__">Enum</span>):</span><br><span class="line">    Sun = <span class="number">0</span> <span class="comment"># Sun的value被设定为0</span></span><br><span class="line">    Mon = <span class="number">1</span></span><br><span class="line">    Tue = <span class="number">2</span></span><br><span class="line">    Wed = <span class="number">3</span></span><br><span class="line">    Thu = <span class="number">4</span></span><br><span class="line">    Fri = <span class="number">5</span></span><br><span class="line">    Sat = <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>访问方式有下面几种</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(Weekday.Sun)</span></span><br><span class="line">Weekday.Sun</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(Weekday[<span class="string">&#x27;Sun&#x27;</span>])</span></span><br><span class="line">Weekday.Sun</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(Weekday(1))</span></span><br><span class="line">Weekday.Mon</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(Weekday(1).value)</span></span><br><span class="line">1</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; day1 = Weekday.Sun</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(day1 == Weekday(1))</span></span><br><span class="line">False</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(day1 == Weekday(0))</span></span><br><span class="line">True</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(day1 == Weekday[<span class="string">&#x27;Sun&#x27;</span>])</span></span><br><span class="line">True</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(day1 == Weekday.Sun)</span></span><br><span class="line">True</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h1><blockquote>
<p>元类就是深度的魔法，99% 的用户应该根本不必为此操心。如果你想搞清楚究竟是否需要用到元类，那么你就不需要它。那些实际用到元类的人都非常清楚地知道他们需要做什么，而且根本不需要解释为什么要用元类。</p>
</blockquote>
<p><strong>type()</strong></p>
<p>动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的。</p>
<p>比方说我们要定义一个<code>Hello</code>的class，就写一个<code>hello.py</code>模块：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">class Hello(object):</span><br><span class="line">    def hello(self, name=&#x27;world&#x27;):</span><br><span class="line">        print(&#x27;Hello, %s.&#x27; % name)</span><br></pre></td></tr></table></figure>

<p>当Python解释器载入<code>hello</code>模块时，就会依次执行该模块的所有语句，执行结果就是动态创建出一个<code>Hello</code>的class对象，测试如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from hello import Hello</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; h = Hello()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; h.hello()</span></span><br><span class="line">Hello, world.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(<span class="built_in">type</span>(Hello))</span></span><br><span class="line">&lt;class &#x27;type&#x27;&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(<span class="built_in">type</span>(h))</span></span><br><span class="line">&lt;class &#x27;hello.Hello&#x27;&gt;</span><br></pre></td></tr></table></figure>

<p><code>type()</code>函数可以查看一个类型或变量的类型，<code>Hello</code>是一个class，它的类型就是<code>type</code>，而<code>h</code>是一个实例，它的类型就是class <code>Hello</code>。</p>
<p>我们说class的定义是运行时动态创建的，而创建class的方法就是使用<code>type()</code>函数。</p>
<p><strong>metaclass</strong></p>
<p>除了使用type()动态创建类以外，要控制类的创建行为，还可以使用metaclass。</p>
]]></content>
  </entry>
  <entry>
    <title>8.python错误和调试</title>
    <url>/hexoblog/python/8.python%E9%94%99%E8%AF%AF%E5%92%8C%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<p>在程序运行过程中，总会遇到各种各样的错误。有代码逻辑错误，有运行时错误，有用户输入错误等。</p>
<p>此外，还可以通过使用<code>pdb</code>进行调试。</p>
<span id="more"></span>


<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><h2 id="try"><a href="#try" class="headerlink" title="try"></a>try</h2><p>python提供了 <code>try...except...finally...</code> 来处理异常。</p>
<p>不同的错误类型，可以由不同的<code>except</code>来处理。 <code>finally</code> 可以没有。</p>
<p>如果没有错误发生，可以在except语句块后面加一个<code>else</code>，当没有错误发生时，会自动执行<code>else</code>语句</p>
<p>错误其实也是class，所有的错误类型都继承自<code>BaseException</code>，所以在使用<code>except</code>时需要注意的是，捕获父类之后，下面捕获子类的代码就不会执行到了。 和java类似。</p>
<p>python常见的错误类型和继承关系 <a href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy">exception-hierarchy</a></p>
<p>示例如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">error_test</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;try...&#x27;</span>)</span><br><span class="line">        result = <span class="number">10</span> / <span class="built_in">int</span>(num)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;结果是 %s&#x27;</span> % result)</span><br><span class="line">    <span class="keyword">except</span> ValueError <span class="keyword">as</span> ve:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;ValueError: &#x27;</span>, ve )</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> zde:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;ZeroDivisionError: &#x27;</span>, zde)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;无异常&#x27;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;finally...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">error_test(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">error_test(<span class="number">2</span>)</span><br><span class="line">error_test(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">error_test(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><p>如下面错误的堆栈信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;err.py&quot;, line 11, in &lt;module&gt;</span><br><span class="line">    main()</span><br><span class="line">  File &quot;err.py&quot;, line 9, in main</span><br><span class="line">    bar(&#x27;0&#x27;)</span><br><span class="line">  File &quot;err.py&quot;, line 6, in bar</span><br><span class="line">    return foo(s) * 2</span><br><span class="line">  File &quot;err.py&quot;, line 3, in foo</span><br><span class="line">    return 10 / int(s)</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Traceback (most recent call last):</p>
</blockquote>
<p>第一行，告诉我们这是错误的跟踪信息。 后面可以逐行分析， 最终找到错误的根源。</p>
<blockquote>
<p>出错的时候，一定要分析错误的调用栈信息，才能定位错误的位置。</p>
</blockquote>
<h2 id="记录错误"><a href="#记录错误" class="headerlink" title="记录错误"></a>记录错误</h2><p><code>logging</code> 模块可以记录错误信息。</p>
<p>捕获错误，然后记录错误堆栈信息，让程序继续往下运行。</p>
<h2 id="抛出错误"><a href="#抛出错误" class="headerlink" title="抛出错误"></a>抛出错误</h2><p>因为错误是class，捕获一个错误就是捕获到该class的一个实例。因此，错误并不是凭空产生的，而是有意创建并抛出的。Python的内置函数会抛出很多类型的错误，我们自己编写的函数也可以抛出错误。</p>
<p>只有在必要的时候才定义我们自己的错误类型。如果可以选择Python已有的内置的错误类型（比如<code>ValueError</code>，<code>TypeError</code>），尽量使用Python内置的错误类型。</p>
<p>我们还可以捕获异常，记录之后将异常重新抛出，也可以转换为其他异常(要符合逻辑，不能随意转换)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;ValueError!&#x27;</span>)</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="number">10</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&#x27;input error!&#x27;</span>)</span><br></pre></td></tr></table></figure>


<p>程序也可以主动抛出错误，让调用者来处理相应的错误。但是，应该在文档中写清楚可能会抛出哪些错误，以及错误产生的原因。</p>
<h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><h2 id="print"><a href="#print" class="headerlink" title="print"></a>print</h2><p>使用<code>print()</code>将相关变量的值打印出来，但是将来还需要删除它。</p>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>凡是用<code>print()</code>来辅助查看的地方，都可以用断言<code>（assert）</code>来替代：</p>
<blockquote>
<p>assert n !&#x3D; 0, ‘n is zero!’</p>
</blockquote>
<p><code>assert</code>的意思是，表达式<code>n != 0</code>应该是<code>True</code>，否则，根据程序运行的逻辑，后面的代码肯定会出错。</p>
<p>如果断言失败，<code>assert</code>语句本身就会抛出<code>AssertionError</code></p>
<p>启动Python解释器时可以用<code>-O</code>(大写的英文O)参数来关闭<code>assert</code>， 关闭后 <code>assert</code> 可以当做 <code>pass</code></p>
<h2 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h2><p>把<code>print()</code>替换为<code>logging</code>是第3种方式，和<code>assert</code>比，<code>logging</code>不会抛出错误，而且可以输出到文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(level=logging.INFO)</span><br></pre></td></tr></table></figure>

<p><code>logging</code> 可以控制日志的级别， 有<code>debug</code>，<code>info</code>，<code>warning</code>，<code>error</code>, 也可以通过配置，将日志输出到不同的地方。</p>
<h2 id="pdb"><a href="#pdb" class="headerlink" title="pdb"></a>pdb</h2><p>第4种方式是启动Python的调试器pdb，让程序以单步方式运行，可以随时查看运行状态。</p>
<p>以参数<code>-m pdb</code> 启动后，pdb定位到下一步要执行的代码，可以输入命令 <code>l</code>(小写的L) 来查看代码。输入命令<code>n</code>可以单步的执行代码。</p>
<p>可以输入<code>p 变量名</code>来查看变量。输入命令<code>q</code> 来结束调试。</p>
<h2 id="pdb-set-trace"><a href="#pdb-set-trace" class="headerlink" title="pdb.set_trace()"></a>pdb.set_trace()</h2><p><code>pdb</code> 单步执行太麻烦，我们只需要import pdb，然后，在可能出错的地方放一个pdb.set_trace()，就可以设置一个断点：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># err.py</span></span><br><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line"></span><br><span class="line">s = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">n = <span class="built_in">int</span>(s)</span><br><span class="line">pdb.set_trace() <span class="comment"># 运行到这里会自动暂停</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span> / n)</span><br></pre></td></tr></table></figure>
<p>运行代码，程序会自动在<code>pdb.set_trace()</code>暂停并进入<code>pdb</code>调试环境，可以用命令<code>p</code>查看变量，或者用命令<code>c</code>继续运行</p>
<h2 id="IDE调试"><a href="#IDE调试" class="headerlink" title="IDE调试"></a>IDE调试</h2><p>VS Code 插件。</p>
<p>虽然用IDE调试起来比较方便，但是最后你会发现，logging才是终极武器。</p>
<h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p>单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。</p>
<p>单元测试通过后，如果对代码做了修改，可以重新跑一遍单元测试，看是否通过，来判断修改是否对原来的逻辑造成了影响。</p>
<p>编写单元测试时，我们需要编写一个测试类，从<code>unittest.TestCase</code>继承</p>
<p>以<code>test</code>开头的方法就是测试方法，不以<code>test</code>开头的方法不被认为是测试方法，测试的时候不会被执行。</p>
<p>对每一类测试都需要编写一个<code>test_xxx()</code>方法。由于<code>unittest.TestCase</code>提供了很多内置的条件判断，最常用的断言就是<code>assertEqual()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.assertEqual(<span class="built_in">abs</span>(-<span class="number">1</span>), <span class="number">1</span>) <span class="comment"># 断言函数返回的结果与1相等</span></span><br></pre></td></tr></table></figure>

<p>另一种重要的断言就是期待抛出指定类型的Error</p>
<p><strong>运行单元测试</strong></p>
<p>最简单的运行方式是在<code>mydict_test.py</code>的最后加上两行代码，这样就可以把文件当做正常脚本运行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure>

<p>另一种方法是在命令行通过参数<code>-m unittest</code>直接运行单元测试。</p>
<p>这是推荐的做法，因为这样可以一次批量运行很多单元测试，并且，有很多工具可以自动来运行这些单元测试</p>
<p><strong>setUp与tearDown</strong></p>
<p>可以在单元测试中编写两个特殊的<code>setUp()</code>和<code>tearDown()</code>方法。这两个方法会分别在每调用一个测试方法的前后分别被执行。</p>
<p><code>setUp()</code>和<code>tearDown()</code>方法有什么用呢？设想你的测试需要启动一个数据库，这时，就可以在<code>setUp()</code>方法中连接数据库，在<code>tearDown()</code>方法中关闭数据库，这样，不必在每个测试方法中重复相同的代码</p>
<p>类似 java单元测试中的 <code>@Before</code> 和 <code>@After</code></p>
<h1 id="文档测试"><a href="#文档测试" class="headerlink" title="文档测试"></a>文档测试</h1><p>Python官方文档中的示例代码，比如 <a href="https://docs.python.org/3/library/re.html">re模块</a> 就带了很多示例代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import re</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; m = re.search(<span class="string">&#x27;(?&lt;=abc)def&#x27;</span>, <span class="string">&#x27;abcdef&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; m.group(0)</span></span><br><span class="line">&#x27;def&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以把这些示例代码在Python的交互式环境下输入并执行，结果与文档中的示例代码显示的一致。</p>
<p>这些代码与其他说明可以写在注释中，然后，由一些工具来自动生成文档。</p>
<p>既然这些代码本身就可以粘贴出来直接运行，也可以自动执行写在注释中的这些代码。</p>
<p>当我们编写注释时，如果写上这样的注释</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">abs</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Function to get absolute value of number.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Example:</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; abs(1)</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; abs(-1)</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; abs(0)</span></span><br><span class="line"><span class="string">    0</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> n <span class="keyword">if</span> n &gt;= <span class="number">0</span> <span class="keyword">else</span> (-n)</span><br></pre></td></tr></table></figure>

<p>可以明确地告诉函数的调用者该函数的期望输入和输出</p>
<p>并且，Python内置的“文档测试”（<code>doctest</code>）模块可以直接提取注释中的代码并执行测试。</p>
<p>doctest严格按照Python交互式命令行的输入和输出来判断测试结果是否正确。只有测试异常的时候，可以用…表示中间一大段烦人的输出。</p>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fact</span>(<span class="params">n</span>):</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Calculate 1*2*...*n</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; fact(1)</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; fact(10)</span></span><br><span class="line"><span class="string">    3628800</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; fact(-1)</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string">    ValueError</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError()</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n * fact(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">numList = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">20</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> numList:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s的阶乘结果是%s&#x27;</span> % (i  ,fact(i) ))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> doctest</span><br><span class="line">    doctest.testmod()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>doctest不仅可以用来测试，还可以直接作为示例代码，通过某些文档生成工具，可以自动把包含doctest的注释提取出来。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>9.python的IO编程</title>
    <url>/hexoblog/python/9.python%E7%9A%84IO%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>IO在计算机中指Input&#x2F;Output，也就是输入和输出。如磁盘IO，网络IO等。Stream（流）是一个很重要的概念，输入流和输出流。</p>
<p>由于CPU和内存的速度远远高于外设的速度，所以，在IO编程中，就存在速度严重不匹配的问题。可以分为同步和异步处理。</p>
<p>异步IO又包含了回调模模式和轮询模式等，在网络IO编程中比较常用。</p>
<span id="more"></span>

<h1 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h1><p>读写文件是最常见的IO操作。Python内置了读写文件的函数，用法和C是兼容的。</p>
<p>操作系统不允许普通程序直接操作磁盘，读写文件就是请求操作系统打开一个文件对象(通常称为文件描述符)，然后通过操作系统的接口进行读写操作。</p>
<h2 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h2><p>读文件，用Python内置的<code>open()</code>函数，传入文件名和标示符</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; f=open(<span class="string">&#x27;D:/imgUrl.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; f=open(<span class="string">&#x27;D:/imgUrl.txtaa&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:/imgUrl.txtaa&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p>标示符<code>&#39;r&#39;</code>表示读，如果文件不存在，<code>open()</code>函数就会抛出一个<code>IOError</code>的错误，并且给出错误码和详细的信息告诉你文件不存在</p>
<p>调用<code>read()</code>方法可以一次把文件内容读取到内存中，用一个<code>str</code>对象表示。</p>
<p>最后一定要调用<code>close()</code>关闭文件，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的。和java一样。</p>
<p>文件读取出错后，后面的close就不会执行了。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用<code>try ... finally</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&#x27;/path/to/file&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(f.read())</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">if</span> f:</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure>

<p>但是每次都这样写太麻烦， Python引入了<code>with</code>语句来自动帮我们调用<code>close()</code>方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/path/to/file&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(f.read())</span><br></pre></td></tr></table></figure>

<p>这和<code>try ... finally</code>是一样的，但是代码更简洁。</p>
<p>调用<code>read()</code>会一次将文件内容读取到内存中，如果文件过大，内存就爆了，可以使用分治的方法，每次读取一部分内容。反复调用<code>read(size)</code>方法，每次最多读取<code>size</code>个字节的内容</p>
<p>另外，调用<code>readline()</code>可以每次读取一行内容，调用<code>readlines()</code>一次读取所有内容并按行返回<code>list</code>。因此，要根据需要决定怎么调用。</p>
<p>如果文件很小，<code>read()</code>一次性读取最方便；如果不能确定文件大小，反复调用<code>read(size)</code>比较保险；如果是配置文件，调用<code>readlines()</code>最方便：</p>
<p>可以使用 <code>line.strip()</code> 把末尾的<code>\n</code> 换行符去掉</p>
<p>例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读文件遍历 </span></span><br><span class="line"><span class="keyword">with</span>(<span class="built_in">open</span>(<span class="string">&#x27;D:/imgUrl.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 直接迭代文件对象</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        <span class="comment">#print(len(line))</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一次全部读入内存</span></span><br><span class="line"><span class="keyword">with</span>(<span class="built_in">open</span>(<span class="string">&#x27;D:/imgUrl.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)) <span class="keyword">as</span> f:</span><br><span class="line">    l = f.readlines()</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(l))</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> l:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        <span class="comment">#print(s.strip())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按行读取</span></span><br><span class="line"><span class="keyword">with</span>(<span class="built_in">open</span>(<span class="string">&#x27;D:/imgUrl.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)) <span class="keyword">as</span> f:</span><br><span class="line">    line = f.readline()</span><br><span class="line">    <span class="keyword">while</span> line:</span><br><span class="line">        <span class="comment">#print(line.strip())</span></span><br><span class="line">        line = f.readline()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按size读取</span></span><br><span class="line"><span class="keyword">with</span>(<span class="built_in">open</span>(<span class="string">&#x27;D:/imgUrl.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)) <span class="keyword">as</span> f:</span><br><span class="line">    size = <span class="number">50</span></span><br><span class="line">    data = f.read(size)</span><br><span class="line">    <span class="keyword">while</span> data:</span><br><span class="line">        <span class="built_in">print</span>(data)</span><br><span class="line">        data = f.read(size)</span><br></pre></td></tr></table></figure>

<h2 id="file-like-Object"><a href="#file-like-Object" class="headerlink" title="file-like Object"></a>file-like Object</h2><p>像<code>open()</code>函数返回的这种有个<code>read()</code>方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个read()方法就行。</p>
<p><code>StringIO</code> 就是在内存中创建的file-like Object，常用作临时缓冲。</p>
<h2 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h2><p>上面的默认都是读取的<code>utf-8</code>编码的文本文件，如果是二进制文件，比如图片等，需要用<code>&#39;rb&#39;</code> 模式打开文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; f = open(<span class="string">&#x27;D:/123.png&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; f.readline()</span></span><br><span class="line">b&#x27;\x89PNG\r\n&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><p>要读取非UTF-8编码的文本文件，需要给<code>open()</code>函数传入<code>encoding</code>参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; f=open(<span class="string">&#x27;D:/gb2312-test.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;gb2312&#x27;</span>, errors=<span class="string">&#x27;ignore&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; f.readline()</span></span><br><span class="line">&#x27;中文编码测试\n&#x27;</span><br></pre></td></tr></table></figure>

<p>如果有一些非法的编码，可能会报错<code>UnicodeDecodeError</code>，可以指定<code>errors</code>参数忽略错误</p>
<h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><p>写文件和读文件是一样的，唯一区别是调用<code>open()</code>函数时，传入标识符<code>&#39;w&#39;</code>或者<code>&#39;wb&#39;</code>表示写文本文件或写二进制文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;D:/write-test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">f.write(<span class="string">&#x27;哈哈哈哈\n&#x27;</span>)</span><br><span class="line">f.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以反复调用<code>write()</code>来写文件，但是一定要调用<code>f.close()</code>方法来关闭文件，否则可能发会导致要写入的数据只写了一部分。只有调用<code>close()</code>方法时，操作系统才保证把没有写入的数据全部写入磁盘。</p>
<p>所以还是使用<code>with</code>最保险</p>
<p>要写入特定编码的文本文件，可以给<code>open()</code>函数传入<code>encoding</code>参数</p>
<p>以 <code>&#39;w&#39;</code>模式写文件时，每次写入会覆盖，可以将<code>&#39;w&#39;</code> 改为 <code>&#39;a&#39;</code> 来使用追加模式写入。</p>
<h1 id="StringIO和BytesIO"><a href="#StringIO和BytesIO" class="headerlink" title="StringIO和BytesIO"></a>StringIO和BytesIO</h1><h2 id="StringIO"><a href="#StringIO" class="headerlink" title="StringIO"></a>StringIO</h2><p>很多时候，数据读写不一定是文件，也可以在内存中读写。</p>
<p>StringIO就是在内存中读写str。要把str写入StringIO，我们需要先创建一个StringIO，然后，像文件一样写入即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from io import StringIO</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; f = StringIO()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; f.write(<span class="string">&#x27;大&#x27;</span>)</span></span><br><span class="line">1</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; f.write(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line">1</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; f.write(<span class="string">&#x27;家好&#x27;</span>)</span></span><br><span class="line">2</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; f.getvalue()</span></span><br><span class="line">&#x27;大\n家好&#x27;</span><br></pre></td></tr></table></figure>

<p><code>getvalue()</code>方法用于获得写入后的str。</p>
<p>要读取StringIO，可以用一个str初始化StringIO，然后，像读文件一样读取</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = StringIO(<span class="string">&#x27;大\n家\n好&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    s = f.readline()</span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(s.strip())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="BytesIO"><a href="#BytesIO" class="headerlink" title="BytesIO"></a>BytesIO</h2><p>StringIO操作的只能是str，如果要操作二进制数据，就需要使用BytesIO。</p>
<p>BytesIO实现了在内存中读写bytes，我们创建一个BytesIO，然后写入一些bytes：</p>
<p>写入的不是str，而是经过UTF-8编码的bytes</p>
<p>和StringIO类似，可以用一个bytes初始化BytesIO，然后，像读文件一样读取</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = BytesIO()</span><br><span class="line">f.write(<span class="string">&#x27;中文&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(f.getvalue())</span><br><span class="line"><span class="built_in">print</span>(f.getvalue().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用bytes初始化</span></span><br><span class="line">f = BytesIO(<span class="string">&#x27;中文&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(f.read())</span><br></pre></td></tr></table></figure>

<h1 id="操作文件和目录"><a href="#操作文件和目录" class="headerlink" title="操作文件和目录"></a>操作文件和目录</h1><p>内置的<code>os</code>模块可以直接调用操作系统提供的接口操作文件和目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import os</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; os.name</span></span><br><span class="line">&#x27;posix&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; os.uname()</span></span><br><span class="line">(&#x27;Linux&#x27;, &#x27;dev&#x27;, &#x27;3.10.0-1160.90.1.el7.x86_64&#x27;, &#x27;#1 SMP Thu May 4 15:21:22 UTC 2023&#x27;, &#x27;x86_64&#x27;)</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span> </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; os.name</span></span><br><span class="line">&#x27;nt&#x27;</span><br></pre></td></tr></table></figure>

<p>如果是<code>posix</code>，说明系统是<code>Linux</code>、<code>Unix</code>或<code>Mac OS X</code>，如果是<code>nt</code>，就是<code>Windows</code>系统。</p>
<p>要获取详细的系统信息，可以调用<code>uname()</code>函数, windows系统不支持该函数。<code>os</code>模块的某些函数是跟操作系统相关的</p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p><code>os.environ</code> 可以查看全部的环境变量。要获取某个环境变量的值，可以调用<code>os.environ.get(&#39;key&#39;)</code>：</p>
<h2 id="操作文件和目录-1"><a href="#操作文件和目录-1" class="headerlink" title="操作文件和目录"></a>操作文件和目录</h2><p>操作文件和目录的函数一部分放在os模块中，一部分放在os.path模块中。</p>
<p>把两个路径合成一个时，不要直接拼字符串，而要通过<code>os.path.join()</code>函数，这样可以正确处理不同操作系统的路径分隔符。</p>
<p>拆分路径的时候，要使用<code>os.path.split()</code>，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名。</p>
<p><code>os.path.splitext()</code>可以直接得到文件的扩展名。</p>
<p>这些合并、拆分路径的函数并不要求目录和文件要真实存在，它们只对字符串进行操作。</p>
<p><code>os.rename()</code> 对文件重命名。<code>os.remove</code> 删除文件。</p>
<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p>程序运行的过程中，所有的变量都是在内存中。在程序运行结束后，变量就会被操作系统回收。</p>
<p>把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思</p>
<p>序列化之后，就可以把序列化的内容写入到磁盘，或者通过网络传输。</p>
<p>把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。</p>
<h2 id="pickle"><a href="#pickle" class="headerlink" title="pickle"></a>pickle</h2><p>Python提供了<code>pickle</code>模块来实现序列化。</p>
<p><code>pickle.dumps()</code>方法把任意对象序列化成一个<code>bytes</code>，然后，就可以把这个<code>bytes</code>写入文件。</p>
<p>或者用另一个方法<code>pickle.dump()</code>直接把对象序列化后写入一个file-like Object：</p>
<p>当我们要把对象从磁盘读到内存时，可以先把内容读到一个<code>bytes</code>，然后用<code>pickle.loads()</code>方法反序列化出对象，也可以直接用<code>pickle.load()</code>方法从一个file-like Object中直接反序列化出对象。</p>
<p>通过这种方式反序列化的变量内容相同，但是实际上不是同一个变量了。</p>
<p>Pickle的序列化只能用于python，可能python的不同版本也不兼容，也不能跨语言。所以不能保存重要的数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(pickle.dumps(l))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 序列化到文件中</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;D:/tmpdump.txt&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">pickle.dump(l, f)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反序列化 先读取成bytes</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;D:/tmpdump.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">b = f.read()</span><br><span class="line">data = pickle.loads(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(data))</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="comment">#直接从文件反序列化</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;D:/tmpdump.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">d = pickle.load(f)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">b&#x27;\x80\x04\x95\x17\x00\x00\x00\x00\......省略....&#x27;</span><br><span class="line">&lt;class &#x27;list&#x27;&gt;</span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure>

<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON。</p>
<p>JSON和Python内置的数据类型对应如下</p>
<table>
<thead>
<tr>
<th align="left">JSON类型</th>
<th align="left">Python类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">{}</td>
<td align="left">dict</td>
</tr>
<tr>
<td align="left">[]</td>
<td align="left">list</td>
</tr>
<tr>
<td align="left">“string”</td>
<td align="left">str</td>
</tr>
<tr>
<td align="left">12.3</td>
<td align="left">int或float</td>
</tr>
<tr>
<td align="left">true&#x2F;false</td>
<td align="left">True&#x2F;False</td>
</tr>
<tr>
<td align="left">null</td>
<td align="left">None</td>
</tr>
</tbody></table>
<p>Python内置的json模块提供了非常完善的Python对象到JSON格式的转换。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; d = dict(name=<span class="string">&#x27;张三&#x27;</span>, age=20, height=130.5, interest=[<span class="string">&#x27;篮球&#x27;</span>, <span class="string">&#x27;唱歌&#x27;</span>])</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; d</span></span><br><span class="line">&#123;&#x27;name&#x27;: &#x27;张三&#x27;, &#x27;age&#x27;: 20, &#x27;height&#x27;: 130.5, &#x27;interest&#x27;: [&#x27;篮球&#x27;, &#x27;唱歌&#x27;]&#125;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; json.dumps(d)</span></span><br><span class="line">&#x27;&#123;&quot;name&quot;: &quot;\\u5f20\\u4e09&quot;, &quot;age&quot;: 20, &quot;height&quot;: 130.5, &quot;interest&quot;: [&quot;\\u7bee\\u7403&quot;, &quot;\\u5531\\u6b4c&quot;]&#125;&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; json.dumps(d,ensure_ascii=False)</span></span><br><span class="line">&#x27;&#123;&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 20, &quot;height&quot;: 130.5, &quot;interest&quot;: [&quot;篮球&quot;, &quot;唱歌&quot;]&#125;&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s=json.dumps(d)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; json.loads(s)</span></span><br><span class="line">&#123;&#x27;name&#x27;: &#x27;张三&#x27;, &#x27;age&#x27;: 20, &#x27;height&#x27;: 130.5, &#x27;interest&#x27;: [&#x27;篮球&#x27;, &#x27;唱歌&#x27;]&#125;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>dumps()</code>方法返回一个<code>str</code>，内容是标准的json，类似的 <code>dump()</code>方法可以直接把json写入到<code>file-like Object</code></p>
<p>使用<code>loads()</code>方法把json字符串反序列化，或者使用<code>load()</code>方法从<code>file-like Object</code>中读取字符串并反序列化。</p>
<h2 id="JSON进阶"><a href="#JSON进阶" class="headerlink" title="JSON进阶"></a>JSON进阶</h2><p><code>dict</code>对象可以直接序列化为JSON的<code>&#123;&#125;</code>，不过，很多时候，我们更喜欢用class表示对象，比如定义Student类，然后序列化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, score</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line">s = Student(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">20</span>, <span class="number">88</span>)</span><br><span class="line"><span class="built_in">print</span>(json.dumps(s))</span><br></pre></td></tr></table></figure>

<p>运行时，会报<code>TypeError</code>，是因为<code>Student</code>对象不是一个可序列化为JSON的对象。</p>
<p><code>dumps()</code>函数有很多可选参数，可以用来定制json序列化。</p>
<p>可选参数<code>default</code>就是把任意一个对象变成一个可序列为JSON的对象，我们只需要为<code>Student</code>专门写一个转换函数，再把函数传进去即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">student2dict</span>(<span class="params">std</span>):</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>: std.name,</span><br><span class="line">        <span class="string">&#x27;age&#x27;</span>: std.age,</span><br><span class="line">        <span class="string">&#x27;score&#x27;</span>: std.score</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(json.dumps(s, default=student2dict))</span><br></pre></td></tr></table></figure>

<p>不过，如果遇到其他类的实例，依然无法序列化，可以默认把任意<code>class</code>的实例变为<code>dict</code></p>
<blockquote>
<p>print(json.dumps(s, default&#x3D;lambda obj: obj.<strong>dict</strong>))</p>
</blockquote>
<p>因为通常<code>class</code>的实例都有一个<code>__dict__</code>属性，它就是一个<code>dict</code>，用来存储实例变量。也有少数例外，比如定义了<code>__slots__</code>的class。</p>
<p>如果我们要把JSON反序列化为一个<code>Student</code>对象实例，<code>loads()</code>方法首先转换出一个<code>dict</code>对象，然后，我们传入的<code>object_hook</code>函数负责把<code>dict</code>转换为<code>Student</code>实例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s = <span class="string">&#x27;&#123;&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 20, &quot;height&quot;: 130.5, &quot;interest&quot;: [&quot;篮球&quot;, &quot;唱歌&quot;]&#125;&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; stu = json.loads(s, object_hook=dict2student)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(stu)</span></span><br><span class="line">&lt;__main__.Student object at 0x000002615C4962A0&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(json.dumps(stu, default=lambda obj: obj.__dict__, ensure_ascii=False))</span></span><br><span class="line">&#123;&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 20, &quot;score&quot;: 130.5&#125;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>ensure_ascii</code>用于指定在对JSON进行编码时是否对非ASCII字符进行转义，确保生成的JSON字符串中只包含ASCII字符。</p>
<p><code>ensure_ascii</code>参数默认值为True，表示会对非ASCII字符进行转义，将其表示为<code>\uXXXX</code>的形式。 如果将<code>ensure_ascii</code>参数设置为<code>False</code>，则表示不对非ASCII字符进行转义。非ASCII字符将以原样包含在生成的JSON字符串中。</p>
<p>通常情况下，需要保持默认值，这样可以确保生成的JSON字符串是有效的ASCII字符串，可以在不同的系统之间进行传输和解析。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Sublime使用</title>
    <url>/hexoblog/tools/SublimeText%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="配置，安装插件"><a href="#配置，安装插件" class="headerlink" title="配置，安装插件"></a>配置，安装插件</h2><ol>
<li>常用的package，以及配置，参考<a href="https://github.com/cpf929/Users.git">Users目录的配置文件</a></li>
</ol>
<span id="more"></span>

<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ol>
<li>可以直接打开图片</li>
<li>Goto Anything功能 — 快速查找（ctrl + P）</li>
</ol>
<ul>
<li>输入@+函数名可以快速找到函数。</li>
<li>输入#+文本可以快速进行文件内文本匹配</li>
<li>在打开文件夹的情况下，输入文件名，可以模糊匹配包含对应字符的文件。</li>
<li>在打开文件夹的情况下，文件名 + ：+ 行号，跳转到对应的行， 文件名 + @ 可以跳转到对应的代码段</li>
</ul>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>快捷键一般都可以在ST的菜单中找到。</p>
<ol>
<li>快速复制当前行 CTRL + SHIFT + D</li>
<li>删除当前行 CTRL + SHIFT + K</li>
</ol>
]]></content>
      <categories>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>Sublime</tag>
      </tags>
  </entry>
  <entry>
    <title>使用docsify搭建github pages页面</title>
    <url>/hexoblog/tools/docsify-config/</url>
    <content><![CDATA[<p>docsify 可以快速帮你生成文档网站。不同于 GitBook、Hexo 的地方是它不会生成静态的 <code>.html</code> 文件，<br>所有转换工作都是在运行时。如果你想要开始使用它，只需要创建一个 <code>index.html</code> 就可以开始编写文档并直接部署在 GitHub Pages。</p>
<span id="more"></span>

<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>可以直接参考官方文档 <a href="https://docsify.js.org/#/zh-cn/quickstart">快速开始</a></p>
<p>效果参考  <a href="https://cpfe.github.io/#/">docsify页面</a></p>
<h2 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h2><h3 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge,chrome=1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Description&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, minimum-scale=1.0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;//cdn.jsdelivr.net/npm/docsify@4/lib/themes/vue.css&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.sidebar-nav</span> &gt; <span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span><span class="selector-class">.file</span> <span class="selector-tag">p</span> &gt; <span class="selector-tag">a</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-size</span>: <span class="number">15px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-weight</span>: <span class="number">700</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: <span class="number">#364149</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.sidebar-nav</span> <span class="selector-class">.folder</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">cursor</span>: pointer;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    加载中</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">$docsify</span> = &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">name</span>: <span class="string">&#x27;文档&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">repo</span>: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">loadSidebar</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">subMaxLevel</span>: <span class="number">2</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">coverpage</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">onlyCover</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">auto2top</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">mergeNavbar</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">alias</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="string">&#x27;/.*/_sidebar.md&#x27;</span>: <span class="string">&#x27;/_sidebar.md&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">count</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">countable</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">fontsize</span>: <span class="string">&#x27;0.9em&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">color</span>: <span class="string">&#x27;rgb(90,90,90)&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">language</span>: <span class="string">&#x27;chinese&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// docsify-pagination</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">pagination</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">crossChapter</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">crossChapterText</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">search</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">maxAge</span>: <span class="number">86400000</span>, <span class="comment">// 过期时间，单位毫秒，默认一天</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">paths</span>: <span class="string">&#x27;auto&#x27;</span>, <span class="comment">// or &#x27;auto&#x27;</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">placeholder</span>: <span class="string">&#x27;搜索&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">noData</span>: <span class="string">&#x27;无结果&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">hideOtherSidebarContent</span>: <span class="literal">false</span>, <span class="comment">// 是否隐藏其他侧边栏内容</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">namespace</span>: <span class="string">&#x27;website-1&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">pathNamespaces</span>: [<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;/config&#x27;</span>, <span class="string">&#x27;/guide&#x27;</span>]</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Docsify v4 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//cdn.jsdelivr.net/npm/docsify/lib/docsify.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//cdn.jsdelivr.net/npm/docsify/lib/plugins/search.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//cdn.jsdelivr.net/npm/docsify-copy-code/dist/docsify-copy-code.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//unpkg.com/docsify-count/dist/countable.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//cdn.jsdelivr.net/npm/docsify-pagination/dist/docsify-pagination.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//unpkg.com/docsify-sidebar-collapse@1.3.5/dist/docsify-sidebar-collapse.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- code highlight --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//unpkg.com/prismjs@1.27.0/components/prism-bash.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//unpkg.com/prismjs@1.27.0/components/prism-csharp.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//unpkg.com/prismjs@1.27.0/components/prism-java.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//unpkg.com/prismjs@1.27.0/components/prism-json.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//unpkg.com/prismjs@1.27.0/components/prism-markdown.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//unpkg.com/prismjs@1.27.0/components/prism-nginx.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//unpkg.com/prismjs@1.27.0/components/prism-properties.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//unpkg.com/prismjs@1.27.0/components/prism-sql.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//unpkg.com/prismjs@1.27.0/components/prism-xml-doc.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//unpkg.com/prismjs@1.27.0/components/prism-yaml.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="readme-md"><a href="#readme-md" class="headerlink" title="readme.md"></a>readme.md</h3><p>默认是使用 readme作为首页的</p>
<h3 id="sidebar-md"><a href="#sidebar-md" class="headerlink" title="_sidebar.md"></a>_sidebar.md</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&lt;!-- docs/<span class="emphasis">_sidebar.md --&gt;</span></span><br><span class="line"><span class="emphasis">* 首页</span></span><br><span class="line"><span class="emphasis">	* [<span class="string">首页</span>](<span class="link">readme &quot;首页&quot;</span>)</span></span><br><span class="line"><span class="emphasis">	* [<span class="string">指南</span>](<span class="link">guide &quot;很厉害的导航页面&quot;</span>)</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">* 配置</span></span><br><span class="line"><span class="emphasis">	* [<span class="string">配置说明</span>](<span class="link">config/config</span>)</span></span><br><span class="line"><span class="emphasis">	* [<span class="string">配置说明1</span>](<span class="link">config/config1</span>)</span></span><br><span class="line"><span class="emphasis">	* [<span class="string">配置说明2</span>](<span class="link">config/config2</span>)</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">* 命令</span></span><br><span class="line"><span class="emphasis">	* [<span class="string">命令1</span>](<span class="link">command/command1</span>)</span></span><br><span class="line"><span class="emphasis">	* [<span class="string">命令2</span>](<span class="link">command/command2</span>)</span></span><br><span class="line"><span class="emphasis">	* [<span class="string">命令3</span>](<span class="link">command/command3</span>)</span></span><br><span class="line"><span class="emphasis"></span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>docsify</tag>
      </tags>
  </entry>
  <entry>
    <title>git的使用</title>
    <url>/hexoblog/tools/git-command/</url>
    <content><![CDATA[<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul>
<li>配置可以通过gui工具进行。</li>
<li>git config –list 查看所有配置</li>
<li>git config user.name 查看用户名。</li>
</ul>
<span id="more"></span>

<ul>
<li>配置全局的用户名和邮箱<br>如果不是个人机器，可以去掉global选项，仅针对当前仓库配置。</li>
<li><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;xxx&quot;</span><br><span class="line">git config --global user.email &quot;xxx&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul>
<li><strong>git init</strong> 在目录中初始化仓库，使用git管理。<br> 初始化仓库之后， 可以git remote add [shortname] [url]，添加到远程仓库中。<blockquote>
<p>git remote add cpf <a href="https://github.com/cpf929/test.git">https://github.com/cpf929/test.git</a></p>
</blockquote>
</li>
<li><strong>git clone</strong> 克隆仓库的命令格式为 <code>git clone [url]</code></li>
<li>文件跟踪和更新到仓库</li>
</ul>
<p>工作目录下面的所有文件都不外乎这两种状态：已跟踪或未跟踪。已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是未更新，已修改或者已放入暂存区。而所有其他文件都属于未跟踪文件。它们既没有上次更新时的快照，也不在当前的暂存区域。初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为未修改。</p>
<p>git文件状态变化周期.</p>
<ul>
<li><p><strong>git status</strong> 查看文件状态</p>
</li>
<li><p><strong>git add</strong> 跟踪文件(把文件放入暂存区，文件处于暂存状态)<br>根据目标文件的状态不同，此命令的效果也不同：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等</p>
</li>
<li><p><strong>git diff</strong><br>比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。<br>若要看已经暂存起来的文件和上次提交时的快照之间的差异，使用 <code>git diff --staged</code>。</p>
</li>
<li><p><strong>git commit</strong> 提交暂存区的文件。<br>git commit -m ‘注释’<br>git commit -a 把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤</p>
</li>
<li><p><strong>git rm [filename]</strong> 从暂存区和工作空间中移除文件。<br>git rm –cached readme.txt, 只从暂存区移除，而保留在工作空间。</p>
</li>
<li><p><strong>重命名</strong> <code>git mv from_name to_name</code><br>相当于执行了三条命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv from_name to_name</span><br><span class="line">git rm from_name</span><br><span class="line">git add to_name</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>git log</strong> 显示日志<br>git log -p -2 , <code>-p</code> 选项展开显示每次提交的内容差异，用 <code>-2</code> 则仅显示最近的两次更新</p>
</li>
</ul>
<blockquote>
<p>git log –pretty&#x3D;oneline</p>
</blockquote>
<h3 id="撤销操作-REDO-UNDO"><a href="#撤销操作-REDO-UNDO" class="headerlink" title="撤销操作 REDO&#x2F;UNDO"></a>撤销操作 REDO&#x2F;UNDO</h3><p>参考 <a href="https://github.blog/2015-06-08-how-to-undo-almost-anything-with-git/">How to undo (almost) anything with Git</a></p>
<ol>
<li>修改上次的提交的内容</li>
</ol>
<p>有时候我们提交完了才发现漏掉了几个文件没有加，或者提交信息写错了。想要撤消刚才的提交操作，可以使用 <code>--amend</code> 选项重新提交.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &#x27;initial commit&#x27;</span><br><span class="line">git add forgotten_file </span><br><span class="line">git commit --amend</span><br><span class="line">or git commit --amend -m &quot;注释&quot;</span><br></pre></td></tr></table></figure>
<p>上面的三条命令最终只是产生一个提交，第二个提交命令修正了第一个的提交内容。</p>
<p><code>git commit --amend</code> 会打开编辑器，可以修改上次的提交信息。</p>
<ol start="2">
<li>还原某次提交</li>
</ol>
<p>使用 <code>git revert &lt;SHA&gt;</code> 来直接还原指定的提交，会产生一次新的提交内容，将上次提交的内容删除。</p>
<ol start="3">
<li>撤销工作区中未提交的内容</li>
</ol>
<p><code>git checkout --filename </code> ，撤销工作区文件的修改，不可逆的， 无法通过git找回。</p>
<ol start="4">
<li>重置本地的提交<br>reset到指定的提交版本，丢弃后面产生的提交信息。reset 之后，在git log中没有丢弃后的那些错误的提交记录。</li>
</ol>
<ul>
<li>使用 <code>git reset &lt;last good SHA&gt;</code> or <code>git reset --hard &lt;last good SHA&gt;</code></li>
</ul>
<ol start="5">
<li>Redo after undo “local”</li>
</ol>
<p>reset之后，又想要把对应的提交还原回来。<br>使用 <code>git reflog</code> and <code>git reset</code></p>
<p>reflog 记录有时限，且只在本地才有。</p>
<p>如果想重新创建某个文件，使用 <code>git checkout &lt;SHA&gt; -- &lt;filename&gt;</code></p>
<p>如果只想要把某次的提交内容合并到本地，使用 <code>git cherry-pick &lt;SHA&gt;</code></p>
<h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><ul>
<li>查看远程仓库<br>git remote -v ，查看远程仓库和克隆的地址</li>
<li>添加远程仓库<br>git remote add [shortname] [url]<br>现在可以用[shortname]代替远程地址。如： git fetch [shortname]</li>
<li>从远程仓库抓取数据<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch [remote-name]</span><br></pre></td></tr></table></figure>
会到远程仓库中拉取所有你本地仓库中还没有的数据或更新，只是拉取数据，但是并不自动合并到当前工作分支，</li>
<li>推送数据到远程仓库<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push [remote-name] [branch-name]</span><br></pre></td></tr></table></figure>
克隆操作会自动使用默认的 master 和 origin 名字,所以可以直接git push</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo-next主题配置方式</title>
    <url>/hexoblog/tools/hexo-next-theme/</url>
    <content><![CDATA[<p>主要介绍hexo的配置，和使用next主题时的一些自定义配置，需要先确认版本是否一致。<br>本文主要基于 hexo 7.0.0 和 next 8.18.2，如果版本不一致，可能会有报错。</p>
<span id="more"></span>


<h2 id="hexo安装配置"><a href="#hexo安装配置" class="headerlink" title="hexo安装配置"></a>hexo安装配置</h2><p>操作比较简单，可以直接参考官方文档  <a href="https://hexo.io/zh-cn/docs/configuration">hexo配置</a></p>
<h2 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h2><p>版本依赖</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">$</span> <span class="string">npm list</span></span><br><span class="line"><span class="attr">hexo-site@0.0.0</span> <span class="string">D:\Documents\GitHub\hexo</span></span><br><span class="line"><span class="attr">├──</span> <span class="string">@waline/hexo-next@3.0.1</span></span><br><span class="line"><span class="attr">├──</span> <span class="string">hexo-cli@4.3.1</span></span><br><span class="line"><span class="attr">├──</span> <span class="string">hexo-deployer-git@4.0.0</span></span><br><span class="line"><span class="attr">├──</span> <span class="string">hexo-generator-archive@2.0.0</span></span><br><span class="line"><span class="attr">├──</span> <span class="string">hexo-generator-category@2.0.0</span></span><br><span class="line"><span class="attr">├──</span> <span class="string">hexo-generator-index@3.0.0</span></span><br><span class="line"><span class="attr">├──</span> <span class="string">hexo-generator-searchdb@1.4.1</span></span><br><span class="line"><span class="attr">├──</span> <span class="string">hexo-generator-tag@2.0.0</span></span><br><span class="line"><span class="attr">├──</span> <span class="string">hexo-renderer-ejs@2.0.0</span></span><br><span class="line"><span class="attr">├──</span> <span class="string">hexo-renderer-marked@6.1.1</span></span><br><span class="line"><span class="attr">├──</span> <span class="string">hexo-renderer-stylus@3.0.0</span></span><br><span class="line"><span class="attr">├──</span> <span class="string">hexo-server@3.0.0</span></span><br><span class="line"><span class="attr">├──</span> <span class="string">hexo-symbols-count-time@0.7.1</span></span><br><span class="line"><span class="attr">├──</span> <span class="string">hexo-theme-landscape@1.0.0</span></span><br><span class="line"><span class="attr">├──</span> <span class="string">hexo-theme-next@8.18.2</span></span><br><span class="line"><span class="attr">└──</span> <span class="string">hexo@7.0.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="版本升级"><a href="#版本升级" class="headerlink" title="版本升级"></a>版本升级</h3><ol>
<li>先检查hexo版本， hexo version ，如果不对，可以 <code>npm install -g hexo-cli</code> 全局升级。然后再次查看版本是否升级成功</li>
<li>使用npm-check，检查项目依赖的插件是否需要升级。</li>
<li>使用npm-upgrade，升级依赖的插件。</li>
<li>npm update -g，更新全局插件。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">hexo version</span><br><span class="line"></span><br><span class="line">npm install -g npm-check</span><br><span class="line">npm-check</span><br><span class="line"></span><br><span class="line">npm install -g npm-upgrade</span><br><span class="line">npm-upgrade</span><br><span class="line"></span><br><span class="line">npm update -g</span><br><span class="line"></span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>

<h2 id="Next主题配置"><a href="#Next主题配置" class="headerlink" title="Next主题配置"></a>Next主题配置</h2><p>主要是修改themes&#x2F;next 文件夹内的<code>_config.yml</code> 文件里面的配置</p>
<p><a href="https://theme-next.iissnan.com/getting-started.html">参考官方文档</a></p>
<h3 id="开启阅读时长"><a href="#开启阅读时长" class="headerlink" title="开启阅读时长"></a>开启阅读时长</h3><ol>
<li>npm安装插件</li>
</ol>
<blockquote>
<p>npm install hexo-symbols-count-time -g</p>
</blockquote>
<ol start="2">
<li>修改hexo的主配置，添加</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  symbols: true</span><br><span class="line">  time: true</span><br><span class="line">  total_symbols: true</span><br><span class="line">  total_time: true</span><br><span class="line">  exclude_codeblock: false</span><br><span class="line">  awl: 3</span><br><span class="line">  wpm: 200</span><br><span class="line">  suffix: &quot;mins.&quot;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>查看next的配置文件中的内容</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: true</span><br><span class="line">  item_text_post: true</span><br><span class="line">  item_text_total: false</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>配置完成后，需要执行 hexo clean，否则阅读时长可能会显示 NaN</li>
</ol>
<blockquote>
<p> hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</p>
</blockquote>
<h3 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h3><ol>
<li>安装插件</li>
</ol>
<blockquote>
<p>npm install hexo-generator-searchdb</p>
</blockquote>
<ol start="2">
<li>开启next的搜索配置</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">enable</span>: <span class="string">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="开启访问数统计"><a href="#开启访问数统计" class="headerlink" title="开启访问数统计"></a>开启访问数统计</h3><p>开启配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="添加评论系统"><a href="#添加评论系统" class="headerlink" title="添加评论系统"></a>添加评论系统</h3><p>经过网上的查询和综合评估，选择了<a href="https://waline.js.org/guide/get-started/">waline</a> 作为评论系统。</p>
<ol>
<li><p>首先需要注册和部署相关应用， 可以直接参考官方文档 <a href="https://waline.js.org/guide/get-started/">waline get-started</a></p>
</li>
<li><p>由于 Next 主题中没有 Waline 的评论配置，需要安装官方的插件，在目录下执行</p>
</li>
</ol>
<blockquote>
<p>npm install @waline&#x2F;hexo-next</p>
</blockquote>
<ol start="3">
<li>在next主题的配置下面添加, 一定要修改 serverURL 为自己的</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Waline</span></span><br><span class="line"><span class="comment"># For more information: https://waline.js.org, https://github.com/walinejs/waline</span></span><br><span class="line"><span class="attr">waline:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment">#是否开启</span></span><br><span class="line">  <span class="attr">serverURL:</span> <span class="string">填写第一步部署后获取到的地址</span> <span class="comment"># Waline #服务端地址，我们这里就是上面部署的 Vercel 地址</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">请文明评论呀</span> <span class="comment"># #评论框的默认文字</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">mm</span> <span class="comment"># 头像风格</span></span><br><span class="line">  <span class="attr">meta:</span> [<span class="string">nick</span>, <span class="string">mail</span>, <span class="string">link</span>] <span class="comment"># 自定义评论框上面的三个输入框的内容</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># 评论数量多少时显示分页</span></span><br><span class="line">  <span class="attr">lang:</span> <span class="string">zh-cn</span> <span class="comment"># 语言, 可选值: en, zh-cn</span></span><br><span class="line">  <span class="comment"># Warning: 不要同时启用 `waline.visitor` 以及 `leancloud_visitors`.</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">false</span> <span class="comment"># 文章阅读统计</span></span><br><span class="line">  <span class="attr">comment_count:</span> <span class="literal">true</span> <span class="comment"># 如果为 false , 评论数量只会在当前评论页面显示, 主页则不显示</span></span><br><span class="line">  <span class="attr">requiredFields:</span> [] <span class="comment"># 设置用户评论时必填的信息，[nick,mail]: [nick] | [nick, mail]</span></span><br><span class="line">  <span class="attr">libUrl:</span> <span class="comment"># Set custom library cdn url</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>重新生成</li>
</ol>
<blockquote>
<p> hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</p>
</blockquote>
<h3 id="登录注册评论后台"><a href="#登录注册评论后台" class="headerlink" title="登录注册评论后台"></a>登录注册评论后台</h3><p>Waline 有服务端，支持评论管理。找到评论框，点击 登录 按钮，会弹出一个窗口，找到用户注册，默认第一个注册的用户为管理员，所以部署好一定要记得及时注册。</p>
<p>注册登录之后， 就可以对评论进行管理了。</p>
<h3 id="hexo开启-mermaid"><a href="#hexo开启-mermaid" class="headerlink" title="hexo开启 mermaid"></a>hexo开启 mermaid</h3><p><code>mermaid</code> 可以帮助在markdown中画流程图，时序图等</p>
<p>首先需要在项目目录下面安装依赖</p>
<blockquote>
<p> npm i hexo-filter-mermaid-diagrams</p>
</blockquote>
<p>然后在配置中开启</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mermaid:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>下面就可以在markdown文件中添加对应的内容，页面就会自动渲染了， 如下面的例子</p>
<p><strong>流程图</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">mermaid</span></span><br><span class="line"><span class="string">graph</span> <span class="string">TD</span></span><br><span class="line"><span class="string">Start</span> <span class="string">--&gt;</span> <span class="string">Stop</span></span><br></pre></td></tr></table></figure>


<pre class="mermaid">graph TD
Start --> Stop</pre>

<p><strong>时间轴</strong></p>
<pre class="mermaid">timeline
      title History of Social Media Platform
      2002 : LinkedIn
      2004 : Facebook
           : Google
      2005 : Youtube
      2006 : Twitter</pre>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo使用</title>
    <url>/hexoblog/tools/hexo%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br><span class="line"></span><br><span class="line"> hexo new post -p folder/fileanme <span class="string">&quot;titlename&quot;</span></span><br><span class="line"> </span><br><span class="line"> 比如 &gt;hexo new post -p tools/testfile <span class="string">&quot;测试文章&quot;</span></span><br><span class="line">  // 就是在posts 下的 tools目录中创建了文件 testfile.md，文件中对应的title是 测试文章</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>
<h3 id="使用图片"><a href="#使用图片" class="headerlink" title="使用图片"></a>使用图片</h3><p>可以将图片放到 source&#x2F;images 目录下面即可，然后在文章中使用markdown语法访问他们, 参考 <a href="https://fuhailin.github.io/Hexo-images/">资源文件夹</a></p>
<blockquote>
<p> <code>![](/images/image.jpg)</code></p>
</blockquote>
<p>效果如下:</p>
<p><img data-src="/hexoblog/images/assets/40703300-d32f-11ea-938e-f5ee97dc461f.jpg"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>使用jsdelivr加速hexo github pages博客的静态资源</title>
    <url>/hexoblog/tools/use-jsdelivr-cdn-hexo-blog/</url>
    <content><![CDATA[<p>使用hexo将博客部署在github pages上面，有时候访问速度会比较慢，可以将图片等静态资源，使用jsdelivr进行cdn加速。</p>
<p>目前由于一些非法的滥用，jsdelivr在国内被墙，无法访问了。</p>
<span id="more"></span>

<h3 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍"></a>使用介绍</h3><p><a href="https://github.com/jsdelivr/jsdelivr?tab=readme-ov-file#github">jsdelivr加速github介绍</a></p>
<p>根路径是 :  <a href="https://cdn.jsdelivr.net/">https://cdn.jsdelivr.net</a></p>
<h4 id="Load-any-GitHub-release-commit-or-branch"><a href="#Load-any-GitHub-release-commit-or-branch" class="headerlink" title="Load any GitHub release, commit, or branch:"></a>Load any GitHub release, commit, or branch:</h4><blockquote>
<p>&#x2F;gh&#x2F;user&#x2F;repo@version&#x2F;file</p>
</blockquote>
<h4 id="Load-exact-version"><a href="#Load-exact-version" class="headerlink" title="Load exact version:"></a>Load exact version:</h4><blockquote>
<p>&#x2F;gh&#x2F;jquery&#x2F;<a href="mailto:&#x6a;&#113;&#117;&#x65;&#114;&#121;&#x40;&#51;&#46;&#x31;&#x2e;&#48;">&#x6a;&#113;&#117;&#x65;&#114;&#121;&#x40;&#51;&#46;&#x31;&#x2e;&#48;</a>&#x2F;dist&#x2F;jquery.min.js<br>&#x2F;gh&#x2F;jquery&#x2F;jquery@32b00373b3f42e5cdcb709df53f3b08b7184a944&#x2F;dist&#x2F;jquery.min.js</p>
</blockquote>
<h4 id="Use-a-version-range-instead-of-an-exact-version-only-works-with-valid-semver-versions"><a href="#Use-a-version-range-instead-of-an-exact-version-only-works-with-valid-semver-versions" class="headerlink" title="Use a version range instead of an exact version (only works with valid semver versions):"></a>Use a version range instead of an exact version (only works with valid semver versions):</h4><blockquote>
<p>&#x2F;gh&#x2F;jquery&#x2F;jquery@3&#x2F;dist&#x2F;jquery.min.js<br>&#x2F;gh&#x2F;jquery&#x2F;<a href="mailto:&#106;&#113;&#117;&#101;&#x72;&#x79;&#64;&#x33;&#46;&#x31;">&#106;&#113;&#117;&#101;&#x72;&#x79;&#64;&#x33;&#46;&#x31;</a>&#x2F;dist&#x2F;jquery.min.js</p>
</blockquote>
<ul>
<li>访问方式</li>
</ul>
<p><a href="https://cdn.jsdelivr.net/gh/Github%E7%94%A8%E6%88%B7%E5%90%8D/%E4%BB%93%E5%BA%93%E5%90%8D/%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84">https://cdn.jsdelivr.net/gh/Github用户名/仓库名/资源路径</a></p>
<p>默认访问 <code>master</code>分支下面的文件。</p>
<p>比如: </p>
<ul>
<li><a href="https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js">https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js</a> 访问的是master下的</li>
<li><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@3.1.0/dist/jquery.min.js">https://cdn.jsdelivr.net/gh/jquery/jquery@3.1.0/dist/jquery.min.js</a> 访问的是精确的版本</li>
<li><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@3.1/dist/jquery.min.js">https://cdn.jsdelivr.net/gh/jquery/jquery@3.1/dist/jquery.min.js</a>  访问的是范围版本</li>
</ul>
<p>加速静态资源的方式， 可以在github上创建一个仓库，比如叫cdn，然后将静态资源放到方库中。</p>
<blockquote>
<p><a href="https://cdn.jsdelivr.net/gh/cpfo/cdn/images/2024/40703300-d32f-11ea-938e-f5ee97dc461f.jpg">https://cdn.jsdelivr.net/gh/cpfo/cdn/images/2024/40703300-d32f-11ea-938e-f5ee97dc461f.jpg</a></p>
</blockquote>
<p>使用加速后的图片</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/cpfo/cdn/images/2024/40703300-d32f-11ea-938e-f5ee97dc461f.jpg"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>jsdelivr</tag>
      </tags>
  </entry>
  <entry>
    <title>linux常用操作</title>
    <url>/hexoblog/yunwei/linux%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>主要记录一些日常用到的shell命令操作。</p>
<span id="more"></span>

<ol>
<li>jenkins执行remote主机上面的sh脚本时， 无法拿到远程主机的环境变量。</li>
</ol>
<p>解决方法：在文件开头的注释加上 –login</p>
<p><code> #!/bin/bash --login</code></p>
<p><a href="http://feihu.me/blog/2014/env-problem-when-ssh-executing-command-on-remote/">参考</a></p>
<ol start="2">
<li>sed 替换文件中的内容</li>
</ol>
<blockquote>
<p>sed -i ‘s&#x2F;java -jar&#x2F;$JAVA_HOME/bin/java -jar&#x2F;g’ <code>find /opt/xxxxx/ -name &quot;xxx.sh&quot;</code></p>
</blockquote>
<ol start="3">
<li>jenkins shell重启本地tomcat， 无效， 原因，jenkins 会杀死衍生进程</li>
</ol>
<p><a href="https://wiki.jenkins-ci.org/display/JENKINS/ProcessTreeKiller">参考</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sleep 5</span><br><span class="line">BUILD_ID=dontKillMe</span><br><span class="line">bash /opt/xxxx/business_restart.sh</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>CentOS&#x2F;RHEL 修改主机名</li>
</ol>
<ul>
<li>查看主机名</li>
</ul>
<blockquote>
<p>hostnamectl status</p>
</blockquote>
<ul>
<li>修改</li>
</ul>
<blockquote>
<p>hostnamectl –static set-hostname 名字</p>
</blockquote>
<ol start="5">
<li>创建组， 用户权限</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">groupadd dev</span><br><span class="line">useradd -g dev cpf</span><br><span class="line">passwd cpf</span><br><span class="line">用户列表文件：/etc/passwd</span><br><span class="line"></span><br><span class="line">用户组列表文件：/etc/group</span><br><span class="line"></span><br><span class="line">查看系统中有哪些用户：cut -d : -f 1 /etc/passwd</span><br><span class="line"></span><br><span class="line">查看可以登录系统的用户：cat /etc/passwd | grep -v /sbin/nologin | cut -d : -f 1</span><br><span class="line"></span><br><span class="line">查看用户操作：w命令(需要root权限)</span><br><span class="line"></span><br><span class="line">查看某一用户：w 用户名</span><br><span class="line"></span><br><span class="line">查看登录用户：who</span><br><span class="line"></span><br><span class="line">查看用户登录历史记录：last</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>修改目录所属用户和组</li>
</ol>
<blockquote>
<p>chown -R cpf.dev tomcat2&#x2F;</p>
</blockquote>
<ol start="7">
<li>磁盘</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看 fdisk –l</span><br><span class="line">fdisk /dev/vdb</span><br><span class="line">输入n 进行分区, 分区类型选 p， 分区个数默认， 柱面默认， 输入w 写入分区表</span><br><span class="line">格式化分区,如果创建的是主分区；</span><br><span class="line">mkfs -t ext3 /dev/vdb1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="8">
<li>find中 -mtime 中的参数n</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . –mtime n中的n指的是24*n, +n、-n、n分别表示：</span><br><span class="line">+n： 大于n</span><br><span class="line">-n:  小于n</span><br><span class="line">n：  等于n</span><br><span class="line"></span><br><span class="line">但是man find里这样的解释还是比较令人费解的，不如直接看find . -mtime 中的用法</span><br><span class="line"></span><br><span class="line">find . –mtime n:  File waslast modified n*24 hours ago.</span><br><span class="line"></span><br><span class="line">最后一次修改发生在距离当前时间n*24小时至(n+1)*24 小时</span><br><span class="line"></span><br><span class="line">find . –mtime +n:</span><br><span class="line"></span><br><span class="line">最后一次修改发生在n+1天以前，距离当前时间为(n+1)*24小时或者更早</span><br><span class="line"></span><br><span class="line">find . –mtime –n:</span><br><span class="line"></span><br><span class="line">最后一次修改发生在n天以内，距离当前时间为n*24小时以内</span><br></pre></td></tr></table></figure>



<ol start="9">
<li>awk</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk默认分割符是空格或制表符。</span><br><span class="line">cut命令不能在分割符是空格的字符串中截取列，只能是制表符或具体的分割符。</span><br><span class="line">cut [选项] 文件</span><br><span class="line">awk &#x27;条件1&#123;动作1&#125; 条件2&#123;动作2&#125; ...&#x27; 文件名</span><br><span class="line"></span><br><span class="line">awk &#x27;&#123;print $1&#125;&#x27; 文件名</span><br><span class="line">awk &#x27;&#123;if ( $1 &gt; 10 )&#123; print $1&#125; &#125;&#x27;</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>网络监控工具</li>
</ol>
<p>iftop,  iptraf-ng</p>
<ol start="11">
<li>root 删除文件 Operation not permitted</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsattr 1.txt</span><br><span class="line">——i—— 1.txt</span><br><span class="line">在lsattr命令下，这个1.txt文件带有一个&quot;i&quot;的属性，所以才不可以删除</span><br><span class="line">chattr -i 1.txt</span><br><span class="line"></span><br><span class="line">chattr +i filename 加上保护</span><br></pre></td></tr></table></figure>

<ol start="12">
<li>获取目录， 文件名</li>
</ol>
<blockquote>
<p>dirname, basename</p>
</blockquote>
<ol start="13">
<li>redis批量更新</li>
</ol>
<blockquote>
<p>for i in $(cat news1.txt) ; do echo ‘set’ $i $((RANDOM % (200 - 50) + 50)); done | redis-cli -c -p 6300</p>
</blockquote>
<ol start="14">
<li>nginx统计</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nginx按分钟统计访问频率高的</span><br><span class="line">awk &#x27;&#123;print $3&#125;&#x27; access.log | cut -c 14-18 | uniq -c  | sort -rn  | head -n 100</span><br><span class="line"></span><br><span class="line">统计耗时的请求</span><br><span class="line">tail -200000 access.log | awk  &#x27;&#123;print $3, $6 ,$10&#125;&#x27; | sort -k3 -rn | head -100</span><br></pre></td></tr></table></figure>

<ol start="15">
<li>切割大文件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">head</span> -3000000 4.txt &gt; 4.1.txt</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">tail</span> -n +3000001 4.txt &gt; 4.2.txt</span></span><br><span class="line"></span><br><span class="line">split -l 2600000 -d imei-part-3.txt  imei-part-3_</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="16">
<li>循环请求url</li>
</ol>
<blockquote>
<p>for i in <code>cat udid.txt</code> ; do curl  -0 $i; echo ‘’ ; done</p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx拦截非法host的请求</title>
    <url>/hexoblog/yunwei/nginx-deny-host/</url>
    <content><![CDATA[<p>在nginx的访问日志中发现了一些奇怪的host域名，并非是实际用到的，经过排查发现，可以在本地的hosts文件中指定ip和域名的映射关系， 这样就可以通过访问一个任意的域名，来请求到对应的ip地址上面，因为nginx会使用默认server来处理未匹配到server_name的请求，可以通过这种方式来绕过waf等，或者访问到nginx中其他的servername下， 会有一定的风险，需要将这种方式拦截掉</p>
<span id="more"></span>

<p>比如在hosts文件中指定ip对应 <a href="http://www.abc.com/">www.abc.com</a> </p>
<blockquote>
<p>xx.xx.xx.xx <a href="http://www.abc.com/">www.abc.com</a></p>
</blockquote>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>因为nginx默认按照ASCII码的顺序来加载conf配置文件，所以可以通过创建一个00开头的conf文件，来保证是最先加载的，在该文件中指定默认的server_name,<br>来拦截所有的非法host的请求</p>
<p>可以使用 <code>ls -nl</code> 来查看nginx conf文件的ASCII顺序。</p>
<p>00block.conf 文件的配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">	listen 80 default_server;</span><br><span class="line">        server_name __;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">		deny all;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        listen 443 ssl default_server;</span><br><span class="line">        server_name _;</span><br><span class="line">        ssl_certificate cert/xxx.com.pem;</span><br><span class="line">        ssl_certificate_key cert/xxx.com.key;</span><br><span class="line">        ssl_session_timeout 5m;</span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; </span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">                deny all;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>这样就可以禁止掉直接通过IP或者本地绑定域名的方式的非法请求。</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>es索引和文档操作</title>
    <url>/hexoblog/java/es/es-02-index-mapping/</url>
    <content><![CDATA[<p>主要介绍索引和文档的CRUD操作。</p>
<span id="more"></span>


<h1 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h1><p>常用api列表 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.12/rest-apis.html">rest-apis.html</a> </p>
<table>
<thead>
<tr>
<th>操作</th>
<th>方式</th>
<th>接口</th>
<th>参数</th>
</tr>
</thead>
<tbody><tr>
<td>集群健康</td>
<td>GET</td>
<td>&#x2F;_cat&#x2F;health?v</td>
<td>-</td>
</tr>
<tr>
<td>节点列表</td>
<td>GET</td>
<td>&#x2F;_cat&#x2F;nodes?v</td>
<td>-</td>
</tr>
<tr>
<td>索引列表</td>
<td>GET</td>
<td>&#x2F;_cat&#x2F;indices?v</td>
<td>-</td>
</tr>
<tr>
<td>创建索引</td>
<td>PUT</td>
<td>&#x2F;indexName</td>
<td>-</td>
</tr>
<tr>
<td>查看设置</td>
<td>GET</td>
<td>&#x2F;indexname&#x2F;_settings</td>
<td>-</td>
</tr>
<tr>
<td>&#x2F;查看映射</td>
<td>GET</td>
<td>&#x2F;indexname&#x2F;_mapping</td>
<td>-</td>
</tr>
<tr>
<td>关闭索引</td>
<td>POST</td>
<td>&#x2F;name&#x2F;_close</td>
<td>-</td>
</tr>
<tr>
<td>打开索引</td>
<td>POST</td>
<td>&#x2F;name&#x2F;_open</td>
<td>-</td>
</tr>
<tr>
<td>删除索引</td>
<td>DELETE</td>
<td>&#x2F;name</td>
<td>-</td>
</tr>
</tbody></table>
<h1 id="索引库操作"><a href="#索引库操作" class="headerlink" title="索引库操作"></a>索引库操作</h1><p>索引库就类似数据库表，mapping映射就类似表的结构。</p>
<p>我们要向es中存储数据，必须先创建“库”和“表”。</p>
<h2 id="Mapping映射属性"><a href="#Mapping映射属性" class="headerlink" title="Mapping映射属性"></a>Mapping映射属性</h2><p>mapping是对索引库中文档的约束，常见的mapping属性包括：</p>
<ul>
<li><p>type：字段数据类型，常见的简单类型有：</p>
<ul>
<li><p>字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip地址）</p>
<blockquote>
<p><strong>keyword类型只能整体搜索，不支持搜索部分内容</strong></p>
</blockquote>
</li>
<li><p>数值：long、integer、short、byte、double、float、</p>
</li>
<li><p>布尔：boolean</p>
</li>
<li><p>日期：date</p>
</li>
<li><p>对象：object</p>
</li>
</ul>
</li>
<li><p>index：是否创建索引，默认为true</p>
</li>
<li><p>analyzer：使用哪种分词器</p>
</li>
<li><p>properties：该字段的子字段</p>
</li>
<li><p>fields: 给field 创建多字段，用于不同目的(全文检索或者聚合分析排序)， 参考 <a href="https://www.cnblogs.com/hld123/p/16538466.html">es的mapping参数-fields</a> , <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-params.html">mapping-params</a></p>
</li>
</ul>
<p>例如下面的json文档</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">21</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;weight&quot;</span><span class="punctuation">:</span> <span class="number">52.1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;isMarried&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;info&quot;</span><span class="punctuation">:</span> <span class="string">&quot;真相只有一个！&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;zy@itcast.cn&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;score&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">99.1</span><span class="punctuation">,</span> <span class="number">99.5</span><span class="punctuation">,</span> <span class="number">98.9</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;firstName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;柯&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;lastName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;南&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>


<p>对应的每个字段映射（mapping）：</p>
<ul>
<li>age：类型为 integer；参与搜索，因此需要index为true；无需分词器</li>
<li>weight：类型为float；参与搜索，因此需要index为true；无需分词器</li>
<li>isMarried：类型为boolean；参与搜索，因此需要index为true；无需分词器</li>
<li>info：类型为字符串，需要分词，因此是text；参与搜索，因此需要index为true；分词器可以用ik_smart</li>
<li>email：类型为字符串，但是不需要分词，因此是keyword；不参与搜索，因此需要index为false；无需分词器</li>
<li>score：虽然是数组，但是我们只看元素的类型，类型为float；参与搜索，因此需要index为true；无需分词器</li>
<li>name：类型为object，需要定义多个子属性<ul>
<li>name.firstName；类型为字符串，但是不需要分词，因此是keyword；参与搜索，因此需要index为true；无需分词器</li>
<li>name.lastName；类型为字符串，但是不需要分词，因此是keyword；参与搜索，因此需要index为true；无需分词器</li>
</ul>
</li>
</ul>
<h2 id="索引库的CRUD"><a href="#索引库的CRUD" class="headerlink" title="索引库的CRUD"></a>索引库的CRUD</h2><blockquote>
<p>CRUD简单描述：</p>
<ul>
<li>创建索引库：PUT &#x2F;索引库名</li>
<li>查询索引库：GET &#x2F;索引库名</li>
<li>删除索引库：DELETE &#x2F;索引库名</li>
<li>修改索引库（添加字段）：PUT &#x2F;索引库名&#x2F;_mapping</li>
</ul>
</blockquote>
<p>这里统一使用Kibana编写DSL的方式来演示。</p>
<h3 id="创建索引库和映射"><a href="#创建索引库和映射" class="headerlink" title="创建索引库和映射"></a>创建索引库和映射</h3><p><strong>基本语法：</strong></p>
<ul>
<li>请求方式：PUT</li>
<li>请求路径：&#x2F;索引库名，可以自定义</li>
<li>请求参数：mapping映射</li>
</ul>
<p>格式：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /索引库名称</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;字段名&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;字段名2&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;false&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;字段名3&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;子字段&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="comment">// ...略</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /conan</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;column1&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;column2&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;false&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;column3&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;子字段1&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;子字段2&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="查询索引库"><a href="#查询索引库" class="headerlink" title="查询索引库"></a>查询索引库</h3><p><strong>基本语法</strong>：</p>
<ul>
<li>请求方式：GET</li>
<li>请求路径：&#x2F;索引库名</li>
<li>请求参数：无</li>
</ul>
<p><strong>格式</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /索引库名</span><br></pre></td></tr></table></figure>

<h3 id="修改索引库"><a href="#修改索引库" class="headerlink" title="修改索引库"></a>修改索引库</h3><blockquote>
<p>这里的修改是只能增加新的字段到mapping中</p>
</blockquote>
<p>倒排索引结构虽然不复杂，但是一旦数据结构改变（比如改变了分词器），就需要重新创建倒排索引，这简直是灾难。因此索引库<strong>一旦创建，无法修改mapping</strong>。</p>
<p>虽然无法修改mapping中已有的字段，但是却<strong>允许添加新的字段</strong>到mapping中，因为不会对倒排索引产生影响。</p>
<p><strong>语法说明</strong>：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /索引库名/_mapping</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;新字段名&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /conan/_mapping</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;acknowledged&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="删除索引库"><a href="#删除索引库" class="headerlink" title="删除索引库"></a>删除索引库</h3><p><strong>语法：</strong></p>
<ul>
<li><p>请求方式：DELETE</p>
</li>
<li><p>请求路径：&#x2F;索引库名</p>
</li>
<li><p>请求参数：无</p>
</li>
</ul>
<p><strong>格式：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="operator">/</span>索引库名</span><br></pre></td></tr></table></figure>

<h1 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h1><blockquote>
<p>文档操作有哪些？</p>
<ul>
<li>创建文档：POST &#x2F;{索引库名}&#x2F;_doc&#x2F;文档id</li>
<li>查询文档：GET &#x2F;{索引库名}&#x2F;_doc&#x2F;文档id</li>
<li>删除文档：DELETE &#x2F;{索引库名}&#x2F;_doc&#x2F;文档id</li>
<li>修改文档：<ul>
<li>全量修改：PUT &#x2F;{索引库名}&#x2F;_doc&#x2F;文档id</li>
<li>增量修改：POST &#x2F;{索引库名}&#x2F;_update&#x2F;文档id { “doc”: {字段}}</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="文档的CRUD"><a href="#文档的CRUD" class="headerlink" title="文档的CRUD"></a>文档的CRUD</h2><p>先创建索引库</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /testcrud</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;info&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;firstName&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;lastName&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="新增文档"><a href="#新增文档" class="headerlink" title="新增文档"></a>新增文档</h3><p><strong>语法：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /索引库名/_doc/文档id</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;字段1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;字段2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;字段3&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;子属性1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值3&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;子属性2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值4&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /testcrud/_doc/<span class="number">1</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;info&quot;</span><span class="punctuation">:</span> <span class="string">&quot;真相只有一个！&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;firstName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;柯&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;lastName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;南&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;testcrud&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_version&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;result&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;created&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;total&quot;</span> <span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> <span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_seq_no&quot;</span> <span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_primary_term&quot;</span> <span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h3><p>根据rest风格，新增是post，查询应该是get，不过查询一般都需要条件，这里我们把文档id带上。</p>
<p><strong>语法：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /<span class="punctuation">&#123;</span>索引库名称<span class="punctuation">&#125;</span>/_doc/<span class="punctuation">&#123;</span>id<span class="punctuation">&#125;</span></span><br><span class="line"><span class="comment">//批量查询：查询该索引库下的全部文档</span></span><br><span class="line">GET /<span class="punctuation">&#123;</span>索引库名称<span class="punctuation">&#125;</span>/_search</span><br></pre></td></tr></table></figure>
<p><strong>通过kibana查看数据</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /testcrud/_doc/<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;testcrud&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_version&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_seq_no&quot;</span> <span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_primary_term&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;found&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_source&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;info&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;真相只有一个！&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span> <span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;firstName&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;柯&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;lastName&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;南&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><p>删除使用DELETE请求，同样，需要根据id进行删除：</p>
<p><strong>语法：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">DELETE</span> /&#123;索引库名&#125;/_doc/id值</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"># 根据id删除数据</span><br><span class="line">DELETE /testcrud/_doc/<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;testcrud&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_version&quot;</span> <span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;result&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;deleted&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;total&quot;</span> <span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> <span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_seq_no&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_primary_term&quot;</span> <span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="修改文档"><a href="#修改文档" class="headerlink" title="修改文档"></a>修改文档</h3><p>修改有两种方式：</p>
<ul>
<li>全量修改：直接覆盖原来的文档</li>
<li>增量修改：修改文档中的部分字段</li>
</ul>
<p><strong>全量修改</strong></p>
<p>全量修改是覆盖原来的文档，其本质是：</p>
<ul>
<li>根据指定的id删除文档</li>
<li>新增一个相同id的文档</li>
</ul>
<p><strong>注意</strong>：如果根据id删除时，id不存在，第二步的新增也会执行，也就从修改变成了新增操作了。</p>
<p><strong>语法：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /<span class="punctuation">&#123;</span>索引库名<span class="punctuation">&#125;</span>/_doc/文档id</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;字段1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;字段2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值2&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// ... 略</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>示例</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /testcrud/_doc/<span class="number">1</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;info&quot;</span><span class="punctuation">:</span> <span class="string">&quot;真相只有一个！, 哈哈哈哈&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;firstName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;柯xxx&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;lastName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;南&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;testcrud&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_version&quot;</span> <span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_seq_no&quot;</span> <span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_primary_term&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;found&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_source&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;info&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;真相只有一个！, 哈哈哈哈&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span> <span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;firstName&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;柯xxx&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;lastName&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;南&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>增量修改</strong></p>
<p>增量修改是只修改指定id匹配的文档中的部分字段。</p>
<p><strong>语法：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /<span class="punctuation">&#123;</span>索引库名<span class="punctuation">&#125;</span>/_update/文档id</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;doc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;字段名&quot;</span><span class="punctuation">:</span> <span class="string">&quot;新的值&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">增量修改</span></span><br><span class="line">POST /testcrud/_update/1</span><br><span class="line">&#123;</span><br><span class="line">    &quot;doc&quot;: &#123;</span><br><span class="line">         &quot;age&quot;: 10</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 结果</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot; : &quot;testcrud&quot;,</span><br><span class="line">  &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">  &quot;_id&quot; : &quot;1&quot;,</span><br><span class="line">  &quot;_version&quot; : 4,</span><br><span class="line">  &quot;result&quot; : &quot;updated&quot;,</span><br><span class="line">  &quot;_shards&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : 2,</span><br><span class="line">    &quot;successful&quot; : 1,</span><br><span class="line">    &quot;failed&quot; : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;_seq_no&quot; : 5,</span><br><span class="line">  &quot;_primary_term&quot; : 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>参考文章</strong></p>
<ol>
<li><a href="https://www.cnblogs.com/buchizicai/p/17093719.html">ElasticSearch (ES从入门到精通一篇就够了)</a></li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>elascitsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>ES相关介绍和安装</title>
    <url>/hexoblog/java/es/es-01-install/</url>
    <content><![CDATA[<p>主要记录下ES的概念，安装和使用。</p>
<span id="more"></span>

<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><p>倒排索引的概念是基于MySQL这样的正向索引而言的。</p>
<h3 id="正向索引"><a href="#正向索引" class="headerlink" title="正向索引"></a>正向索引</h3><blockquote>
<p>设置了索引的话挺快的，但要是模糊查询则就很慢！</p>
</blockquote>
<p>那么什么是正向索引呢？例如给下表（tb_goods）中的id创建索引：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205171741388-1990334679.png" alt="images"></p>
<p>如果是根据id查询，那么直接走索引，查询速度非常快。</p>
<p>但如果是基于title做模糊查询，只能是逐行扫描数据，流程如下：</p>
<p>1）用户搜索数据，条件是title符合”%手机%”</p>
<p>2）逐行获取数据，比如id为1的数据</p>
<p>3）判断数据中的title是否符合用户搜索条件</p>
<p>4）如果符合则放入结果集，不符合则丢弃。回到步骤1</p>
<p>逐行扫描，也就是全表扫描，随着数据量增加，其查询效率也会越来越低。当数据量达到数百万时，就是一场灾难。</p>
<h3 id="倒排索引-1"><a href="#倒排索引-1" class="headerlink" title="倒排索引"></a>倒排索引</h3><p>倒排索引中有两个非常重要的概念：</p>
<ul>
<li>文档（Document）：用来搜索的数据，其中的每一条数据就是一个文档。例如一个网页、一个商品信息</li>
<li>词条（Term）：对文档数据或用户搜索数据，利用某种算法分词，得到的具备含义的词语就是词条。例如：我是中国人，就可以分为：我、是、中国人、中国、国人这样的几个词条</li>
</ul>
<p>创建倒排索引是对正向索引的一种特殊处理，流程如下：</p>
<ul>
<li>将每一个文档的数据利用算法分词，得到一个个词条</li>
<li>创建表，每行数据包括词条、词条所在文档id、位置等信息</li>
<li>因为词条唯一性，可以给词条创建索引，例如hash表结构索引</li>
</ul>
<p>如图：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205171751933-576636800.png" alt="images"></p>
<p>倒排索引的<strong>搜索流程</strong>如下（以搜索”华为手机”为例）：</p>
<p>1）用户输入条件<code>&quot;华为手机&quot;</code>进行搜索。</p>
<p>2）对用户输入内容<strong>分词</strong>，得到词条：<code>华为</code>、<code>手机</code>。</p>
<p>3）拿着词条在倒排索引中查找，可以得到包含词条的文档id：1、2、3。</p>
<p>4）拿着文档id到正向索引中查找具体文档。</p>
<p>如图：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205171803916-704919285.png" alt="image"></p>
<p>虽然要先查询倒排索引，再查询倒排索引，但是无论是词条、还是文档id都建立了索引，查询速度非常快！无需全表扫描。</p>
<h3 id="正向和倒排对比"><a href="#正向和倒排对比" class="headerlink" title="正向和倒排对比"></a>正向和倒排对比</h3><p>概念区别：</p>
<ul>
<li><p><strong>正向索引</strong>是最传统的，根据id索引的方式。但根据词条查询时，必须先逐条获取每个文档，然后判断文档中是否包含所需要的词条，是<strong>根据文档找词条的过程</strong>。</p>
</li>
<li><p>而<strong>倒排索引</strong>则相反，是先找到用户要搜索的词条，根据词条得到保护词条的文档的id，然后根据id获取文档。是<strong>根据词条找文档的过程</strong>。</p>
</li>
</ul>
<h2 id="ES数据库基本概念"><a href="#ES数据库基本概念" class="headerlink" title="ES数据库基本概念"></a>ES数据库基本概念</h2><p>elasticsearch中有很多独有的概念，与mysql中略有差别，但也有相似之处。</p>
<h3 id="文档和字段"><a href="#文档和字段" class="headerlink" title="文档和字段"></a>文档和字段</h3><blockquote>
<p>一个文档就像数据库里的一条数据，字段就像数据库里的列</p>
</blockquote>
<p>elasticsearch是面向<strong>文档（Document）</strong>存储的，可以是<strong>数据库中的一条商品数据</strong>，一个订单信息。文档数据会被序列化为json格式后存储在elasticsearch中：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205171811564-2114810461.png" alt="image"></p>
<p>而Json文档中往往包含很多的<strong>字段（Field）</strong>，类似于<strong>mysql数据库中的列</strong>。</p>
<h3 id="索引和映射"><a href="#索引和映射" class="headerlink" title="索引和映射"></a>索引和映射</h3><blockquote>
<p>索引就像数据库里的表，映射就像数据库中定义的表结构</p>
</blockquote>
<p><strong>索引（Index）</strong>，就是相同类型的文档的集合【<strong>类似mysql中的表</strong>】</p>
<p>例如：</p>
<ul>
<li>所有用户文档，就可以组织在一起，称为用户的索引；</li>
<li>所有商品的文档，可以组织在一起，称为商品的索引；</li>
<li>所有订单的文档，可以组织在一起，称为订单的索引；</li>
</ul>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205171817377-1198317744.png" alt="image"></p>
<p>因此，我们可以把索引当做是数据库中的表。</p>
<p>数据库的表会有约束信息，用来定义表的结构、字段的名称、类型等信息。因此，索引库中就有<strong>映射（mapping）</strong>，是索引中文档的字段约束信息，类似表的结构约束。</p>
<h3 id="mysql与elasticsearch"><a href="#mysql与elasticsearch" class="headerlink" title="mysql与elasticsearch"></a>mysql与elasticsearch</h3><blockquote>
<p>各自长处：</p>
<ul>
<li>Mysql：擅长事务类型操作，可以确保数据的安全和一致性</li>
<li>Elasticsearch：擅长海量数据的搜索、分析、计算</li>
</ul>
</blockquote>
<p>我们统一的把<strong>mysql与elasticsearch的概念做一下对比</strong>：</p>
<table>
<thead>
<tr>
<th><strong>MySQL</strong></th>
<th><strong>Elasticsearch</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Table</td>
<td>Index</td>
<td>索引(index)，就是文档的集合，类似数据库的表(table)</td>
</tr>
<tr>
<td>Row</td>
<td>Document</td>
<td>文档（Document），就是一条条的数据，类似数据库中的行（Row），文档都是JSON格式</td>
</tr>
<tr>
<td>Column</td>
<td>Field</td>
<td>字段（Field），就是JSON文档中的字段，类似数据库中的列（Column）</td>
</tr>
<tr>
<td>Schema</td>
<td>Mapping</td>
<td>Mapping（映射）是索引中文档的约束，例如字段类型约束。类似数据库的表结构（Schema）</td>
</tr>
<tr>
<td>SQL</td>
<td>DSL</td>
<td>DSL是elasticsearch提供的JSON风格的请求语句，用来操作elasticsearch，实现CRUD</td>
</tr>
</tbody></table>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205171824403-1152991371.png" alt="image"></p>
<h1 id="ES和Kibana安装"><a href="#ES和Kibana安装" class="headerlink" title="ES和Kibana安装"></a>ES和Kibana安装</h1><h2 id="ES安装"><a href="#ES安装" class="headerlink" title="ES安装"></a>ES安装</h2><h3 id="JDK依赖问题"><a href="#JDK依赖问题" class="headerlink" title="JDK依赖问题"></a>JDK依赖问题</h3><p>ES优先使用系统的jdk，如果版本不一致就会报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">warning: usage of JAVA_HOME is deprecated, use ES_JAVA_HOME</span><br><span class="line">Future versions of Elasticsearch will require Java 11; your Java version from [/usr/local/java/jdk1.8.0_421/jre] does not meet this requirement. Consider switching to a distribution of Elasticsearch with a bundled JDK. If you are already using a distribution with a bundled JDK, ensure the JAVA_HOME environment variable is not set.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解决办法：  使用es自带的jdk, 修改 bin&#x2F;elasticsearch ， 添加下面内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">############# 添加配置解决jdk版本问题 ##############</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将jdk修改为es中自带jdk的配置目录</span></span><br><span class="line">export ES_JAVA_HOME=/usr/local/elasticsearch/elasticsearch-7.12.1/jdk</span><br><span class="line">export PATH=$ES_JAVA_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line">if [ -x &quot;$ES_JAVA_HOME/bin/java&quot; ]; then</span><br><span class="line">        JAVA=&quot;$ES_JAVA_HOME/bin/java&quot;</span><br><span class="line">else</span><br><span class="line">        JAVA=`which java`</span><br><span class="line">fi</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>修改内存  <code>config/jvm.options</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-Xms1024m</span><br><span class="line">-Xmx1024m</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="创建专用用户"><a href="#创建专用用户" class="headerlink" title="创建专用用户"></a>创建专用用户</h3><p>不能使用root启动，需要创建专用的用户。 <code>can not run elasticsearch as root</code> </p>
<ul>
<li>创建用户<blockquote>
<p>useradd esuser</p>
</blockquote>
</li>
<li>创建所属组<blockquote>
<p>chown esuser:esuser -R  elasticsearch-7.12.1</p>
</blockquote>
</li>
<li>切换用户<blockquote>
<p>su esuser</p>
</blockquote>
</li>
<li>启动<blockquote>
<p>.&#x2F;elasticsearch -d</p>
</blockquote>
</li>
</ul>
<h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>修改文件 elasticsearch.yml</p>
<ul>
<li><p>修改ip</p>
<blockquote>
<p>network.host: 0.0.0.0 </p>
</blockquote>
</li>
<li><p>初始化节点名称 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cluster.name: elasticsearch </span><br><span class="line">node.name: es-node0</span><br><span class="line">cluster.initial_master_nodes: [&quot;es-node0&quot;]</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><ul>
<li>max file descriptors [4096] for elasticsearch process is too low</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用root</span></span><br><span class="line">vi /etc/security/limits.conf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加</span></span><br><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 131072</span><br><span class="line">* soft nproc 2048</span><br><span class="line">* hard nproc 4096</span><br></pre></td></tr></table></figure>

<ul>
<li>max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</li>
</ul>
<p>elasticsearch用户拥有的内存权限太小，至少需要262144，解决办法：</p>
<p>vim &#x2F;etc&#x2F;sysctl.conf , 添加 </p>
<blockquote>
<p>vm.max_map_count&#x3D;262144</p>
</blockquote>
<p>保存，刷新配置  </p>
<p>sysctl -p</p>
<p>启动后，访问 <code>curl http://127.0.0.1:9200</code> 出现如下信息，说明成功</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;es-node0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;cluster_name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;elasticsearch&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;cluster_uuid&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;N_nV0k8hTXyGW1G1iZjTuw&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;number&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;7.12.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build_flavor&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;default&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build_type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;tar&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build_hash&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;3186837139b9c6b6d23c3200870651f10d3343b7&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build_date&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;2021-04-20T20:56:39.040728659Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build_snapshot&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;lucene_version&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;8.8.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;minimum_wire_compatibility_version&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;6.8.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;minimum_index_compatibility_version&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;6.0.0-beta1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tagline&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;You Know, for Search&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果使用ip无法访问的话，可以看下，是否是机器防火墙的问题。</p>
<h2 id="Kibana安装"><a href="#Kibana安装" class="headerlink" title="Kibana安装"></a>Kibana安装</h2><ol>
<li><p>下载</p>
<blockquote>
<p>wget <a href="https://artifacts.elastic.co/downloads/kibana/kibana-7.12.1-linux-x86_64.tar.gz">https://artifacts.elastic.co/downloads/kibana/kibana-7.12.1-linux-x86_64.tar.gz</a></p>
</blockquote>
</li>
<li><p>解压后修改权限</p>
</li>
</ol>
<blockquote>
<p>chown esuser:esuser -R kibana-7.12.1-linux-x86_64</p>
</blockquote>
<ol start="3">
<li>修改 <code>config/kibana.yml</code> 配置</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">server.port：http访问端口</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">server.host：ip地址，0.0.0.0表示可远程访问</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">server.name：kibana服务名</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">elasticsearch.hosts：elasticsearch地址</span></span><br><span class="line"></span><br><span class="line">server.port: 5601</span><br><span class="line">server.host: &quot;0.0.0.0&quot;</span><br><span class="line">server.name: &quot;kibana-test&quot;</span><br><span class="line">elasticsearch.hosts: [&quot;http://127.0.0.1:9200&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="4">
<li><p>启动</p>
<blockquote>
<p>nohup .&#x2F;kibana &amp;</p>
</blockquote>
</li>
<li><p>访问</p>
</li>
</ol>
<p>浏览器访问 <a href="http://ip:5601/">http://ip:5601</a> ， 能访问，说明成功。</p>
<ol start="6">
<li><p>可以在页面上添加 Sample data 进行测试</p>
</li>
<li><p>可以在discover 页面进行查询</p>
</li>
</ol>
<p><a href="http://localhost:5601/app/discover">http://localhost:5601/app/discover</a></p>
<h2 id="配置密码访问"><a href="#配置密码访问" class="headerlink" title="配置密码访问"></a>配置密码访问</h2><p>参考官方文档 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.12/security-minimal-setup.html#_prerequisites_10">security-minimal-setup</a></p>
<ol>
<li>Stop both Kibana and Elasticsearch if they are running</li>
<li>修改 <code>ES_PATH_CONF/elasticsearch.yml</code> 文件， 并设置为 true</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xpack.security.enabled: true </span><br><span class="line">xpack.security.transport.ssl.enabled: true</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>启动es， <code>./elasticsearch -d</code></li>
<li>生成随机密码 <code>./bin/elasticsearch-setup-passwords auto</code></li>
<li>设置密码之后， 不能二次执行 <code>elasticsearch-setup-passwords</code></li>
<li>修改 <code>KIB_PATH_CONF/kibana.yml</code> , 添加</li>
</ol>
<blockquote>
<p>elasticsearch.username: “kibana_system”</p>
</blockquote>
<ol start="7">
<li><p>Create the Kibana keystore</p>
<blockquote>
<p>.&#x2F;bin&#x2F;kibana-keystore create</p>
</blockquote>
</li>
<li><p>Add the password for the kibana_system user to the Kibana keystore</p>
<blockquote>
<p>.&#x2F;bin&#x2F;kibana-keystore add elasticsearch.password</p>
</blockquote>
</li>
<li><p>启动kibana</p>
</li>
</ol>
<h2 id="ES集群"><a href="#ES集群" class="headerlink" title="ES集群"></a>ES集群</h2><h3 id="集群安装"><a href="#集群安装" class="headerlink" title="集群安装"></a>集群安装</h3><p>因为本地机器有限，所以在同一台机器上进行集群的安装。</p>
<ol>
<li><p>将 elasticsearch-7.12.1-linux-x86_64.tar.gz 解压后复制成三份，分别修改对应的配置</p>
</li>
<li><p>配置信息如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">node-1</span></span><br><span class="line">cluster.initial_master_nodes: [&quot;node-1&quot;, &quot;node-2&quot;, &quot;node-3&quot;]</span><br><span class="line">cluster.name: es-cluster</span><br><span class="line">discovery.seed_hosts: [&quot;node-1:9205&quot;, &quot;node-2:9206&quot;, &quot;node-3:9207&quot;]</span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line">http.port: 9200</span><br><span class="line">node.name: node-1</span><br><span class="line">transport.port: 9205</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">node-2 前面几项一样</span></span><br><span class="line">http.port: 9201</span><br><span class="line">node.name: node-2</span><br><span class="line">transport.port: 9206</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">node-3</span></span><br><span class="line">http.port: 9202</span><br><span class="line">node.name: node-2</span><br><span class="line">transport.port: 9207</span><br></pre></td></tr></table></figure></li>
<li><p>修改 hosts 中映射</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">10.1.40.136 node-1</span><br><span class="line">10.1.40.136 node-2</span><br><span class="line">10.1.40.136 node-3</span><br></pre></td></tr></table></figure>
</li>
<li><p>调整 jvm.options 内存，按实际调整</p>
</li>
<li><p>分别启动各个node，观察启动日志和状态。</p>
</li>
<li><p>查看集群是否启动成功</p>
<blockquote>
<p>curl <a href="http://localhost:9202/_cat/nodes?v">http://localhost:9202/_cat/nodes?v</a></p>
</blockquote>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip          heap.percent ram.percent cpu load_1m load_5m load_15m node.role   master name</span><br><span class="line">10.1.40.136           54          70   2    0.05    0.05     0.05 cdfhilmrstw *      node-1</span><br><span class="line">10.1.40.136           25          70   2    0.05    0.05     0.05 cdfhilmrstw -      node-2</span><br><span class="line">10.1.40.136           30          70   2    0.05    0.05     0.05 cdfhilmrstw -      node-3</span><br><span class="line"></span><br><span class="line">* 表示是 master 节点</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="7">
<li>查看健康情况</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl http://localhost:9202/_cat/health?v</span><br><span class="line"></span><br><span class="line">epoch      timestamp cluster    status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent</span><br><span class="line">1739178458 09:07:38  es-cluster green           3         3     42  18    0    0        0             0                  -                100.0%</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="集群监控"><a href="#集群监控" class="headerlink" title="集群监控"></a>集群监控</h4><p>推荐使用cerebro来监控es集群状态，官方网址：<a href="https://github.com/lmenezes/cerebro">https://github.com/lmenezes/cerebro</a> </p>
<p>需要JDK11以上，<a href="https://cfdownload.adobe.com/pub/adobe/coldfusion/java/java11/java11026/jdk-11.0.26_linux-x64_bin.tar.gz">下载地址</a> 。</p>
<h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><blockquote>
<p>创建索引库的时候需要设置分片数量（其他还有多少个ES服务在该集群）以及副本数量（本服务的数据拷贝几份）</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PUT /testshard</span><br><span class="line">&#123;</span><br><span class="line">  &quot;settings&quot;: &#123;</span><br><span class="line">    &quot;number_of_shards&quot;: 3, // 分片数量</span><br><span class="line">    &quot;number_of_replicas&quot;: 1 // 副本数量</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      // mapping映射定义 ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以在监控上查看分片效果</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205174428188-794591883.png" alt="image"></p>
<h3 id="集群脑裂问题"><a href="#集群脑裂问题" class="headerlink" title="集群脑裂问题"></a>集群脑裂问题</h3><blockquote>
<p>master eligible节点的作用是什么？</p>
<ul>
<li>参与集群选主</li>
<li>主节点可以管理集群状态、管理分片信息、处理创建和删除索引库的请求</li>
</ul>
<p>data节点的作用是什么？</p>
<ul>
<li>数据的CRUD</li>
</ul>
<p>coordinator节点的作用是什么？</p>
<ul>
<li><p>路由请求到其它节点</p>
</li>
<li><p>合并查询到的结果，返回给用户</p>
</li>
</ul>
</blockquote>
<h4 id="集群职责划分"><a href="#集群职责划分" class="headerlink" title="集群职责划分"></a>集群职责划分</h4><blockquote>
<p>通过改变配置文件中的 true——&gt; false 来改变职责。如data数据职责节点就只保留data为true其他为false</p>
<p>注意：每个节点都是路由，这样可以保证不管哪个节点接收到请求可以分给其他人已经从其他人那接收信息。</p>
</blockquote>
<p>elasticsearch中集群节点有不同的职责划分：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205174437248-89466588.png" alt="image"></p>
<p>默认情况下，集群中的任何一个节点都同时具备上述四种角色。</p>
<p>但是真实的集群一定要将集群职责分离：（因为不同职责对CPU要求不同）</p>
<ul>
<li>master节点：对CPU要求高，但是内存要求低</li>
<li>data节点：对CPU和内存要求都高</li>
<li>coordinating节点：对网络带宽、CPU要求高</li>
</ul>
<p>职责分离可以让我们根据不同节点的需求分配不同的硬件去部署。而且避免业务之间的互相干扰。</p>
<p>一个典型的es集群职责划分如图：<br><img data-src="/hexoblog/images/java/es/2729274-20230205174442439-1069765383.png" alt="image"></p>
<h4 id="脑裂问题"><a href="#脑裂问题" class="headerlink" title="脑裂问题"></a>脑裂问题</h4><blockquote>
<p>ES 7.0后默认配置了 <strong>( eligible节点数量 + 1 ）&#x2F; 2</strong> 来解决脑裂问题</p>
</blockquote>
<p>脑裂是因为集群中的节点失联导致的。</p>
<p>例如一个集群中，主节点与其它节点失联：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205174447612-1377452674.png" alt="image"></p>
<p>此时，node2和node3认为node1宕机，就会重新选主：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205174453080-1677763578.png" alt="image"></p>
<p>当node3当选后，集群继续对外提供服务，node2和node3自成集群，node1自成集群，两个集群数据不同步，出现数据差异。</p>
<p>当网络恢复后，因为集群中有两个master节点，集群状态的不一致，出现脑裂的情况：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205174457820-447955706.png" alt="image"></p>
<p>解决脑裂的方案是，要求选票超过 <strong>( eligible节点数量 + 1 ）&#x2F; 2</strong> 才能当选为主，因此eligible节点数量最好是奇数。对应配置项是discovery.zen.minimum_master_nodes，在es7.0以后，已经成为默认配置，因此一般不会发生脑裂问题</p>
<p>例如：3个节点形成的集群，选票必须超过 （3 + 1） &#x2F; 2 ，也就是2票。node3得到node2和node3的选票，当选为主。node1只有自己1票，没有当选。集群中依然只有1个主节点，没有出现脑裂。</p>
<h3 id="集群分布式存储"><a href="#集群分布式存储" class="headerlink" title="集群分布式存储"></a>集群分布式存储</h3><p>当新增文档时，应该保存到不同分片，保证数据均衡，那么coordinating node如何确定数据该存储到哪个分片呢？</p>
<p>多插入几条数据，然后进行查询，可以看到数据分布在不同的分片上</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /testshard1/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;explain&quot;: true, </span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;hits&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;_shard&quot;: &quot;[testshard1][0]&quot;,</span><br><span class="line">            &quot;_node&quot;: &quot;cM_rO9NtQQCA6EKgrsTtbw&quot;,</span><br><span class="line">            &quot;_index&quot;: &quot;testshard1&quot;,</span><br><span class="line">            &quot;_type&quot;: &quot;_doc&quot;,</span><br><span class="line">            &quot;_id&quot;: &quot;5&quot;,</span><br><span class="line">            &quot;_score&quot;: 1.0,</span><br><span class="line">            &quot;_source&quot;: &#123;</span><br><span class="line">                &quot;info&quot;: &quot;我是一个测试语句&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;_shard&quot;: &quot;[testshard1][1]&quot;,</span><br><span class="line">            &quot;_node&quot;: &quot;WZT09pJTRrC2SLof6wlPVw&quot;,</span><br><span class="line">            &quot;_index&quot;: &quot;testshard1&quot;,</span><br><span class="line">            &quot;_type&quot;: &quot;_doc&quot;,</span><br><span class="line">            &quot;_id&quot;: &quot;2&quot;,</span><br><span class="line">            &quot;_score&quot;: 1.0,</span><br><span class="line">            &quot;_source&quot;: &#123;</span><br><span class="line">                &quot;info&quot;: &quot;我是一个测试语句&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="分片存储原理"><a href="#分片存储原理" class="headerlink" title="分片存储原理"></a>分片存储原理</h4><p>elasticsearch会通过hash算法来计算文档应该存储到哪个分片：</p>
<blockquote>
<p>shard &#x3D; hash(_routing) % number_of_shards</p>
</blockquote>
<p>说明：</p>
<ul>
<li>_routing默认是文档的id</li>
<li>算法与分片数量有关，因此索引库一旦创建，分片数量不能修改！</li>
</ul>
<p>新增文档的流程如下：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205174551794-1811444061.png" alt="image"></p>
<p>解读：</p>
<ul>
<li>1）新增一个id&#x3D;1的文档</li>
<li>2）对id做hash运算，假如得到的是2，则应该存储到shard-2</li>
<li>3）shard-2的主分片在node3节点，将数据路由到node3</li>
<li>4）保存文档</li>
<li>5）同步给shard-2的副本replica-2，在node2节点</li>
<li>6）返回结果给coordinating-node节点</li>
</ul>
<h4 id="集群分布式查询"><a href="#集群分布式查询" class="headerlink" title="集群分布式查询"></a>集群分布式查询</h4><p><strong>原理：</strong></p>
<p>elasticsearch的查询分成两个阶段：</p>
<ul>
<li><p>scatter phase：分散阶段，coordinating node会把请求分发到每一个分片</p>
</li>
<li><p>gather phase：聚集阶段，coordinating node汇总data node的搜索结果，并处理为最终结果集返回给用户</p>
</li>
</ul>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205174557427-1969761296.png" alt="image"></p>
<h4 id="集群故障转移"><a href="#集群故障转移" class="headerlink" title="集群故障转移"></a>集群故障转移</h4><blockquote>
<p>ES本身已经配置好了有集群故障转移，不需要我们再去配置</p>
</blockquote>
<p>集群的master节点会监控集群中的节点状态，如果发现有节点宕机，会立即将宕机节点的分片数据迁移到其它节点，确保数据安全，这个叫做故障转移。</p>
<p>1）例如一个集群结构如图：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205174602086-492617752.png" alt="image"></p>
<p>现在，node1是主节点，其它两个节点是从节点。</p>
<p>2）突然，node1发生了故障：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205174607756-480992428.png" alt="image"></p>
<p>宕机后的第一件事，需要重新选主，例如选中了node2：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205174612261-197593780.png" alt="image"></p>
<p>node2成为主节点后，会检测集群监控状态，发现：shard-1、shard-0没有副本节点。因此需要将node1上的数据迁移到node2、node3：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205174617803-1364879576.png" alt="image"></p>
<h2 id="安装分词器"><a href="#安装分词器" class="headerlink" title="安装分词器"></a>安装分词器</h2><ol>
<li>下载地址  <a href="https://release.infinilabs.com/analysis-ik/stable/">https://release.infinilabs.com/analysis-ik/stable/</a></li>
</ol>
<p>可以在线安装，或者离线下载后解压到plugins目录下面</p>
<ul>
<li>在线安装<blockquote>
<p>.&#x2F;elasticsearch-plugin  install <a href="https://release.infinilabs.com/analysis-ik/stable/elasticsearch-analysis-ik-7.12.1.zip">https://release.infinilabs.com/analysis-ik/stable/elasticsearch-analysis-ik-7.12.1.zip</a></p>
</blockquote>
</li>
</ul>
<p>如果是集群的ES，需要每个node下都安装一遍。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>IK分词器包含两种模式：</p>
<ul>
<li><p><code>ik_smart</code>：最少切分</p>
</li>
<li><p><code>ik_max_word</code>：最细切分</p>
</li>
</ul>
<p>在kibana的Dev tools中输入以下代码：</p>
<blockquote>
<p>”analyzer“ 就是选择分词器模式</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_analyze</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;黑马程序员学习java太棒了&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;tokens&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;token&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;黑马&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> <span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> <span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;CN_WORD&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;position&quot;</span> <span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;token&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;程序员&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> <span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> <span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;CN_WORD&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;position&quot;</span> <span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;token&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;程序&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> <span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> <span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;CN_WORD&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;position&quot;</span> <span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;token&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;员&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> <span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> <span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;CN_CHAR&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;position&quot;</span> <span class="punctuation">:</span> <span class="number">3</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;token&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;学习&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> <span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> <span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;CN_WORD&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;position&quot;</span> <span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;token&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;java&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> <span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> <span class="punctuation">:</span> <span class="number">11</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;ENGLISH&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;position&quot;</span> <span class="punctuation">:</span> <span class="number">5</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;token&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;太棒了&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> <span class="punctuation">:</span> <span class="number">11</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> <span class="punctuation">:</span> <span class="number">14</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;CN_WORD&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;position&quot;</span> <span class="punctuation">:</span> <span class="number">6</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;token&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;太棒&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> <span class="punctuation">:</span> <span class="number">11</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> <span class="punctuation">:</span> <span class="number">13</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;CN_WORD&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;position&quot;</span> <span class="punctuation">:</span> <span class="number">7</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;token&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;了&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> <span class="punctuation">:</span> <span class="number">13</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> <span class="punctuation">:</span> <span class="number">14</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;CN_CHAR&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;position&quot;</span> <span class="punctuation">:</span> <span class="number">8</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="扩展词词典"><a href="#扩展词词典" class="headerlink" title="扩展词词典"></a>扩展词词典</h3><p>随着互联网的发展，“造词运动”也越发的频繁。出现了很多新的词语，在原有的词汇列表中并不存在。比如：“奥力给”，“白嫖” 等。</p>
<p>所以我们的词汇也需要不断的更新，IK分词器提供了扩展词汇的功能。</p>
<p>1）打开IK分词器目录  config&#x2F;analysis-ik：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205172005673-1129389907.png" alt="image"></p>
<p>2）在IKAnalyzer.cfg.xml配置文件内容添加：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">properties</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://java.sun.com/dtd/properties.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">comment</span>&gt;</span>IK Analyzer 扩展配置<span class="tag">&lt;/<span class="name">comment</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--用户可以在这里配置自己的扩展字典 *** 添加扩展词典--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_dict&quot;</span>&gt;</span>ext.dic<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3）新建一个 <code>ext.dic</code>，可以参考config目录下复制一个配置文件进行修改</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">白嫖</span></span><br><span class="line"><span class="attr">奥力给</span></span><br></pre></td></tr></table></figure>

<p>4）重启elasticsearch， 查看日志中的加载情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[2025-01-17T14:38:30,348][INFO ][o.w.a.d.Dictionary       ] [es-node0] try load config from /usr/local/elasticsearch/elasticsearch-7.12.1/config/analysis-ik/IKAnalyzer.cfg.xml</span><br><span class="line">[2025-01-17T14:38:30,500][INFO ][o.w.a.d.Dictionary       ] [es-node0] [Dict Loading] /usr/local/elasticsearch/elasticsearch-7.12.1/config/analysis-ik/ext.dic</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑</p>
</blockquote>
<h3 id="停用词词典"><a href="#停用词词典" class="headerlink" title="停用词词典"></a>停用词词典</h3><p>在互联网项目中，在网络间传输的速度很快，所以很多语言是不允许在网络上传递的，如：关于宗教、政治等敏感词语，那么我们在搜索时也应该忽略当前词汇。</p>
<p>IK分词器也提供了强大的停用词功能，让我们在索引时就直接忽略当前的停用词汇表中的内容。</p>
<p>1）IKAnalyzer.cfg.xml配置文件内容添加：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_stopwords&quot;</span>&gt;</span>stopword.dic<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2）在 stopword.dic 添加停用词</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">傻逼</span></span><br><span class="line"><span class="attr">艹</span></span><br></pre></td></tr></table></figure>

<p>3）重启elasticsearch</p>
<p>4）测试效果</p>
<p><strong>参考文章</strong></p>
<ol>
<li><a href="https://www.cnblogs.com/buchizicai/p/17093719.html">ElasticSearch (ES从入门到精通一篇就够了)</a></li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>elascitsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>ES-RestAPI的使用</title>
    <url>/hexoblog/java/es/es-03-rest-api/</url>
    <content><![CDATA[<p>RestAPI的使用 <a href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/7.12/java-rest-high.html">Java High Level REST Client 7.12</a></p>
<p>需要注意的是， 此api对应的es版本为7.12.1，目前此api已被官方标记为deprecated，如果使用新的es版本的话，需要使用新的api <a href="https://www.elastic.co/guide/en/elasticsearch/client/index.html">java-api-client</a> 。</p>
<span id="more"></span>


<h1 id="API操作索引库"><a href="#API操作索引库" class="headerlink" title="API操作索引库"></a>API操作索引库</h1><blockquote>
<p>JavaRestClient操作elasticsearch的流程基本类似。核心是client.indices()方法来获取索引库的操作对象。</p>
<p>索引库操作的基本步骤：【可以根据发送请求那步的第一个参数，来判断需要创建什么XXXXRequest】</p>
<ul>
<li>初始化RestHighLevelClient</li>
<li>创建XxxIndexRequest。XXX是Create、Get、Delete</li>
<li>准备DSL（ Create时需要，其它是无参）</li>
<li>发送请求。调用RestHighLevelClient#indices().xxx()方法，xxx是create、exists、delete</li>
</ul>
</blockquote>
<h2 id="mapping映射分析"><a href="#mapping映射分析" class="headerlink" title="mapping映射分析"></a>mapping映射分析</h2><blockquote>
<p><strong>根据MySQL数据库表结构（建表语句），去写索引库结构JSON。表和索引库一一对应</strong></p>
<p><strong>注意</strong>：地理坐标、组合字段。索引库里的地理坐标是一个字段：<code>坐标：维度,精度</code> 。copy_to组合字段作用是供用户查询（输入关键字可以查询多个字段）</p>
</blockquote>
<p>创建索引库，最关键的是mapping映射，而mapping映射要考虑的信息包括：</p>
<ul>
<li>字段名</li>
<li>字段数据类型</li>
<li>是否参与搜索</li>
<li>是否需要分词</li>
<li>如果分词，分词器是什么？</li>
</ul>
<p>其中：</p>
<ul>
<li>字段名、字段数据类型，可以参考数据表结构的名称和类型</li>
<li>是否参与搜索要分析业务来判断，例如图片地址，就无需参与搜索</li>
<li>是否分词呢要看内容，内容如果是一个整体就无需分词，反之则要分词</li>
<li>分词器，我们可以统一使用ik_max_word</li>
</ul>
<p>来看下酒店数据的索引库结构:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /hotel</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;copy_to&quot;</span><span class="punctuation">:</span> <span class="string">&quot;all&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;score&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;copy_to&quot;</span><span class="punctuation">:</span> <span class="string">&quot;all&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;copy_to&quot;</span><span class="punctuation">:</span> <span class="string">&quot;all&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;starName&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;business&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;location&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;geo_point&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;pic&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;all&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>几个特殊字段说明：</p>
<ul>
<li>location：地理坐标，里面包含精度、纬度</li>
<li>all：一个组合字段，其目的是将多字段的值 利用copy_to合并，提供给用户搜索</li>
</ul>
<p>地理坐标说明：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205172124085-626335563.png" alt="image"></p>
<p>copy_to说明：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205172128097-289087887.png" alt="image"></p>
<h2 id="初始化RestClient"><a href="#初始化RestClient" class="headerlink" title="初始化RestClient"></a>初始化RestClient</h2><p>在elasticsearch提供的API中，与elasticsearch一切交互都封装在一个名为RestHighLevelClient的类中，必须先完成这个对象的初始化，建立与elasticsearch的连接。</p>
<p>分为三步：</p>
<p>1）引入es的RestHighLevelClient依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.12.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2）初始化RestHighLevelClient：这里一般在启动类或者配置类里注入该Bean，用于告诉Java 访问ES的ip地址</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">RestHighLevelClient client;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    client = <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(</span><br><span class="line">    RestClient.builder(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HttpHost</span>(<span class="string">&quot;10.1.40.136&quot;</span>, <span class="number">9200</span>, <span class="string">&quot;http&quot;</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="索引库CRUD"><a href="#索引库CRUD" class="headerlink" title="索引库CRUD"></a>索引库CRUD</h2><h3 id="创建索引库"><a href="#创建索引库" class="headerlink" title="创建索引库"></a>创建索引库</h3><blockquote>
<p>代码分为三步：</p>
<ul>
<li>1）创建Request对象。因为是创建索引库的操作，因此Request是CreateIndexRequest。</li>
<li>2）添加请求参数，其实就是DSL的JSON参数部分。因为json字符串很长，这里是定义了静态字符串常量MAPPING_TEMPLATE，让代码看起来更加优雅。</li>
<li>3）发送请求，client.indices()方法的返回值是IndicesClient类型，封装了所有与索引库操作有关的方法。</li>
</ul>
</blockquote>
<p>创建索引库的API如下：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205172138463-1252488196.png" alt="image"></p>
<p>单元测试的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createHotelIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request对象</span></span><br><span class="line">    <span class="type">CreateIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateIndexRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备请求的参数：DSL语句 , json 内容为上面 PUT /hotel 中的json内容</span></span><br><span class="line">    request.source(json, XContentType.JSON);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">CreateIndexResponse</span> <span class="variable">createIndexResponse</span> <span class="operator">=</span> client.indices().create(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 重复创建会报错</span></span><br><span class="line">    log.info(<span class="string">&quot;创建索引的结果为 &#123;&#125;&quot;</span>, createIndexResponse.isAcknowledged());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="删除索引库"><a href="#删除索引库" class="headerlink" title="删除索引库"></a>删除索引库</h3><blockquote>
<p>三步走：</p>
<ul>
<li>1）创建Request对象。这次是DeleteIndexRequest对象</li>
<li>2）准备参数。这里是无参</li>
<li>3）发送请求。改用delete方法</li>
</ul>
</blockquote>
<p>删除索引库的DSL语句非常简单：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">DELETE /hotel</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteHotelIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request对象</span></span><br><span class="line">    <span class="type">DeleteIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteIndexRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    <span class="type">AcknowledgedResponse</span> <span class="variable">acknowledgedResponse</span> <span class="operator">=</span> client.indices().delete(request, RequestOptions.DEFAULT);</span><br><span class="line">    log.info(<span class="string">&quot;删除索引的结果为 &#123;&#125;&quot;</span>, acknowledgedResponse.isAcknowledged());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="查询索引库"><a href="#查询索引库" class="headerlink" title="查询索引库"></a>查询索引库</h3><blockquote>
<p>三步走：</p>
<ul>
<li>1）创建Request对象。这次是GetIndexRequest对象</li>
<li>2）准备参数。这里是无参</li>
<li>3）发送请求。改用exists方法</li>
</ul>
</blockquote>
<p>判断索引库是否存在，本质就是查询，对应的DSL是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /hotel</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testExistsHotelIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request对象</span></span><br><span class="line">    <span class="type">GetIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetIndexRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> client.indices().exists(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 3.输出</span></span><br><span class="line">    log.info(<span class="string">&quot;索引是否存在 &#123;&#125;&quot;</span>, exists);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="API操作文档"><a href="#API操作文档" class="headerlink" title="API操作文档"></a>API操作文档</h1><blockquote>
<p>这里更多的是先读取Mysql中的数据，然后再存进ES中。</p>
<p>文档操作的基本步骤：【可以根据发送请求那步的第一个参数，反过来判断需要创建什么XXXXRequest】</p>
<ul>
<li>初始化RestHighLevelClient</li>
<li>创建XxxRequest。XXX是Index、Get、Update、Delete、Bulk</li>
<li>准备参数（Index、Update、Bulk时需要）</li>
<li>发送请求。调用RestHighLevelClient#.xxx()方法，xxx是index、get、update、delete、bulk</li>
<li>解析结果（Get时需要）</li>
</ul>
</blockquote>
<p>初始化<code>RestHighLevelClient</code> 的操作和索引库的一样。</p>
<h2 id="批量导入文档"><a href="#批量导入文档" class="headerlink" title="批量导入文档"></a>批量导入文档</h2><blockquote>
<p>三步走：</p>
<ul>
<li>1）创建Request对象。这里是BulkRequest</li>
<li>2）准备参数。批处理的参数，就是其它Request对象，这里就是多个IndexRequest</li>
<li>3）发起请求。这里是批处理，调用的方法为client.bulk()方法</li>
</ul>
</blockquote>
<p>案例需求：利用BulkRequest批量将数据库数据导入到索引库中。</p>
<p>步骤如下：</p>
<ul>
<li>利用mybatis-plus查询酒店数据</li>
<li>将查询到的酒店数据（Hotel）转换为文档类型数据（HotelDoc）</li>
<li>利用JavaRestClient中的BulkRequest批处理，实现批量新增文档</li>
</ul>
<p><strong>语法说明：</strong></p>
<p>批量处理BulkRequest，其本质就是将多个普通的CRUD请求组合在一起发送。</p>
<p>其中提供了一个add方法，用来添加其他请求：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205172220573-1990074801.png" alt="image"></p>
<p>可以看到，能添加的请求包括：</p>
<ul>
<li>IndexRequest，也就是新增</li>
<li>UpdateRequest，也就是修改</li>
<li>DeleteRequest，也就是删除</li>
</ul>
<p>因此Bulk中添加了多个IndexRequest，就是批量新增功能了。示例：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205172227358-759338253.png" alt="image"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBulk</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">BulkRequest</span> <span class="variable">bulkRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BulkRequest</span>();</span><br><span class="line">    bulkRequest.add(<span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;testcrud&quot;</span>).id(<span class="string">&quot;2&quot;</span>).source(<span class="string">&quot;&#123;\&quot;age\&quot;:10,\&quot;info\&quot;:\&quot;我是中国人\&quot;&#125;&quot;</span>, XContentType.JSON));</span><br><span class="line">    bulkRequest.add(<span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;testcrud&quot;</span>).id(<span class="string">&quot;3&quot;</span>).source(<span class="string">&quot;&#123;\&quot;age\&quot;:15,\&quot;info\&quot;:\&quot;这是一段测试的文本内容\&quot;&#125;&quot;</span>, XContentType.JSON));</span><br><span class="line">    <span class="type">BulkResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.bulk(bulkRequest, RequestOptions.DEFAULT);</span><br><span class="line">    log.info(<span class="string">&quot;批量添加文档的结果 &#123;&#125;&quot;</span>, Arrays.stream(response.getItems()).collect(Collectors.toMap(BulkItemResponse::getId, BulkItemResponse::status)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="批量新增文档"><a href="#批量新增文档" class="headerlink" title="批量新增文档"></a>批量新增文档</h2><blockquote>
<p>四步走：</p>
<ul>
<li>0）创建索引库实体类</li>
<li>1）创建Request对象</li>
<li>2）准备请求参数，也就是DSL中的JSON文档</li>
<li>3）发送请求 （注意：这里直接使用client.xxx()的API，不再需要client.indices()了）</li>
</ul>
</blockquote>
<p>我们要将数据库的酒店数据查询出来，写入elasticsearch中。</p>
<p><strong>1）创建索引库实体类</strong></p>
<blockquote>
<p>一般实体类里包含经纬度都需要创建一个新的实体类，将经纬度拼成一个字段</p>
</blockquote>
<p>数据库查询后的结果是一个Hotel类型的对象。结构如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;tb_hotel&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hotel</span> &#123;</span><br><span class="line">    <span class="meta">@TableId(type = IdType.INPUT)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String starName;</span><br><span class="line">    <span class="keyword">private</span> String business;</span><br><span class="line">    <span class="keyword">private</span> String longitude;</span><br><span class="line">    <span class="keyword">private</span> String latitude;</span><br><span class="line">    <span class="keyword">private</span> String pic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>与我们的索引库结构存在差异：</p>
<ul>
<li>longitude和latitude需要合并为location</li>
</ul>
<p>因此，我们需要定义一个新的类型，与索引库结构吻合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelDoc</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String starName;</span><br><span class="line">    <span class="keyword">private</span> String business;</span><br><span class="line">    <span class="keyword">private</span> String location;</span><br><span class="line">    <span class="keyword">private</span> String pic;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HotelDoc</span><span class="params">(Hotel hotel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = hotel.getId();</span><br><span class="line">        <span class="built_in">this</span>.name = hotel.getName();</span><br><span class="line">        <span class="built_in">this</span>.address = hotel.getAddress();</span><br><span class="line">        <span class="built_in">this</span>.price = hotel.getPrice();</span><br><span class="line">        <span class="built_in">this</span>.score = hotel.getScore();</span><br><span class="line">        <span class="built_in">this</span>.brand = hotel.getBrand();</span><br><span class="line">        <span class="built_in">this</span>.city = hotel.getCity();</span><br><span class="line">        <span class="built_in">this</span>.starName = hotel.getStarName();</span><br><span class="line">        <span class="built_in">this</span>.business = hotel.getBusiness();</span><br><span class="line">        <span class="built_in">this</span>.location = hotel.getLatitude() + <span class="string">&quot;, &quot;</span> + hotel.getLongitude();</span><br><span class="line">        <span class="built_in">this</span>.pic = hotel.getPic();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>2）新增代码</strong></p>
<p>新增文档的DSL语句如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /<span class="punctuation">&#123;</span>索引库名<span class="punctuation">&#125;</span>/_doc/<span class="number">1</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Jack&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">21</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>对应的java代码如图：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205172259030-1988634807.png" alt="image"></p>
<p>我们导入酒店数据，基本流程一致，但是需要考虑几点变化：</p>
<ul>
<li>酒店数据来自于数据库，我们需要先查询出来，得到hotel对象</li>
<li>hotel对象需要转为HotelDoc对象</li>
<li>HotelDoc需要序列化为json格式</li>
</ul>
<h2 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h2><blockquote>
<p>查询文档是根据id查询的，所以没有批量查询</p>
<p>三步走：</p>
<ul>
<li>1）准备Request对象。这次是查询，所以是GetRequest</li>
<li>2）发送请求，得到结果。因为是查询，这里调用client.get()方法</li>
<li>3）解析结果，就是对JSON做反序列化</li>
</ul>
</blockquote>
<p>查询的DSL语句如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /hotel/_doc/<span class="punctuation">&#123;</span>id<span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>非常简单，因此代码大概分两步：</p>
<ul>
<li>准备Request对象</li>
<li>发送请求</li>
</ul>
<p>不过查询的目的是得到结果，解析为HotelDoc，因此难点是结果的解析。完整代码如下：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205172309780-381577770.png" alt="image"></p>
<p>可以看到，结果是一个JSON，其中文档放在一个<code>_source</code>属性中，因此解析就是拿到<code>_source</code>，使用工具反序列化为Java对象即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetDocumentById</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 查询文档</span></span><br><span class="line">    <span class="type">GetRequest</span> <span class="variable">getRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetRequest</span>(<span class="string">&quot;testcrud&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">    <span class="type">GetResponse</span> <span class="variable">getResponse</span> <span class="operator">=</span> client.get(getRequest, RequestOptions.DEFAULT);</span><br><span class="line">    log.info(<span class="string">&quot;查询文档的结果为 &#123;&#125;&quot;</span>, getResponse.getSourceAsString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="批量删除文档"><a href="#批量删除文档" class="headerlink" title="批量删除文档"></a>批量删除文档</h2><blockquote>
<p>三步走：</p>
<ul>
<li>1）准备Request对象，因为是删除，这次是DeleteRequest对象。要指定索引库名和id</li>
<li>2）准备参数，无参</li>
<li>3）发送请求。因为是删除，所以是client.delete()方法</li>
</ul>
</blockquote>
<p>删除的DSL为是这样的：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">DELETE /hotel/_doc/<span class="punctuation">&#123;</span>id<span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteDocumentById</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 删除文档</span></span><br><span class="line">    <span class="type">DeleteRequest</span> <span class="variable">deleteRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteRequest</span>(<span class="string">&quot;testcrud&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">    <span class="type">DeleteResponse</span> <span class="variable">deleteResponse</span> <span class="operator">=</span> client.delete(deleteRequest, RequestOptions.DEFAULT);</span><br><span class="line">    log.info(<span class="string">&quot;删除文档的结果为 &#123;&#125;&quot;</span>, deleteResponse.status());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="批量修改文档"><a href="#批量修改文档" class="headerlink" title="批量修改文档"></a>批量修改文档</h2><blockquote>
<p>三步走：</p>
<ul>
<li>1）准备Request对象。这次是修改，所以是UpdateRequest</li>
<li>2）准备参数。也就是JSON文档，里面包含要修改的字段</li>
<li>3）更新文档。这里调用client.update()方法</li>
</ul>
</blockquote>
<p>修改有两种方式：</p>
<ul>
<li>全量修改：本质是先根据id删除，再新增</li>
<li>增量修改：修改文档中的指定字段值</li>
</ul>
<p>在RestClient的API中，全量修改与新增的API完全一致，判断依据是ID：</p>
<ul>
<li>如果新增时，ID已经存在，则修改</li>
<li>如果新增时，ID不存在，则新增</li>
</ul>
<p><strong>只演示增量修改：</strong></p>
<p>代码示例如图：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205172320621-611636092.png" alt="image"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdateDocumentById</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 修改文档</span></span><br><span class="line">    <span class="type">UpdateRequest</span> <span class="variable">updateRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UpdateRequest</span>(<span class="string">&quot;testcrud&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Map&lt;String, String&gt; nameMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    nameMap.put(<span class="string">&quot;firstName&quot;</span>, <span class="string">&quot;三&quot;</span>);</span><br><span class="line">    nameMap.put(<span class="string">&quot;lastName&quot;</span>, <span class="string">&quot;张&quot;</span>);</span><br><span class="line">    updateRequest.doc(</span><br><span class="line">            <span class="string">&quot;info&quot;</span>, <span class="string">&quot;测试下name&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>, nameMap</span><br><span class="line">    );</span><br><span class="line">    <span class="type">UpdateResponse</span> <span class="variable">updateResponse</span> <span class="operator">=</span> client.update(updateRequest, RequestOptions.DEFAULT);</span><br><span class="line">    log.info(<span class="string">&quot;更新文档的结果为 &#123;&#125;&quot;</span>, updateResponse.status().getStatus());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="API查询文档"><a href="#API查询文档" class="headerlink" title="API查询文档"></a>API查询文档</h1><p>文档的查询同样适用 RestHighLevelClient对象，基本步骤包括：</p>
<ul>
<li>1）准备Request对象</li>
<li>2）准备请求参数</li>
<li>3）发起请求</li>
<li>4）解析响应</li>
</ul>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>查询的基本步骤是：</p>
<blockquote>
<p>查询的基本步骤是：</p>
<ol>
<li><p>创建SearchRequest对象</p>
</li>
<li><p>准备Request.source()，也就是DSL。</p>
<p>① QueryBuilders来构建查询条件</p>
<p>② 传入Request.source() 的 query() 方法</p>
</li>
<li><p>发送请求，得到结果</p>
</li>
<li><p>解析结果（参考JSON结果，从外到内，逐层解析）</p>
</li>
</ol>
</blockquote>
<h3 id="发送查询请求"><a href="#发送查询请求" class="headerlink" title="发送查询请求"></a>发送查询请求</h3><p><img data-src="/hexoblog/images/java/es/2729274-20230205173800773-301602834.png" alt="image"></p>
<p>代码解读：</p>
<ul>
<li><p>第一步，创建<code>SearchRequest</code>对象，指定索引库名</p>
</li>
<li><p>第二步，利用<code>request.source()</code>构建DSL，DSL中可以包含查询、分页、排序、高亮等</p>
<ul>
<li><code>query()</code>：代表查询条件，利用<code>QueryBuilders.matchAllQuery()</code>构建一个match_all查询的DSL</li>
</ul>
</li>
<li><p>第三步，利用client.search()发送请求，得到响应</p>
</li>
</ul>
<p>这里关键的API有两个，一个是<code>request.source()</code>，其中包含了查询、排序、分页、高亮等所有功能：</p>
<p>另一个是<code>QueryBuilders</code>，其中包含match、term、function_score、bool等各种查询：</p>
<h3 id="解析响应结果"><a href="#解析响应结果" class="headerlink" title="解析响应结果"></a>解析响应结果</h3><p>响应结果的解析：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205173819239-1577366921.png" alt="image"></p>
<p>elasticsearch返回的结果是一个JSON字符串，结构包含：</p>
<ul>
<li><code>hits</code>：命中的结果<ul>
<li><code>total</code>：总条数，其中的value是具体的总条数值</li>
<li><code>max_score</code>：所有结果中得分最高的文档的相关性算分</li>
<li><code>hits</code>：搜索结果的文档数组，其中的每个文档都是一个json对象<ul>
<li><code>_source</code>：文档中的原始数据，也是json对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>因此，我们解析响应结果，就是逐层解析JSON字符串，流程如下：</p>
<ul>
<li><code>SearchHits</code>：通过response.getHits()获取，就是JSON中的最外层的hits，代表命中的结果<ul>
<li><code>SearchHits#getTotalHits().value</code>：获取总条数信息</li>
<li><code>SearchHits#getHits()</code>：获取SearchHit数组，也就是文档数组<ul>
<li><code>SearchHit#getSourceAsString()</code>：获取文档结果中的_source，也就是原始的json文档数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="设置查询条件"><a href="#设置查询条件" class="headerlink" title="设置查询条件"></a>设置查询条件</h2><h3 id="全文检索查询"><a href="#全文检索查询" class="headerlink" title="全文检索查询"></a>全文检索查询</h3><p>全文检索的match和multi_match查询与match_all的API基本一致。差别是查询条件，也就是query的部分。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">全量查询</span></span><br><span class="line">GET /testcrud/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">match 查询 keyword</span></span><br><span class="line">GET /testcrud/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;city&quot;: &quot;上海市&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">multi_match 查询</span></span><br><span class="line">GET /testcrud/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;multi_match&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &quot;上海市&quot;,</span><br><span class="line">      &quot;fields&quot;: [&quot;address&quot;, &quot; city&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因此，Java代码上的差异主要是 <code>request.source().query()</code> 中的参数了。同样是利用QueryBuilders提供的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;kibana_sample_data_flights&quot;</span>);</span><br><span class="line"><span class="comment">// 单字段查询</span></span><br><span class="line">request.source().query(QueryBuilders.matchQuery(<span class="string">&quot;OriginWeather&quot;</span>, <span class="string">&quot;Sunny&quot;</span>));</span><br><span class="line"><span class="comment">// 多字段查询</span></span><br><span class="line">request.source().query(QueryBuilders.multiMatchQuery(<span class="string">&quot;Sunny&quot;</span>, <span class="string">&quot;OriginWeather&quot;</span>, <span class="string">&quot;DestWeather&quot;</span>));</span><br></pre></td></tr></table></figure>


<p>而结果解析代码则完全一致，可以抽取并共享。</p>
<h3 id="精确查询"><a href="#精确查询" class="headerlink" title="精确查询"></a>精确查询</h3><p>精确查询主要是两者：</p>
<ul>
<li>term：词条精确匹配</li>
<li>range：范围查询</li>
</ul>
<p>与之前的查询相比，差异同样在查询条件，其它都一样。</p>
<p>查询条件构造的API如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">QueryBuilders.termQuery(<span class="string">&quot;DestCountry&quot;</span>, <span class="string">&quot;CN&quot;</span>);</span><br><span class="line">QueryBuilders.rangeQuery(<span class="string">&quot;FlightTimeMin&quot;</span>).gte(<span class="number">100</span>).lte(<span class="number">400</span>);</span><br></pre></td></tr></table></figure>

<h3 id="地理查询"><a href="#地理查询" class="headerlink" title="地理查询"></a>地理查询</h3><p>DSL查询</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /kibana_sample_data_flights/_search</span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;geo_distance&quot;: &#123;</span><br><span class="line">      &quot;distance&quot; : &quot;50km&quot;,</span><br><span class="line">      &quot;OriginLocation&quot; : &quot;44.7, 11.6&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGeoSearch</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;kibana_sample_data_flights&quot;</span>);</span><br><span class="line">    <span class="comment">// 单字段查询</span></span><br><span class="line">    request.source().query(QueryBuilders.matchQuery(<span class="string">&quot;DestCountry&quot;</span>, <span class="string">&quot;CN&quot;</span>));</span><br><span class="line">    request.source().from(<span class="number">0</span>).size(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">// 先按照时间，再按照距离排序</span></span><br><span class="line">    request.source()</span><br><span class="line">            .sort(SortBuilders.fieldSort(<span class="string">&quot;FlightTimeMin&quot;</span>).order(SortOrder.ASC))</span><br><span class="line">            .sort(SortBuilders.geoDistanceSort(<span class="string">&quot;DestLocation&quot;</span>, <span class="number">31.194265D</span>, <span class="number">121.44156D</span>)</span><br><span class="line">            .order(SortOrder.ASC).unit(DistanceUnit.KILOMETERS));</span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="type">SearchHits</span> <span class="variable">searchHits</span> <span class="operator">=</span> response.getHits();</span><br><span class="line">    <span class="comment">// 解析数据</span></span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    log.info(<span class="string">&quot;总条数 &#123;&#125;, 结果条数为 &#123;&#125;  结果数据 \r\n &#123;&#125;&quot;</span>, searchHits.getTotalHits().value, hits.length, response.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="布尔查询"><a href="#布尔查询" class="headerlink" title="布尔查询"></a>布尔查询</h3><p>布尔查询是用must、must_not、filter等方式组合其它查询，代码示例如下：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205173858188-382428581.png" alt="image"></p>
<p>可以看到，API与其它查询的差别同样是在查询条件的构建，QueryBuilders，结果解析等其他代码完全不变。</p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 布尔查询</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBoolQuery</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;kibana_sample_data_flights&quot;</span>);</span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">boolQuery</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line">    boolQuery.must(QueryBuilders.termQuery(<span class="string">&quot;DestCountry&quot;</span>, <span class="string">&quot;CN&quot;</span>));</span><br><span class="line">    boolQuery.mustNot(QueryBuilders.multiMatchQuery(<span class="string">&quot;Rain&quot;</span>, <span class="string">&quot;OriginWeather&quot;</span>, <span class="string">&quot;DestWeather&quot;</span>));</span><br><span class="line">    boolQuery.filter(QueryBuilders.rangeQuery(<span class="string">&quot;AvgTicketPrice&quot;</span>).lte(<span class="number">300</span>));</span><br><span class="line">    request.source().query(boolQuery);</span><br><span class="line">    request.source().from(<span class="number">0</span>).size(<span class="number">10</span>);</span><br><span class="line">    request.source().sort(<span class="string">&quot;AvgTicketPrice&quot;</span>);</span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    log.info(<span class="string">&quot;查询结果为 &#123;&#125;&quot;</span>, response.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算分函数查询"><a href="#算分函数查询" class="headerlink" title="算分函数查询"></a>算分函数查询</h3><blockquote>
<p>java代码逻辑：添加一个isAD字段，在算分函数的filter中判断<code>isAD=ture</code>就进行重新算分</p>
</blockquote>
<p>function_score查询结构如下：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205173906160-2115196651.png" alt="image"></p>
<p>对应的JavaAPI如下：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205173910417-2019314328.png" alt="image"></p>
<p>我们可以将上一步的布尔查询作为<strong>原始查询</strong>条件放到query中，接下来就是添加<strong>过滤条件</strong>、<strong>算分函数</strong>、<strong>加权模式</strong>了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FunctionScoreQueryBuilder</span> <span class="variable">functionScoreQueryBuilder</span> <span class="operator">=</span> QueryBuilders.functionScoreQuery(</span><br><span class="line">        boolQuery, <span class="keyword">new</span> <span class="title class_">FunctionScoreQueryBuilder</span>.FilterFunctionBuilder[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FunctionScoreQueryBuilder</span>.FilterFunctionBuilder(</span><br><span class="line">        QueryBuilders.multiMatchQuery(<span class="string">&quot;Sunny&quot;</span>, <span class="string">&quot;DestWeather&quot;</span>, <span class="string">&quot;OriginWeather&quot;</span>),</span><br><span class="line">        ScoreFunctionBuilders.weightFactorFunction(<span class="number">10F</span>)</span><br><span class="line">        )</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="设置搜索结果"><a href="#设置搜索结果" class="headerlink" title="设置搜索结果"></a>设置搜索结果</h2><h3 id="排序和分页"><a href="#排序和分页" class="headerlink" title="排序和分页"></a>排序和分页</h3><p>搜索结果的排序和分页是与query同级的参数，因此同样是使用request.source()来设置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request.source().from(<span class="number">0</span>).size(<span class="number">10</span>);</span><br><span class="line">request.source().sort(<span class="string">&quot;AvgTicketPrice&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h3><p>高亮的代码与之前代码差异较大，有两点：</p>
<ul>
<li>查询的DSL：其中除了查询条件，还需要添加高亮条件，同样是与query同级。</li>
<li>结果解析：结果除了要解析_source文档数据，还要解析高亮结果</li>
</ul>
<p><strong>1）高亮请求构建</strong></p>
<p>高亮请求的构建API如下：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205173927424-735344633.png" alt="image"></p>
<p>上述代码省略了查询条件部分，但是大家不要忘了：高亮查询必须使用全文检索查询，并且要有搜索关键字，将来才可以对关键字高亮。</p>
<p>完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testHighlight</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备DSL</span></span><br><span class="line">    <span class="comment">// 2.1.query</span></span><br><span class="line">    request.source().query(QueryBuilders.matchQuery(<span class="string">&quot;all&quot;</span>, <span class="string">&quot;如家&quot;</span>));</span><br><span class="line">    <span class="comment">// 2.2.高亮</span></span><br><span class="line">    request.source().highlighter(<span class="keyword">new</span> <span class="title class_">HighlightBuilder</span>().field(<span class="string">&quot;name&quot;</span>).requireFieldMatch(<span class="literal">false</span>));</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2）高亮结果解析</strong></p>
<p>高亮的结果与查询的文档结果默认是分离的，并不在一起。</p>
<p>因此解析高亮的代码需要额外处理：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205173934109-1738654654.png" alt="image"></p>
<p>代码解读：</p>
<ul>
<li>第一步：从结果中获取source。hit.getSourceAsString()，这部分是非高亮结果，json字符串。还需要反序列为HotelDoc对象</li>
<li>第二步：获取高亮结果。hit.getHighlightFields()，返回值是一个Map，key是高亮字段名称，值是HighlightField对象，代表高亮值</li>
<li>第三步：从map中根据高亮字段名称，获取高亮字段值对象HighlightField</li>
<li>第四步：从HighlightField中获取Fragments，并且转为字符串。这部分就是真正的高亮字符串了</li>
<li>第五步：用高亮的结果替换HotelDoc中的非高亮结果</li>
</ul>
<h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>聚合条件与query条件同级别，因此需要使用request.source()来指定聚合条件。</p>
<p>聚合条件的语法：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205173941332-769786160.png" alt="image"></p>
<p>聚合的结果也与查询结果不同，API也比较特殊。不过同样是JSON逐层解析：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205173947241-344347749.png" alt="image"></p>
<p>示例代码，对按照机场id和航空公司进行聚合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对查询结果进行聚合  DSL 语句为</span></span><br><span class="line"><span class="comment"> * GET /kibana_sample_data_flights/_search</span></span><br><span class="line"><span class="comment"> * &#123;</span></span><br><span class="line"><span class="comment"> *   &quot;query&quot;: &#123;&quot;match&quot;: &#123;</span></span><br><span class="line"><span class="comment"> *     &quot;DestCountry&quot;: &quot;CN&quot;</span></span><br><span class="line"><span class="comment"> *   &#125;&#125;,</span></span><br><span class="line"><span class="comment"> *   &quot;size&quot;: 0,</span></span><br><span class="line"><span class="comment"> *   &quot;aggs&quot;: &#123;</span></span><br><span class="line"><span class="comment"> *     &quot;airportIdAggs&quot;: &#123;</span></span><br><span class="line"><span class="comment"> *       &quot;terms&quot;: &#123;</span></span><br><span class="line"><span class="comment"> *         &quot;field&quot;: &quot;DestAirportID&quot;,</span></span><br><span class="line"><span class="comment"> *         &quot;size&quot;: 10,</span></span><br><span class="line"><span class="comment"> *         &quot;order&quot;: &#123;</span></span><br><span class="line"><span class="comment"> *           &quot;_count&quot;: &quot;desc&quot;</span></span><br><span class="line"><span class="comment"> *         &#125;</span></span><br><span class="line"><span class="comment"> *       &#125;</span></span><br><span class="line"><span class="comment"> *     &#125;,</span></span><br><span class="line"><span class="comment"> *     &quot;CarrierAggs&quot;:&#123;</span></span><br><span class="line"><span class="comment"> *       &quot;terms&quot;: &#123;</span></span><br><span class="line"><span class="comment"> *         &quot;field&quot;: &quot;Carrier&quot;,</span></span><br><span class="line"><span class="comment"> *         &quot;size&quot;: 10</span></span><br><span class="line"><span class="comment"> *       &#125;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAggs</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;kibana_sample_data_flights&quot;</span>);</span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">boolQuery</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line">    boolQuery.must(QueryBuilders.termQuery(<span class="string">&quot;DestCountry&quot;</span>, <span class="string">&quot;CN&quot;</span>));</span><br><span class="line">    request.source().query(boolQuery);</span><br><span class="line">    request.source().size(<span class="number">0</span>);</span><br><span class="line">    request.source().aggregation(AggregationBuilders.terms(<span class="string">&quot;airportIdAggs&quot;</span>)</span><br><span class="line">            .size(<span class="number">10</span>).field(<span class="string">&quot;DestAirportID&quot;</span>).order(BucketOrder.count(<span class="literal">false</span>)));</span><br><span class="line">    request.source().aggregation(AggregationBuilders.terms(<span class="string">&quot;CarrierAggs&quot;</span>)</span><br><span class="line">            .size(<span class="number">10</span>).field(<span class="string">&quot;Carrier&quot;</span>).order(BucketOrder.count(<span class="literal">false</span>)));</span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    log.info(<span class="string">&quot;查询结果为 &#123;&#125;&quot;</span>, response.toString());</span><br><span class="line">    <span class="type">Aggregations</span> <span class="variable">aggregations</span> <span class="operator">=</span> response.getAggregations();</span><br><span class="line">    <span class="type">Terms</span> <span class="variable">airportIdTerms</span> <span class="operator">=</span> aggregations.get(<span class="string">&quot;airportIdAggs&quot;</span>);</span><br><span class="line">    List&lt;? <span class="keyword">extends</span> <span class="title class_">Terms</span>.Bucket&gt; airportIdBuckets =  airportIdTerms.getBuckets();</span><br><span class="line">    <span class="keyword">for</span> (Terms.Bucket idBucket : airportIdBuckets) &#123;</span><br><span class="line">        log.info(<span class="string">&quot; key &#123;&#125; 的数量为 &#123;&#125;&quot;</span>, idBucket.getKeyAsString(), idBucket.getDocCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>参考文章</strong></p>
<ol>
<li><a href="https://www.cnblogs.com/buchizicai/p/17093719.html">ElasticSearch (ES从入门到精通一篇就够了)</a></li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>elascitsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>ES搜索查询</title>
    <url>/hexoblog/java/es/es-04-dsl-search/</url>
    <content><![CDATA[<p>[toc]</p>
<p>主要介绍ES DSL的查询</p>
<span id="more"></span>


<p>elasticsearch的查询依然是基于JSON风格的DSL来实现的。</p>
<h1 id="DSL设置查询条件"><a href="#DSL设置查询条件" class="headerlink" title="DSL设置查询条件"></a>DSL设置查询条件</h1><h2 id="DSL查询分类"><a href="#DSL查询分类" class="headerlink" title="DSL查询分类"></a>DSL查询分类</h2><p>Elasticsearch提供了基于JSON的DSL ( <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html">Domain Specific Language</a> ) 来定义查询。常见的查询类型包括：</p>
<ul>
<li><p><strong>查询所有</strong>：查询出所有数据，<em>一般测试用</em>。例如：match_all</p>
</li>
<li><p><strong>全文检索（full text）查询</strong>：利用分词器对用户输入内容分词，然后去倒排索引库中匹配。例如：</p>
<ul>
<li>match_query</li>
<li>multi_match_query</li>
</ul>
</li>
<li><p><strong>精确查询</strong>：根据精确词条值查找数据，一般是查找keyword、数值、日期、boolean等类型字段。例如：</p>
<ul>
<li>ids</li>
<li>range</li>
<li>term</li>
</ul>
</li>
<li><p><strong>地理（geo）查询</strong>：根据经纬度查询。例如：</p>
<ul>
<li>geo_distance</li>
<li>geo_bounding_box</li>
</ul>
</li>
<li><p><strong>复合（compound）查询</strong>：复合查询可以将上述各种查询条件组合起来，合并查询条件。例如：</p>
<ul>
<li>bool</li>
<li>function_score</li>
</ul>
</li>
</ul>
<p>查询的语法基本一致：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;查询类型&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;查询条件&quot;</span><span class="punctuation">:</span> <span class="string">&quot;条件值&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>


<p>我们以查询所有为例，其中：</p>
<ul>
<li>查询类型为match_all</li>
<li>没有查询条件</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询所有</span></span><br><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>其它查询无非就是<strong>查询类型</strong>、<strong>查询条件</strong>的变化。</p>
<h2 id="全文检索查询"><a href="#全文检索查询" class="headerlink" title="全文检索查询"></a>全文检索查询</h2><blockquote>
<p>match和multi_match的区别是什么？</p>
<ul>
<li>match：根据一个字段查询【推荐：使用copy_to构造all字段】</li>
<li>multi_match：根据多个字段查询，参与查询字段越多，查询性能越差</li>
</ul>
<p><strong>注：搜索字段越多，对查询性能影响越大，因此建议采用copy_to，然后单字段查询的方式。</strong></p>
</blockquote>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>全文检索查询的<strong>基本流程</strong>如下：</p>
<ul>
<li>对用户搜索的内容做分词，得到词条</li>
<li>根据词条去倒排索引库中匹配，得到文档id</li>
<li>根据文档id找到文档，返回给用户</li>
</ul>
<p>比较常用的<strong>场景</strong>包括：</p>
<ul>
<li>商城的输入框搜索</li>
<li>百度输入框搜索</li>
</ul>
<p>例如京东：</p>
<p>因为是拿着词条去匹配，因此参与搜索的字段也必须是可分词的text类型的字段。</p>
<p>常见的全文检索查询包括：</p>
<ul>
<li>match查询：单字段查询</li>
<li>multi_match查询：多字段查询，任意一个字段符合条件就算符合查询条件</li>
</ul>
<h3 id="match查询"><a href="#match查询" class="headerlink" title="match查询"></a>match查询</h3><p>match查询语法如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span><span class="punctuation">:</span> <span class="string">&quot;TEXT&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>


<p>match查询示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /testcrud/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;info&quot; : &quot;测试 文档&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询结果是 info 中包含 <code>测试</code> 或者 <code>文档</code> 的数据。</p>
<h3 id="mulit-match查询"><a href="#mulit-match查询" class="headerlink" title="mulit_match查询"></a>mulit_match查询</h3><p>mulit_match语法如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;multi_match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="string">&quot;TEXT&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;FIELD1&quot;</span><span class="punctuation">,</span> <span class="string">&quot; FIELD12&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="精准查询"><a href="#精准查询" class="headerlink" title="精准查询"></a>精准查询</h2><blockquote>
<p>精准查询类型：</p>
<ul>
<li>term查询：根据词条精确匹配，一般搜索keyword类型、数值类型、布尔类型、日期类型字段</li>
<li>range查询：根据数值范围查询，可以是数值、日期的范围</li>
</ul>
</blockquote>
<p>精确查询一般是查找keyword、数值、日期、boolean等类型字段。所以<strong>不会</strong>对搜索条件分词。常见的有：</p>
<ul>
<li><strong>term：根据词条精确值查询</strong></li>
<li><strong>range：根据值的范围查询</strong></li>
</ul>
<h3 id="term查询"><a href="#term查询" class="headerlink" title="term查询"></a>term查询</h3><p>因为精确查询的字段是不分词的字段，因此查询的条件也必须是<strong>不分词</strong>的词条。查询时，用户输入的内容跟字段值完全匹配时才认为符合条件。如果用户输入的内容过多，反而搜索不到数据。</p>
<p>语法说明：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// term查询</span><br><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;FIELD&quot;: &#123;</span><br><span class="line">        &quot;value&quot;: &quot;VALUE&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="range查询"><a href="#range查询" class="headerlink" title="range查询"></a>range查询</h3><blockquote>
<p>范围查询，一般应用在对数值类型做范围过滤的时候。比如做价格范围过滤。</p>
</blockquote>
<p>基本语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// range查询</span><br><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;range&quot;: &#123;</span><br><span class="line">      &quot;FIELD&quot;: &#123;</span><br><span class="line">        &quot;gte&quot;: 10, // 这里的gte代表大于等于，gt则代表大于</span><br><span class="line">        &quot;lte&quot;: 20 // lte代表小于等于，lt则代表小于</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /testcrud/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;range&quot;: &#123;</span><br><span class="line">      &quot;age&quot; : &#123;</span><br><span class="line">        &quot;gte&quot; : 10,</span><br><span class="line">        &quot;lte&quot; : 12</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="地理坐标查询"><a href="#地理坐标查询" class="headerlink" title="地理坐标查询"></a>地理坐标查询</h3><p>所谓的地理坐标查询，其实就是根据经纬度查询，官方文档：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html">geo-queries.html</a></p>
<p>常见的使用场景包括：</p>
<ul>
<li>携程：搜索我附近的酒店</li>
<li>滴滴：搜索我附近的出租车</li>
<li>微信：搜索我附近的人</li>
</ul>
<h4 id="矩形范围查询"><a href="#矩形范围查询" class="headerlink" title="矩形范围查询"></a>矩形范围查询</h4><blockquote>
<p>很少有业务有这种需求</p>
</blockquote>
<p>矩形范围查询，也就是geo_bounding_box查询，查询坐标落在某个矩形范围的所有文档：<br><img data-src="/hexoblog/images/java/es/2729274-20230205172556695-448469947.gif" alt="image"></p>
<p>查询时，需要指定矩形的<strong>左上</strong>、<strong>右下</strong>两个点的坐标，然后画出一个矩形，落在该矩形内的都是符合条件的点。</p>
<p>语法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// geo_bounding_box查询</span><br><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;geo_bounding_box&quot;: &#123;</span><br><span class="line">      &quot;FIELD&quot;: &#123;</span><br><span class="line">        &quot;top_left&quot;: &#123; // 左上点</span><br><span class="line">          &quot;lat&quot;: 31.1,</span><br><span class="line">          &quot;lon&quot;: 121.5</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;bottom_right&quot;: &#123; // 右下点</span><br><span class="line">          &quot;lat&quot;: 30.9,</span><br><span class="line">          &quot;lon&quot;: 121.7</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="附近-圆形-查询"><a href="#附近-圆形-查询" class="headerlink" title="附近(圆形)查询"></a>附近(圆形)查询</h4><p>附近查询，也叫做距离查询（geo_distance）：查询到指定中心点小于某个距离值的所有文档。</p>
<p>换句话来说，在地图上找一个点作为圆心，以指定距离为半径，画一个圆，落在圆内的坐标都算符合条件：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205172657385-1268854128.gif" alt="image"></p>
<p>语法说明：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// geo_distance 查询</span><br><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;geo_distance&quot;: &#123;</span><br><span class="line">      &quot;distance&quot;: &quot;15km&quot;, // 半径</span><br><span class="line">      &quot;FIELD&quot;: &quot;31.21,121.5&quot; // 圆心</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<p>我们先搜索陆家嘴附近15km的酒店：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205172724869-1773754207.png" alt="image"></p>
<p>发现共有47家酒店。</p>
<h2 id="复合查询"><a href="#复合查询" class="headerlink" title="复合查询"></a>复合查询</h2><p>复合（compound）查询：复合查询可以将其它简单查询组合起来，实现更复杂的搜索逻辑。常见的有两种：</p>
<ul>
<li>fuction score：算分函数查询，可以控制文档相关性算分，控制文档排名</li>
<li>bool query：布尔查询，利用逻辑关系组合多个其它的查询，实现复杂搜索</li>
</ul>
<h3 id="复合查询归纳"><a href="#复合查询归纳" class="headerlink" title="复合查询归纳"></a>复合查询归纳</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;function_score&quot;: &#123;           </span><br><span class="line">      &quot;query&quot;: &#123; // 原始查询，可以是任意条件</span><br><span class="line">          &quot;bool&quot;: &#123;</span><br><span class="line">              &quot;must&quot;: [</span><br><span class="line">                  &#123;&quot;term&quot;: &#123;&quot;city&quot;: &quot;上海&quot; &#125;&#125;</span><br><span class="line">              ],</span><br><span class="line">              &quot;should&quot;: [</span><br><span class="line">                  &#123;&quot;term&quot;: &#123;&quot;brand&quot;: &quot;皇冠假日&quot; &#125;&#125;,</span><br><span class="line">                  &#123;&quot;term&quot;: &#123;&quot;brand&quot;: &quot;华美达&quot; &#125;&#125;</span><br><span class="line">              ],</span><br><span class="line">              &quot;must_not&quot;: [</span><br><span class="line">                  &#123; &quot;range&quot;: &#123; &quot;price&quot;: &#123; &quot;lte&quot;: 500 &#125; &#125;&#125;</span><br><span class="line">              ],</span><br><span class="line">              &quot;filter&quot;: [</span><br><span class="line">                  &#123; &quot;range&quot;: &#123;&quot;score&quot;: &#123; &quot;gte&quot;: 45 &#125; &#125;&#125;</span><br><span class="line">              ]</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;functions&quot;: [ // 算分函数</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;filter&quot;: &#123; // 满足的条件，品牌必须是如家【品牌是如家的才加分，这里是加分条件】</span><br><span class="line">            &quot;term&quot;: &#123;</span><br><span class="line">              &quot;brand&quot;: &quot;如家&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;weight&quot;: 2 // 算分权重为2</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;boost_mode&quot;: &quot;sum&quot; // 加权模式，求和</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="相关性算分"><a href="#相关性算分" class="headerlink" title="相关性算分"></a>相关性算分</h3><blockquote>
<p>elasticsearch会根据词条和文档的相关度做打分，算法由两种：</p>
<ul>
<li>TF-IDF算法</li>
<li>BM25算法，elasticsearch5.1版本后采用的算法</li>
</ul>
</blockquote>
<p>当我们利用match查询时，文档结果会根据与搜索词条的关联度打分（_score），返回结果时按照分值降序排列。</p>
<p>例如，我们搜索 “虹桥如家”，结果如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;_score&quot;</span> <span class="punctuation">:</span> <span class="number">17.850193</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;_source&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;虹桥如家酒店真不错&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;_score&quot;</span> <span class="punctuation">:</span> <span class="number">12.259849</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;_source&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;外滩如家酒店真不错&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;_score&quot;</span> <span class="punctuation">:</span> <span class="number">11.91091</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;_source&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;迪士尼如家酒店真不错&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在elasticsearch中，早期使用的打分算法是TF-IDF算法，公式如下：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205173433826-368331600.png" alt="image"></p>
<p>在后来的5.1版本升级中，elasticsearch将算法改进为BM25算法，公式如下：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205173438720-1124832591.png" alt="image"></p>
<p>TF-IDF算法有一各缺陷，就是词条频率越高，文档得分也会越高，单个词条对文档影响较大。而BM25则会让单个词条的算分有一个上限，曲线更加平滑：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205173443307-150506578.png" alt="image"></p>
<h3 id="算分函数查询"><a href="#算分函数查询" class="headerlink" title="算分函数查询"></a>算分函数查询</h3><blockquote>
<p>在搜索出来的结果的分数基础上，再手动与指定的数字进行一定运算来改变算分，从而改变结果的排序。</p>
</blockquote>
<blockquote>
<p>function score query定义的三要素是什么？</p>
<ul>
<li>过滤条件：哪些文档要加分</li>
<li>算分函数：如何计算function score</li>
<li>加权方式：function score 与 query score如何运算</li>
</ul>
</blockquote>
<p>根据相关度打分是比较合理的需求，但<strong>合理的不一定是产品经理需要</strong>的。</p>
<p>以百度为例，你搜索的结果中，并不是相关度越高排名越靠前，而是谁掏的钱多排名就越靠前。如图：</p>
<p>要想人为控制相关性算分，就需要利用elasticsearch中的function score 查询了。</p>
<h4 id="function-score-查询"><a href="#function-score-查询" class="headerlink" title="function score 查询"></a>function score 查询</h4><p><strong>1）语法说明</strong></p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205173456315-243388005.png" alt="image"></p>
<p>function score 查询中包含四部分内容：</p>
<ul>
<li><strong>原始查询</strong>条件：query部分，基于这个条件搜索文档，并且基于BM25算法给文档打分，<strong>原始算分</strong>（query score)</li>
<li><strong>过滤条件</strong>：filter部分，符合该条件的文档才会重新算分</li>
<li><strong>算分函数</strong>：符合filter条件的文档要根据这个函数做运算，得到的<strong>函数算分</strong>（function score），有四种函数<ul>
<li>weight：函数结果是常量</li>
<li>field_value_factor：以文档中的某个字段值作为函数结果</li>
<li>random_score：以随机数作为函数结果</li>
<li>script_score：自定义算分函数算法</li>
</ul>
</li>
<li><strong>运算模式</strong>：算分函数的结果、原始查询的相关性算分，两者之间的运算方式，包括：<ul>
<li>multiply：相乘</li>
<li>replace：用function score替换query score</li>
<li>其它，例如：sum、avg、max、min</li>
</ul>
</li>
</ul>
<p>function score的运行流程如下：</p>
<ul>
<li>1）根据<strong>原始条件</strong>查询搜索文档，并且计算相关性算分，称为<strong>原始算分</strong>（query score）</li>
<li>2）根据<strong>过滤条件</strong>，过滤文档</li>
<li>3）符合<strong>过滤条件</strong>的文档，基于<strong>算分函数</strong>运算，得到<strong>函数算分</strong>（function score）</li>
<li>4）将<strong>原始算分</strong>（query score）和<strong>函数算分</strong>（function score）基于<strong>运算模式</strong>做运算，得到最终结果，作为相关性算分。</li>
</ul>
<p><strong>2）举例</strong></p>
<p>需求：给“如家”这个品牌的酒店排名靠前一些</p>
<p>翻译一下这个需求，转换为之前说的四个要点：</p>
<ul>
<li>原始条件：不确定，可以任意变化</li>
<li>过滤条件：brand &#x3D; “如家”</li>
<li>算分函数：可以简单粗暴，直接给固定的算分结果，weight</li>
<li>运算模式：比如求和</li>
</ul>
<p>因此最终的DSL语句如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;function_score&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &#123;  .... &#125;, // 原始查询，可以是任意条件</span><br><span class="line">      &quot;functions&quot;: [ // 算分函数</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;filter&quot;: &#123; // 满足的条件，品牌必须是如家【品牌是如家的才加分，这里是加分条件】</span><br><span class="line">            &quot;term&quot;: &#123;</span><br><span class="line">              &quot;brand&quot;: &quot;如家&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;weight&quot;: 2 // 算分权重为2</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;boost_mode&quot;: &quot;sum&quot; // 加权模式，求和</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试，在未添加算分函数时，如家得分如下：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205173504670-1488473639.png" alt="image"></p>
<p>添加了算分函数后，如家得分就提升了：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205173509427-1841421871.png" alt="image"></p>
<h3 id="布尔查询"><a href="#布尔查询" class="headerlink" title="布尔查询"></a>布尔查询</h3><p>布尔查询把多个子查询组合（combine）成一个布尔表达式，所有子查询之间的逻辑关系是与（and）；只有当一个文档满足布尔查询中的所有子查询条件时，ElasticSearch引擎才认为该文档满足查询条件。</p>
<blockquote>
<p>布尔查询是一个或多个查询子句的组合，每一个子句就是一个<strong>子查询</strong>。子查询的组合方式有：</p>
<ul>
<li>must：文档必须匹配must查询条件, 类似sql中的and</li>
<li>should：文档应该匹配should子句查询的一个或多个, 如果满足这些语句中的任意语句，将增加 _score ，否则，无任何影响。它们主要用于修正每个文档的相关性得分。类似 or</li>
<li>must_not：必须不匹配，<strong>不参与算分</strong>，类似“非”</li>
<li>filter：必须匹配，<strong>不参与算分</strong>。 这些语句对评分没有贡献，只是根据过滤标准来排除或包含文档。</li>
</ul>
<p>注意：尽量在筛选的时候多使用不参与算分的must_not和filter，以保证性能良好</p>
</blockquote>
<p>比如在搜索酒店时，除了关键字搜索外，我们还可能根据品牌、价格、城市等字段做过滤：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205173518420-1928367735.png" alt="image"></p>
<p>每一个不同的字段，其查询的条件、方式都不一样，必须是多个不同的查询，而要组合这些查询，就必须用bool查询了。</p>
<p>需要注意的是，搜索时，参与<strong>打分的字段越多，查询的性能也越差</strong>。因此这种多条件查询时，建议这样做：</p>
<ul>
<li>搜索框的关键字搜索，是全文检索查询，使用must查询，参与算分</li>
<li>其它过滤条件，采用filter查询。不参与算分</li>
</ul>
<h4 id="bool查询"><a href="#bool查询" class="headerlink" title="bool查询"></a>bool查询</h4><p>1）语法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123;&quot;term&quot;: &#123;&quot;city&quot;: &quot;上海&quot; &#125;&#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;should&quot;: [</span><br><span class="line">        &#123;&quot;term&quot;: &#123;&quot;brand&quot;: &quot;皇冠假日&quot; &#125;&#125;,</span><br><span class="line">        &#123;&quot;term&quot;: &#123;&quot;brand&quot;: &quot;华美达&quot; &#125;&#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;must_not&quot;: [</span><br><span class="line">        &#123; &quot;range&quot;: &#123; &quot;price&quot;: &#123; &quot;lte&quot;: 500 &#125; &#125;&#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;filter&quot;: [</span><br><span class="line">        &#123; &quot;range&quot;: &#123;&quot;score&quot;: &#123; &quot;gte&quot;: 45 &#125; &#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）示例</p>
<p>需求：搜索名字包含“如家”，价格不高于400，在坐标31.21,121.5周围10km范围内的酒店。</p>
<p>分析：</p>
<ul>
<li>名称搜索，属于全文检索查询，应该参与算分。放到must中</li>
<li>价格不高于400，用range查询，属于过滤条件，不参与算分。放到must_not中</li>
<li>周围10km范围内，用geo_distance查询，属于过滤条件，不参与算分。放到filter中</li>
</ul>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205173526171-218786081.png" alt="image"></p>
<h3 id="boosting-query-提高查询"><a href="#boosting-query-提高查询" class="headerlink" title="boosting query(提高查询)"></a>boosting query(提高查询)</h3><blockquote>
<p>不同于bool查询，bool查询中只要一个子查询条件不匹配那么搜索的数据就不会出现。而boosting query则是降低显示的权重&#x2F;优先级（即score)。</p>
</blockquote>
<h3 id="dis-max-最佳匹配查询）"><a href="#dis-max-最佳匹配查询）" class="headerlink" title="dis_max(最佳匹配查询）"></a>dis_max(最佳匹配查询）</h3><blockquote>
<p>分离最大化查询（Disjunction Max Query）指的是： 将任何与任一查询匹配的文档作为结果返回，但只将最佳匹配的评分作为查询的评分结果返回 。</p>
</blockquote>
<p>dis_max 查询的工作原理如下</p>
<ul>
<li>dis_max 查询首先在每个字段上执行子查询，然后将每个子查询的得分合并起来，选择最高得分的文档作为最终结果。</li>
<li>对于每个子查询，如果某个查询在一个字段上找到了一个很高得分的文档，该字段的得分将被保留，并用于计算最终得分。</li>
<li>这种查询适用于需要在多个字段上执行查询，并希望返回在其中任何一个字段中找到最佳匹配的文档的情况。</li>
</ul>
<h1 id="设置搜索结果"><a href="#设置搜索结果" class="headerlink" title="设置搜索结果"></a>设置搜索结果</h1><p>搜索的结果可以按照用户指定的方式去处理或展示。</p>
<h2 id="搜索结果种类"><a href="#搜索结果种类" class="headerlink" title="搜索结果种类"></a>搜索结果种类</h2><p>查询的DSL是一个大的JSON对象，包含下列属性：</p>
<ul>
<li>query：查询条件</li>
<li>from和size：分页条件</li>
<li>sort：排序条件</li>
<li>highlight：高亮条件</li>
<li>aggs：定义聚合</li>
</ul>
<p>示例：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205173604304-279114726.png" alt="image"></p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205173609914-830516280.png" alt="image"></p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><blockquote>
<p>在使用排序后就不会进行算分了，根据排序设置的规则排列</p>
</blockquote>
<blockquote>
<p>普通字段是根据字典序排序</p>
<p>地理坐标是根据举例远近排序</p>
</blockquote>
<h3 id="普通字段排序"><a href="#普通字段排序" class="headerlink" title="普通字段排序"></a>普通字段排序</h3><p>keyword、数值、日期类型排序的排序语法基本一致。</p>
<p><strong>语法</strong>：</p>
<p><strong>排序条件是一个数组，也就是可以写多个排序条件。按照声明的顺序，当第一个条件相等时，再按照第二个条件排序，以此类推</strong><br><strong>（可以参考下面的图片案例）</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;FIELD&quot;: &quot;desc&quot;  // 排序字段、排序方式ASC、DESC</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例</strong>：</p>
<p>需求描述：酒店数据按照用户评价（score)降序排序，评价相同的按照价格(price)升序排序</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205173616661-1802336128.png" alt="image"></p>
<h3 id="地理坐标排序"><a href="#地理坐标排序" class="headerlink" title="地理坐标排序"></a>地理坐标排序</h3><p>地理坐标排序略有不同。</p>
<p><strong>语法说明</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_geo_distance&quot; : &#123;</span><br><span class="line">          &quot;FIELD&quot; : &quot;纬度，经度&quot;, // 文档中geo_point类型的字段名、目标坐标点</span><br><span class="line">          &quot;order&quot; : &quot;asc&quot;, // 排序方式</span><br><span class="line">          &quot;unit&quot; : &quot;km&quot; // 排序的距离单位</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这个查询的含义是：</p>
<ul>
<li>指定一个坐标，作为目标点</li>
<li>计算每一个文档中，指定字段（必须是geo_point类型）的坐标 到目标点的距离是多少</li>
<li>根据距离排序</li>
</ul>
<p><strong>示例：</strong></p>
<p>需求描述：实现对酒店数据按照到你的位置坐标的距离升序排序</p>
<p>提示：获取你的位置的经纬度的方式：<a href="https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat/">click-to-get-lnglat</a></p>
<p>假设我的位置是：31.034661，121.612282，寻找我周围距离最近的酒店。</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205173623518-625657913.png" alt="image"></p>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><blockquote>
<p><strong>elasticsearch会禁止from+ size 超过10000的请求</strong></p>
</blockquote>
<p>elasticsearch 默认情况下只返回top10的数据。而如果要查询更多数据就需要修改分页参数了。elasticsearch中通过修改from、size参数来控制要返回的分页结果：</p>
<ul>
<li>from：从第几个文档开始</li>
<li>size：总共查询几个文档</li>
</ul>
<p>类似于mysql中的 <code>limit ?, ?</code></p>
<h3 id="基本分页"><a href="#基本分页" class="headerlink" title="基本分页"></a>基本分页</h3><p>分页的基本语法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;from&quot;: 0, // 分页开始的位置，默认为0</span><br><span class="line">  &quot;size&quot;: 10, // 期望获取的文档总数</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;&quot;price&quot;: &quot;asc&quot;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="深度分页"><a href="#深度分页" class="headerlink" title="深度分页"></a>深度分页</h3><blockquote>
<p>原理：elasticsearch内部分页时，必须先查询 0~1000条，然后截取其中的990 ~ 1000的这10条</p>
</blockquote>
<p>现在，我要查询990~1000的数据，查询逻辑要这么写：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;from&quot;: 990, // 分页开始的位置，默认为0</span><br><span class="line">  &quot;size&quot;: 10, // 期望获取的文档总数</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;&quot;price&quot;: &quot;asc&quot;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是查询990开始的数据，也就是 第990~第1000条 数据。</p>
<p><strong>集群情况的深度分页</strong></p>
<blockquote>
<p>针对深度分页，ES提供了两种解决方案， <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html">官方文档</a> </p>
<ul>
<li>search after：分页时需要排序，原理是从上一次的排序值开始，查询下一页数据。【官方推荐】</li>
<li>scroll：原理将排序后的文档id形成快照，保存在内存。</li>
</ul>
</blockquote>
<p>不过，elasticsearch内部分页时，必须先查询 0~1000条，然后截取其中的990 ~ 1000的这10条：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205173634279-892410813.png" alt="image"></p>
<p>查询TOP1000，如果es是单点模式，这并无太大影响。</p>
<p>但是elasticsearch将来一定是集群，例如我集群有5个节点，我要查询TOP1000的数据，并不是每个节点查询200条就可以了。</p>
<p>因为节点A的TOP200，在另一个节点可能排到10000名以外了。</p>
<p>因此要想获取整个集群的TOP1000，必须先查询出每个节点的TOP1000，汇总结果后，重新排名，重新截取TOP1000。</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205173640103-2006900274.png" alt="image"></p>
<p>那如果我要查询9900~10000的数据呢？是不是要先查询TOP10000呢？那每个节点都要查询10000条？汇总到内存中？</p>
<p>当查询分页深度较大时，汇总数据过多，对内存和CPU会产生非常大的压力，因此<strong>elasticsearch会禁止from+ size 超过10000的请求</strong>。</p>
<h2 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h2><blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>高亮是对关键字高亮，因此<strong>搜索条件必须带有关键字</strong>，而不能是范围这样的查询。</li>
<li>默认情况下，<strong>高亮的字段，必须与搜索指定的字段一致</strong>，否则无法高亮</li>
<li>如果要对非搜索字段高亮，则需要添加一个属性：required_field_match&#x3D;false</li>
</ul>
</blockquote>
<p>使用场景：在百度等搜索后，会对结果中出现搜索字段的部分进行高亮处理。</p>
<h3 id="高亮原理"><a href="#高亮原理" class="headerlink" title="高亮原理"></a>高亮原理</h3><p>高亮显示的实现分为两步：</p>
<ul>
<li>1）给文档中的所有关键字都添加一个标签，例如<code>&lt;em&gt;</code>标签</li>
<li>2）页面给<code>&lt;em&gt;</code>标签编写CSS样式</li>
</ul>
<h3 id="实现高亮"><a href="#实现高亮" class="headerlink" title="实现高亮"></a>实现高亮</h3><p>1）语法</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span><span class="punctuation">:</span> <span class="string">&quot;TEXT&quot;</span> <span class="comment">// 查询条件，高亮一定要使用全文检索查询</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;highlight&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 指定要高亮的字段</span></span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//【要和上面的查询字段FIELD一致】</span></span><br><span class="line">        <span class="attr">&quot;pre_tags&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;em&gt;&quot;</span><span class="punctuation">,</span>  <span class="comment">// 用来标记高亮字段的前置标签</span></span><br><span class="line">        <span class="attr">&quot;post_tags&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;/em&gt;&quot;</span> <span class="comment">// 用来标记高亮字段的后置标签</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>2）示例：组合字段all的案例</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205173651044-506239214.png" alt="image"></p>
<h2 id="数据聚合"><a href="#数据聚合" class="headerlink" title="数据聚合"></a>数据聚合</h2><blockquote>
<p>类似于mysql中的【 <strong>度量（Metric）</strong> 聚合】聚合语句实现AVG，MAX，MIN；以及【 <strong>桶（Bucket）</strong> 聚合】GroupBy实现分组</p>
</blockquote>
<p><strong><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html">聚合 aggregations</a></strong> 可以让我们极其方便的实现对数据的统计、分析、运算。例如：</p>
<ul>
<li>什么品牌的手机最受欢迎？</li>
<li>这些手机的平均价格、最高价格、最低价格？</li>
<li>这些手机每月的销售情况如何？</li>
</ul>
<p>实现这些统计功能的比数据库的sql要方便的多，而且查询速度非常快，可以实现近实时搜索效果。</p>
<p>aggs代表聚合，与query同级，此时query的作用是？</p>
<ul>
<li>限定聚合的的文档范围</li>
</ul>
<p>聚合必须的三要素：</p>
<ul>
<li>聚合名称</li>
<li>聚合类型</li>
<li>聚合字段</li>
</ul>
<p>聚合可配置属性有：</p>
<ul>
<li>size：指定聚合结果数量</li>
<li>order：指定聚合结果排序方式</li>
<li>field：指定聚合字段</li>
</ul>
<h3 id="聚合种类"><a href="#聚合种类" class="headerlink" title="聚合种类"></a>聚合种类</h3><blockquote>
<p><strong>注意：</strong>参加聚合的字段必须是keyword、日期、数值、布尔类型</p>
</blockquote>
<p>聚合常见的有三类：</p>
<ul>
<li><p><strong>桶（Bucket）</strong> 聚合：用来对文档做分组</p>
<ul>
<li>TermAggregation：按照文档字段值分组，例如按照品牌值分组、按照国家分组</li>
<li>Date Histogram：按照日期阶梯分组，例如一周为一组，或者一月为一组</li>
</ul>
</li>
<li><p><strong>度量（Metric）</strong> 聚合：用以计算一些值，比如：最大值、最小值、平均值等</p>
<ul>
<li>Avg：求平均值</li>
<li>Max：求最大值</li>
<li>Min：求最小值</li>
<li>Stats：同时求max、min、avg、sum等</li>
</ul>
</li>
<li><p><strong>管道（pipeline）</strong> 聚合：其它聚合的结果为基础做聚合</p>
<blockquote>
<p>如：用桶聚合实现种类排序，然后使用度量聚合实现各个桶的最大值、最小值、平均值等</p>
</blockquote>
</li>
</ul>
<h4 id="桶-Bucket-聚合"><a href="#桶-Bucket-聚合" class="headerlink" title="桶(Bucket)聚合"></a>桶(Bucket)聚合</h4><p>以统计酒店品牌种类，并对其进行数据分组</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//限定要聚合的文档范围，只要添加query条件【一般在没搜索关键字时不写query】</span></span><br><span class="line">    <span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;lte&quot;</span><span class="punctuation">:</span> <span class="number">200</span> <span class="comment">// 只对200元以下的文档聚合</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span>  <span class="comment">// 设置size为0，结果中不包含查询结果文档，只包含聚合结果</span></span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 定义聚合</span></span><br><span class="line">    <span class="attr">&quot;brandAgg&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//给聚合起个名字</span></span><br><span class="line">      <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 聚合的类型，按照品牌值聚合，所以选择term</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;brand&quot;</span><span class="punctuation">,</span> <span class="comment">// 参与聚合的字段</span></span><br><span class="line">        <span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;_count&quot;</span><span class="punctuation">:</span> <span class="string">&quot;asc&quot;</span> <span class="comment">// 对聚合结果按照doc_count升序排列</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">20</span> <span class="comment">// 希望获取的聚合结果数量【设置多少就最多只显示多少】</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img data-src="/hexoblog/images/java/es/2729274-20230205173742270-1590923564.png" alt="image"></p>
<h4 id="度量-Metric-and-管道-pipeline-聚合"><a href="#度量-Metric-and-管道-pipeline-聚合" class="headerlink" title="度量(Metric) and 管道(pipeline)聚合"></a>度量(Metric) and 管道(pipeline)聚合</h4><blockquote>
<p>度量聚合很少单独使用，一般是和桶聚合一并结合使用</p>
</blockquote>
<p>我们对酒店按照品牌分组，形成了一个个桶。现在我们需要对桶内的酒店做运算，获取每个品牌的用户评分的min、max、avg等值。</p>
<p>这就要用到Metric聚合了，例如stat聚合：就可以获取min、max、avg等结果。</p>
<p>语法如下：</p>
<p>这次的score_stats聚合是在brandAgg的聚合内部嵌套的子聚合。因为我们需要在每个桶分别计算。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;brandAgg&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">      <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;brand&quot;</span><span class="punctuation">,</span> </span><br><span class="line">        <span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;scoreAgg.avg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span> <span class="comment">// 对聚合结果按照指定字段降序排列</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">20</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 是brands聚合的子聚合，也就是分组后对每组分别计算</span></span><br><span class="line">        <span class="attr">&quot;score_stats&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 聚合名称</span></span><br><span class="line">          <span class="attr">&quot;stats&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 聚合类型，这里stats可以计算min、max、avg等</span></span><br><span class="line">            <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;score&quot;</span> <span class="comment">// 聚合字段，这里是score</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>另外，我们还可以给聚合结果做个排序，例如按照每个桶的酒店平均分做排序：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205173748393-1737546340.png" alt="image"></p>
<p><strong>参考文章</strong></p>
<ol>
<li><a href="https://www.cnblogs.com/buchizicai/p/17093719.html">ElasticSearch (ES从入门到精通一篇就够了)</a></li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>elascitsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>es自动补全和从mysql同步数据</title>
    <url>/hexoblog/java/es/es-05-autocomplete-mysql-sync/</url>
    <content><![CDATA[<p>主要介绍自动补全功能，以及从mysql同步数据到elasticsearch。</p>
<span id="more"></span>

<h1 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h1><blockquote>
<p>① 设置创建索引库（设置一个自动补全字段，类型为：completion）</p>
<p>② 重新插入数据</p>
<p>③ 查询（查询时要设置这个自动补全操作的名称，并且指定那个类型为completion的字段）</p>
<p>④ 分解结果（结果也需要根据之前设置这个自动查询操作的名称来取）</p>
</blockquote>
<p>当用户在搜索框输入字符时，我们应该提示出与该字符有关的搜索项。</p>
<p>这种根据用户输入的字母，提示完整词条的功能，就是自动补全了。</p>
<h2 id="拼音分词器"><a href="#拼音分词器" class="headerlink" title="拼音分词器"></a>拼音分词器</h2><blockquote>
<p>下载拼音分词器记得版本要和ES对应，不对应会报错</p>
</blockquote>
<p>要实现根据字母做补全，就必须对文档按照拼音分词。在GitHub上恰好有elasticsearch的拼音分词插件。地址：<a href="https://github.com/infinilabs/analysis-pinyin">https://github.com/infinilabs/analysis-pinyin</a></p>
<p><a href="https://release.infinilabs.com/analysis-pinyin/stable/">手动安装下载地址</a></p>
<p>在线安装</p>
<blockquote>
<p> .&#x2F;elasticsearch-plugin install <a href="https://get.infini.cloud/elasticsearch/analysis-pinyin/7.12.1">https://get.infini.cloud/elasticsearch/analysis-pinyin/7.12.1</a></p>
</blockquote>
<h2 id="自定义拼音分词器"><a href="#自定义拼音分词器" class="headerlink" title="自定义拼音分词器"></a>自定义拼音分词器</h2><blockquote>
<p>如何使用拼音分词器？</p>
<ul>
<li><p>①下载pinyin分词器</p>
</li>
<li><p>②解压并放到elasticsearch的plugin目录</p>
</li>
<li><p>③重启即可</p>
</li>
</ul>
<p>如何自定义分词器？</p>
<ul>
<li><p>①创建索引库时，在settings中配置，可以包含三部分</p>
</li>
<li><p>②character filter</p>
</li>
<li><p>③tokenizer</p>
</li>
<li><p>④filter</p>
</li>
</ul>
<p>拼音分词器注意事项？</p>
<ul>
<li>为了避免搜索到同音字，<strong>搜索时不要使用拼音分词器</strong></li>
</ul>
</blockquote>
<p>默认的拼音分词器会将每个汉字单独分为拼音，而我们希望的是每个词条形成一组拼音，需要对拼音分词器做个性化定制，形成自定义分词器。<a href="https://github.com/infinilabs/analysis-pinyin">官网文档查询地址</a> 。</p>
<p>elasticsearch中分词器（analyzer）的组成包含三部分：</p>
<ul>
<li>character filters：在tokenizer之前对文本进行处理。例如删除字符、替换字符</li>
<li>tokenizer：将文本按照一定的规则切割成词条（term）。例如keyword，就是不分词；还有ik_smart</li>
<li>tokenizer filter：将tokenizer输出的词条做进一步处理。例如大小写转换、同义词处理、拼音处理等</li>
</ul>
<p>文档分词时会依次由这三部分来处理文档：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205174015343-1046847662.png" alt="image"></p>
<p>声明自定义分词器的语法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PUT /pinyintest</span><br><span class="line">&#123;</span><br><span class="line">  &quot;settings&quot;: &#123;</span><br><span class="line">    &quot;analysis&quot;: &#123;</span><br><span class="line">      &quot;analyzer&quot;: &#123; // 自定义分词器</span><br><span class="line">        &quot;my_analyzer&quot;: &#123;  // 分词器名称</span><br><span class="line">          &quot;tokenizer&quot;: &quot;ik_max_word&quot;,</span><br><span class="line">          &quot;filter&quot;: &quot;py&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;filter&quot;: &#123;   // 自定义tokenizer filter</span><br><span class="line">        &quot;py&quot;: &#123;  // 过滤器名称</span><br><span class="line">          &quot;type&quot;: &quot;pinyin&quot;, // 过滤器类型，这里是pinyin</span><br><span class="line">		  &quot;keep_full_pinyin&quot;: false,</span><br><span class="line">          &quot;keep_joined_full_pinyin&quot;: true,</span><br><span class="line">          &quot;keep_original&quot;: true,</span><br><span class="line">          &quot;limit_first_letter_length&quot;: 16,</span><br><span class="line">          &quot;remove_duplicated_term&quot;: true,</span><br><span class="line">          &quot;none_chinese_pinyin_tokenize&quot;: false</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;analyzer&quot;: &quot;my_analyzer&quot;,</span><br><span class="line">        &quot;search_analyzer&quot;: &quot;ik_smart&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试验证</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205174024486-1094893452.png" alt="image"></p>
<h2 id="自动补全查询"><a href="#自动补全查询" class="headerlink" title="自动补全查询"></a>自动补全查询</h2><blockquote>
<p>三步骤：</p>
<p>① 创建索引库</p>
<p>② 插入数据</p>
<p>③ 查询的DSL语句</p>
</blockquote>
<p>elasticsearch提供了<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.12/search-suggesters.html">Completion Suggester</a> 查询来实现自动补全功能。这个查询会匹配以用户输入内容开头的词条并返回。为了提高补全查询的效率，对于文档中字段的类型有一些约束：</p>
<ul>
<li><p>参与补全查询的字段必须是completion类型。</p>
</li>
<li><p>字段的内容一般是用来补全的多个词条形成的数组。</p>
</li>
</ul>
<p>比如，索引库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PUT /pinyintest/_mapping</span><br><span class="line">&#123;</span><br><span class="line">  &quot;properties&quot;:&#123;</span><br><span class="line">    &quot;title&quot; : &#123;</span><br><span class="line">      &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>插入数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">POST pinyintest/_doc</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;: [&quot;honor&quot;, &quot;vivo&quot;]</span><br><span class="line">&#125;</span><br><span class="line">POST pinyintest/_doc</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;: [&quot;apple&quot;, &quot;xiaomi&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查询的DSL语句如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 自动补全查询</span><br><span class="line">GET /test/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;suggest&quot;: &#123;</span><br><span class="line">    &quot;title_suggest&quot;: &#123;	//设置这个自动查询操作的名称</span><br><span class="line">      &quot;text&quot;: &quot;s&quot;, // 关键字</span><br><span class="line">      &quot;completion&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;title&quot;, // 补全查询的字段名</span><br><span class="line">        &quot;skip_duplicates&quot;: true, // 跳过重复的</span><br><span class="line">        &quot;size&quot;: 10 // 获取前10条结果</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自动补全嵌入项目"><a href="#自动补全嵌入项目" class="headerlink" title="自动补全嵌入项目"></a>自动补全嵌入项目</h2><h3 id="修改索引库映射结构"><a href="#修改索引库映射结构" class="headerlink" title="修改索引库映射结构"></a>修改索引库映射结构</h3><blockquote>
<p>重点注意：</p>
<p>① all、name字段等要分词设置为自定义分词器(“analyzer”: “text_anlyzer”)（一般要分词，然后再对分词后的词语进行拼音处理），查询设置为最精简分词器(“search_analyzer”: “ik_smart”)</p>
<p>② 设置一个自动补全字段(如 suggestion) 类型必须为：completion，并且使用自定义分词器（一般不分词直接对整个词语进行拼音处理）</p>
</blockquote>
<p>先删除之前的索引库，再设置如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 酒店数据索引库</span></span><br><span class="line">PUT /hotel</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;analysis&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;text_anlyzer&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;tokenizer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;py&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;completion_analyzer&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;tokenizer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;py&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;py&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pinyin&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;keep_full_pinyin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;keep_joined_full_pinyin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;keep_original&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;limit_first_letter_length&quot;</span><span class="punctuation">:</span> <span class="number">16</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;remove_duplicated_term&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;none_chinese_pinyin_tokenize&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text_anlyzer&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;search_analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;copy_to&quot;</span><span class="punctuation">:</span> <span class="string">&quot;all&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;score&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;copy_to&quot;</span><span class="punctuation">:</span> <span class="string">&quot;all&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;starName&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;business&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;copy_to&quot;</span><span class="punctuation">:</span> <span class="string">&quot;all&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;location&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;geo_point&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;pic&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;all&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text_anlyzer&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;search_analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;suggestion&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;completion&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;completion_analyzer&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="修改实体类"><a href="#修改实体类" class="headerlink" title="修改实体类"></a>修改实体类</h3><blockquote>
<p>类型为completion的字段需要在构造方法里做组装</p>
</blockquote>
<p>HotelDoc中要添加一个字段，用来做自动补全，内容可以是酒店品牌、城市、商圈等信息。按照自动补全字段的要求，最好是这些字段的数组。</p>
<p>因此我们在HotelDoc中添加一个suggestion字段，类型为<code>List&lt;String&gt;</code>，然后将brand、city、business等信息放到里面。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelDoc</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String starName;</span><br><span class="line">    <span class="keyword">private</span> String business;</span><br><span class="line">    <span class="keyword">private</span> String location;</span><br><span class="line">    <span class="keyword">private</span> String pic;</span><br><span class="line">    <span class="keyword">private</span> Object distance;</span><br><span class="line">    <span class="keyword">private</span> Boolean isAD;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; suggestion;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HotelDoc</span><span class="params">(Hotel hotel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = hotel.getId();</span><br><span class="line">        <span class="built_in">this</span>.name = hotel.getName();</span><br><span class="line">        <span class="built_in">this</span>.address = hotel.getAddress();</span><br><span class="line">        <span class="built_in">this</span>.price = hotel.getPrice();</span><br><span class="line">        <span class="built_in">this</span>.score = hotel.getScore();</span><br><span class="line">        <span class="built_in">this</span>.brand = hotel.getBrand();</span><br><span class="line">        <span class="built_in">this</span>.city = hotel.getCity();</span><br><span class="line">        <span class="built_in">this</span>.starName = hotel.getStarName();</span><br><span class="line">        <span class="built_in">this</span>.business = hotel.getBusiness();</span><br><span class="line">        <span class="built_in">this</span>.location = hotel.getLatitude() + <span class="string">&quot;, &quot;</span> + hotel.getLongitude();</span><br><span class="line">        <span class="built_in">this</span>.pic = hotel.getPic();</span><br><span class="line">        <span class="comment">// 组装suggestion</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.business.contains(<span class="string">&quot;/&quot;</span>))&#123;</span><br><span class="line">            <span class="comment">// business有多个值，需要切割</span></span><br><span class="line">            String[] arr = <span class="built_in">this</span>.business.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">            <span class="comment">// 添加元素</span></span><br><span class="line">            <span class="built_in">this</span>.suggestion = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="built_in">this</span>.suggestion.add(<span class="built_in">this</span>.brand);</span><br><span class="line">            Collections.addAll(<span class="built_in">this</span>.suggestion, arr);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.suggestion = Arrays.asList(<span class="built_in">this</span>.brand, <span class="built_in">this</span>.business);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重新导入数据"><a href="#重新导入数据" class="headerlink" title="重新导入数据"></a>重新导入数据</h3><p>先删除数据，再重新执行之前编写的导入数据功能，可以看到新的酒店数据中包含了suggestion：</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205174055585-873118927.png" alt="image"></p>
<h3 id="自动补全的JavaAPI"><a href="#自动补全的JavaAPI" class="headerlink" title="自动补全的JavaAPI"></a>自动补全的JavaAPI</h3><p>示例：</p>
<p><strong>查询代码如下：</strong></p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205174142619-1304761758.png" alt="image"></p>
<p><strong>解析结果代码如下：</strong></p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205174149201-911882808.png" alt="image"></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试自动补全</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCompletion</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;pinyintest&quot;</span>);</span><br><span class="line">    request.source().suggest(<span class="keyword">new</span> <span class="title class_">SuggestBuilder</span>().addSuggestion(</span><br><span class="line">            <span class="string">&quot;titleSuggestion&quot;</span>,  <span class="comment">//设置这个自动补全操作的名称</span></span><br><span class="line">            SuggestBuilders.completionSuggestion(<span class="string">&quot;title&quot;</span>) <span class="comment">//类型为completion的字段名</span></span><br><span class="line">                    .prefix(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">                    .skipDuplicates(<span class="literal">true</span>)</span><br><span class="line">                    .size(<span class="number">10</span>)</span><br><span class="line">    ));</span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    log.info(<span class="string">&quot;查询结果为 &#123;&#125;&quot;</span>, response.toString());</span><br><span class="line">    <span class="type">Suggest</span> <span class="variable">suggest</span> <span class="operator">=</span> response.getSuggest();</span><br><span class="line">    <span class="type">CompletionSuggestion</span> <span class="variable">completionSuggestion</span> <span class="operator">=</span> suggest.getSuggestion(<span class="string">&quot;titleSuggestion&quot;</span>);</span><br><span class="line">    List&lt;CompletionSuggestion.Entry.Option&gt; list = completionSuggestion.getOptions();</span><br><span class="line">    <span class="keyword">for</span> (CompletionSuggestion.Entry.Option option : list) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;自动补全的词为 &#123;&#125;&quot;</span>, option.getText().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ES与Mysql数据同步"><a href="#ES与Mysql数据同步" class="headerlink" title="ES与Mysql数据同步"></a>ES与Mysql数据同步</h1><p>elasticsearch中的数据来自于mysql数据库，因此mysql数据发生改变时，elasticsearch也必须跟着改变，这个就是elasticsearch与mysql之间的数据同步。</p>
<p>在微服务中， 负责数据增删改查的业务和负责搜索的业务可能在不同的微服务上面，数据同步该如何实现呢？</p>
<h2 id="三种方法"><a href="#三种方法" class="headerlink" title="三种方法"></a>三种方法</h2><p>常见的数据同步方案有三种：</p>
<ul>
<li>同步调用</li>
<li>异步通知</li>
<li>监听binlog</li>
</ul>
<p>方式一：同步调用</p>
<ul>
<li>优点：实现简单，粗暴</li>
<li>缺点：业务耦合度高</li>
</ul>
<p>方式二：异步通知【常用】</p>
<ul>
<li>优点：低耦合，实现难度一般</li>
<li>缺点：依赖mq的可靠性</li>
</ul>
<p>方式三：监听binlog</p>
<ul>
<li>优点：完全解除服务间耦合</li>
<li>缺点：开启binlog增加数据库负担、实现复杂度高</li>
</ul>
<h3 id="同步调用"><a href="#同步调用" class="headerlink" title="同步调用"></a>同步调用</h3><p>方案一：同步调用</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205174204697-1782713458.png" alt="image"></p>
<p>基本步骤如下：</p>
<ul>
<li>hotel-demo对外提供接口，用来修改elasticsearch中的数据</li>
<li>酒店管理服务在完成数据库操作后，直接调用hotel-demo提供的接口</li>
</ul>
<h3 id="异步通知"><a href="#异步通知" class="headerlink" title="异步通知"></a>异步通知</h3><p>方案二：异步通知</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205174208679-699617903.png" alt="image"></p>
<p>流程如下：</p>
<ul>
<li>hotel-admin对mysql数据库数据完成增、删、改后，发送MQ消息</li>
<li>hotel-demo监听MQ，接收到消息后完成elasticsearch数据修改</li>
</ul>
<h3 id="监听binlog"><a href="#监听binlog" class="headerlink" title="监听binlog"></a>监听binlog</h3><p>方案三：监听binlog</p>
<p><img data-src="/hexoblog/images/java/es/2729274-20230205174214464-753366960.png" alt="image"></p>
<p>流程如下：</p>
<ul>
<li>给mysql开启binlog功能</li>
<li>mysql完成增、删、改操作都会记录在binlog中</li>
<li>hotel-demo基于canal监听binlog变化，实时更新elasticsearch中的内容</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>shardingsphere</tag>
      </tags>
  </entry>
</search>
